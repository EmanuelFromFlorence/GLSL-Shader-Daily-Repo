(()=>{"use strict";var e={d:(t,n)=>{for(var i in n)e.o(n,i)&&!e.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:n[i]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{animation:()=>Yc,color:()=>Vc,distort:()=>kc,draw:()=>jc,filter:()=>Xc,generative:()=>qc,math:()=>Kc,operation:()=>Zc,sample:()=>Jc,sdf:()=>Qc,space:()=>$c});const n=100,i=1e3,o=1001,r=1002,a=1003,s=1006,c=1008,l=1012,d=1014,h=1015,f=1016,u=1020,p=1022,m=1023,g=1026,E=1027,T=2300,v=2301,A=2302,R=2400,I=2401,O=2402,S=3e3,N=3001,b=7680,y=35044,x=35048,L="300 es";function _(){}Object.assign(_.prototype,{addEventListener:function(e,t){void 0===this._listeners&&(this._listeners={});const n=this._listeners;void 0===n[e]&&(n[e]=[]),-1===n[e].indexOf(t)&&n[e].push(t)},hasEventListener:function(e,t){if(void 0===this._listeners)return!1;const n=this._listeners;return void 0!==n[e]&&-1!==n[e].indexOf(t)},removeEventListener:function(e,t){if(void 0===this._listeners)return;const n=this._listeners[e];if(void 0!==n){const e=n.indexOf(t);-1!==e&&n.splice(e,1)}},dispatchEvent:function(e){if(void 0===this._listeners)return;const t=this._listeners[e.type];if(void 0!==t){e.target=this;const n=t.slice(0);for(let t=0,i=n.length;t<i;t++)n[t].call(this,e)}}});const w=[];for(let e=0;e<256;e++)w[e]=(e<16?"0":"")+e.toString(16);let C=1234567;const M={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){const e=4294967295*Math.random()|0,t=4294967295*Math.random()|0,n=4294967295*Math.random()|0,i=4294967295*Math.random()|0;return(w[255&e]+w[e>>8&255]+w[e>>16&255]+w[e>>24&255]+"-"+w[255&t]+w[t>>8&255]+"-"+w[t>>16&15|64]+w[t>>24&255]+"-"+w[63&n|128]+w[n>>8&255]+"-"+w[n>>16&255]+w[n>>24&255]+w[255&i]+w[i>>8&255]+w[i>>16&255]+w[i>>24&255]).toUpperCase()},clamp:function(e,t,n){return Math.max(t,Math.min(n,e))},euclideanModulo:function(e,t){return(e%t+t)%t},mapLinear:function(e,t,n,i,o){return i+(e-t)*(o-i)/(n-t)},lerp:function(e,t,n){return(1-n)*e+n*t},damp:function(e,t,n,i){return M.lerp(e,t,1-Math.exp(-n*i))},pingpong:function(e,t=1){return t-Math.abs(M.euclideanModulo(e,2*t)-t)},smoothstep:function(e,t,n){return e<=t?0:e>=n?1:(e=(e-t)/(n-t))*e*(3-2*e)},smootherstep:function(e,t,n){return e<=t?0:e>=n?1:(e=(e-t)/(n-t))*e*e*(e*(6*e-15)+10)},randInt:function(e,t){return e+Math.floor(Math.random()*(t-e+1))},randFloat:function(e,t){return e+Math.random()*(t-e)},randFloatSpread:function(e){return e*(.5-Math.random())},seededRandom:function(e){return void 0!==e&&(C=e%2147483647),C=16807*C%2147483647,(C-1)/2147483646},degToRad:function(e){return e*M.DEG2RAD},radToDeg:function(e){return e*M.RAD2DEG},isPowerOfTwo:function(e){return 0==(e&e-1)&&0!==e},ceilPowerOfTwo:function(e){return Math.pow(2,Math.ceil(Math.log(e)/Math.LN2))},floorPowerOfTwo:function(e){return Math.pow(2,Math.floor(Math.log(e)/Math.LN2))},setQuaternionFromProperEuler:function(e,t,n,i,o){const r=Math.cos,a=Math.sin,s=r(n/2),c=a(n/2),l=r((t+i)/2),d=a((t+i)/2),h=r((t-i)/2),f=a((t-i)/2),u=r((i-t)/2),p=a((i-t)/2);switch(o){case"XYX":e.set(s*d,c*h,c*f,s*l);break;case"YZY":e.set(c*f,s*d,c*h,s*l);break;case"ZXZ":e.set(c*h,c*f,s*d,s*l);break;case"XZX":e.set(s*d,c*p,c*u,s*l);break;case"YXY":e.set(c*u,s*d,c*p,s*l);break;case"ZYZ":e.set(c*p,c*u,s*d,s*l);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+o)}}};class D{constructor(e=0,t=0){Object.defineProperty(this,"isVector2",{value:!0}),this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e,t){return void 0!==t?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this)}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e,t){return void 0!==t?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this)}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,n=this.y,i=e.elements;return this.x=i[0]*t+i[3]*n+i[6],this.y=i[1]*t+i[4]*n+i[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y;return t*t+n*n}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t,n){return void 0!==n&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const n=Math.cos(t),i=Math.sin(t),o=this.x-e.x,r=this.y-e.y;return this.x=o*n-r*i+e.x,this.y=o*i+r*n+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}}class P{constructor(){Object.defineProperty(this,"isMatrix3",{value:!0}),this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,i,o,r,a,s,c){const l=this.elements;return l[0]=e,l[1]=i,l[2]=a,l[3]=t,l[4]=o,l[5]=s,l[6]=n,l[7]=r,l[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}clone(){return(new this.constructor).fromArray(this.elements)}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],this}extractBasis(e,t,n){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,i=t.elements,o=this.elements,r=n[0],a=n[3],s=n[6],c=n[1],l=n[4],d=n[7],h=n[2],f=n[5],u=n[8],p=i[0],m=i[3],g=i[6],E=i[1],T=i[4],v=i[7],A=i[2],R=i[5],I=i[8];return o[0]=r*p+a*E+s*A,o[3]=r*m+a*T+s*R,o[6]=r*g+a*v+s*I,o[1]=c*p+l*E+d*A,o[4]=c*m+l*T+d*R,o[7]=c*g+l*v+d*I,o[2]=h*p+f*E+u*A,o[5]=h*m+f*T+u*R,o[8]=h*g+f*v+u*I,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[1],i=e[2],o=e[3],r=e[4],a=e[5],s=e[6],c=e[7],l=e[8];return t*r*l-t*a*c-n*o*l+n*a*s+i*o*c-i*r*s}invert(){const e=this.elements,t=e[0],n=e[1],i=e[2],o=e[3],r=e[4],a=e[5],s=e[6],c=e[7],l=e[8],d=l*r-a*c,h=a*s-l*o,f=c*o-r*s,u=t*d+n*h+i*f;if(0===u)return this.set(0,0,0,0,0,0,0,0,0);const p=1/u;return e[0]=d*p,e[1]=(i*c-l*n)*p,e[2]=(a*n-i*r)*p,e[3]=h*p,e[4]=(l*t-i*s)*p,e[5]=(i*o-a*t)*p,e[6]=f*p,e[7]=(n*s-c*t)*p,e[8]=(r*t-n*o)*p,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).copy(this).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,n,i,o,r,a){const s=Math.cos(o),c=Math.sin(o);return this.set(n*s,n*c,-n*(s*r+c*a)+r+e,-i*c,i*s,-i*(-c*r+s*a)+a+t,0,0,1),this}scale(e,t){const n=this.elements;return n[0]*=e,n[3]*=e,n[6]*=e,n[1]*=t,n[4]*=t,n[7]*=t,this}rotate(e){const t=Math.cos(e),n=Math.sin(e),i=this.elements,o=i[0],r=i[3],a=i[6],s=i[1],c=i[4],l=i[7];return i[0]=t*o+n*s,i[3]=t*r+n*c,i[6]=t*a+n*l,i[1]=-n*o+t*s,i[4]=-n*r+t*c,i[7]=-n*a+t*l,this}translate(e,t){const n=this.elements;return n[0]+=e*n[2],n[3]+=e*n[5],n[6]+=e*n[8],n[1]+=t*n[2],n[4]+=t*n[5],n[7]+=t*n[8],this}equals(e){const t=this.elements,n=e.elements;for(let e=0;e<9;e++)if(t[e]!==n[e])return!1;return!0}fromArray(e,t=0){for(let n=0;n<9;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e}}let F;const H={getDataURL:function(e){if(/^data:/i.test(e.src))return e.src;if("undefined"==typeof HTMLCanvasElement)return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{void 0===F&&(F=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),F.width=e.width,F.height=e.height;const n=F.getContext("2d");e instanceof ImageData?n.putImageData(e,0,0):n.drawImage(e,0,0,e.width,e.height),t=F}return t.width>2048||t.height>2048?t.toDataURL("image/jpeg",.6):t.toDataURL("image/png")}};let U=0;function B(e=B.DEFAULT_IMAGE,t=B.DEFAULT_MAPPING,n=1001,i=1001,o=1006,r=1008,a=1023,s=1009,c=1,l=3e3){Object.defineProperty(this,"id",{value:U++}),this.uuid=M.generateUUID(),this.name="",this.image=e,this.mipmaps=[],this.mapping=t,this.wrapS=n,this.wrapT=i,this.magFilter=o,this.minFilter=r,this.anisotropy=c,this.format=a,this.internalFormat=null,this.type=s,this.offset=new D(0,0),this.repeat=new D(1,1),this.center=new D(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new P,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=l,this.version=0,this.onUpdate=null}function z(e){return"undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap?H.getDataURL(e):e.data?{data:Array.prototype.slice.call(e.data),width:e.width,height:e.height,type:e.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}B.DEFAULT_IMAGE=void 0,B.DEFAULT_MAPPING=300,B.prototype=Object.assign(Object.create(_.prototype),{constructor:B,isTexture:!0,updateMatrix:function(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)},clone:function(){return(new this.constructor).copy(this)},copy:function(e){return this.name=e.name,this.image=e.image,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this},toJSON:function(e){const t=void 0===e||"string"==typeof e;if(!t&&void 0!==e.textures[this.uuid])return e.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(void 0!==this.image){const i=this.image;if(void 0===i.uuid&&(i.uuid=M.generateUUID()),!t&&void 0===e.images[i.uuid]){let t;if(Array.isArray(i)){t=[];for(let e=0,n=i.length;e<n;e++)i[e].isDataTexture?t.push(z(i[e].image)):t.push(z(i[e]))}else t=z(i);e.images[i.uuid]={uuid:i.uuid,url:t}}n.image=i.uuid}return t||(e.textures[this.uuid]=n),n},dispose:function(){this.dispatchEvent({type:"dispose"})},transformUv:function(e){if(300!==this.mapping)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case i:e.x=e.x-Math.floor(e.x);break;case o:e.x=e.x<0?0:1;break;case r:1===Math.abs(Math.floor(e.x)%2)?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x)}if(e.y<0||e.y>1)switch(this.wrapT){case i:e.y=e.y-Math.floor(e.y);break;case o:e.y=e.y<0?0:1;break;case r:1===Math.abs(Math.floor(e.y)%2)?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y)}return this.flipY&&(e.y=1-e.y),e}}),Object.defineProperty(B.prototype,"needsUpdate",{set:function(e){!0===e&&this.version++}});class G{constructor(e=0,t=0,n=0,i=1){Object.defineProperty(this,"isVector4",{value:!0}),this.x=e,this.y=t,this.z=n,this.w=i}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,n,i){return this.x=e,this.y=t,this.z=n,this.w=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=void 0!==e.w?e.w:1,this}add(e,t){return void 0!==t?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e,t){return void 0!==t?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,n=this.y,i=this.z,o=this.w,r=e.elements;return this.x=r[0]*t+r[4]*n+r[8]*i+r[12]*o,this.y=r[1]*t+r[5]*n+r[9]*i+r[13]*o,this.z=r[2]*t+r[6]*n+r[10]*i+r[14]*o,this.w=r[3]*t+r[7]*n+r[11]*i+r[15]*o,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,n,i,o;const r=.01,a=.1,s=e.elements,c=s[0],l=s[4],d=s[8],h=s[1],f=s[5],u=s[9],p=s[2],m=s[6],g=s[10];if(Math.abs(l-h)<r&&Math.abs(d-p)<r&&Math.abs(u-m)<r){if(Math.abs(l+h)<a&&Math.abs(d+p)<a&&Math.abs(u+m)<a&&Math.abs(c+f+g-3)<a)return this.set(1,0,0,0),this;t=Math.PI;const e=(c+1)/2,s=(f+1)/2,E=(g+1)/2,T=(l+h)/4,v=(d+p)/4,A=(u+m)/4;return e>s&&e>E?e<r?(n=0,i=.707106781,o=.707106781):(n=Math.sqrt(e),i=T/n,o=v/n):s>E?s<r?(n=.707106781,i=0,o=.707106781):(i=Math.sqrt(s),n=T/i,o=A/i):E<r?(n=.707106781,i=.707106781,o=0):(o=Math.sqrt(E),n=v/o,i=A/o),this.set(n,i,o,t),this}let E=Math.sqrt((m-u)*(m-u)+(d-p)*(d-p)+(h-l)*(h-l));return Math.abs(E)<.001&&(E=1),this.x=(m-u)/E,this.y=(d-p)/E,this.z=(h-l)/E,this.w=Math.acos((c+f+g-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this.w=e.w+(t.w-e.w)*n,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t,n){return void 0!==n&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}}class W extends _{constructor(e,t,n){super(),Object.defineProperty(this,"isWebGLRenderTarget",{value:!0}),this.width=e,this.height=t,this.scissor=new G(0,0,e,t),this.scissorTest=!1,this.viewport=new G(0,0,e,t),n=n||{},this.texture=new B(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.image={},this.texture.image.width=e,this.texture.image.height=t,this.texture.generateMipmaps=void 0!==n.generateMipmaps&&n.generateMipmaps,this.texture.minFilter=void 0!==n.minFilter?n.minFilter:s,this.depthBuffer=void 0===n.depthBuffer||n.depthBuffer,this.stencilBuffer=void 0!==n.stencilBuffer&&n.stencilBuffer,this.depthTexture=void 0!==n.depthTexture?n.depthTexture:null}setSize(e,t){this.width===e&&this.height===t||(this.width=e,this.height=t,this.texture.image.width=e,this.texture.image.height=t,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return(new this.constructor).copy(this)}copy(e){return this.width=e.width,this.height=e.height,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.depthTexture=e.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}class Y{constructor(e=0,t=0,n=0,i=1){Object.defineProperty(this,"isQuaternion",{value:!0}),this._x=e,this._y=t,this._z=n,this._w=i}static slerp(e,t,n,i){return n.copy(e).slerp(t,i)}static slerpFlat(e,t,n,i,o,r,a){let s=n[i+0],c=n[i+1],l=n[i+2],d=n[i+3];const h=o[r+0],f=o[r+1],u=o[r+2],p=o[r+3];if(d!==p||s!==h||c!==f||l!==u){let e=1-a;const t=s*h+c*f+l*u+d*p,n=t>=0?1:-1,i=1-t*t;if(i>Number.EPSILON){const o=Math.sqrt(i),r=Math.atan2(o,t*n);e=Math.sin(e*r)/o,a=Math.sin(a*r)/o}const o=a*n;if(s=s*e+h*o,c=c*e+f*o,l=l*e+u*o,d=d*e+p*o,e===1-a){const e=1/Math.sqrt(s*s+c*c+l*l+d*d);s*=e,c*=e,l*=e,d*=e}}e[t]=s,e[t+1]=c,e[t+2]=l,e[t+3]=d}static multiplyQuaternionsFlat(e,t,n,i,o,r){const a=n[i],s=n[i+1],c=n[i+2],l=n[i+3],d=o[r],h=o[r+1],f=o[r+2],u=o[r+3];return e[t]=a*u+l*d+s*f-c*h,e[t+1]=s*u+l*h+c*d-a*f,e[t+2]=c*u+l*f+a*h-s*d,e[t+3]=l*u-a*d-s*h-c*f,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,n,i){return this._x=e,this._y=t,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){if(!e||!e.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=e._x,i=e._y,o=e._z,r=e._order,a=Math.cos,s=Math.sin,c=a(n/2),l=a(i/2),d=a(o/2),h=s(n/2),f=s(i/2),u=s(o/2);switch(r){case"XYZ":this._x=h*l*d+c*f*u,this._y=c*f*d-h*l*u,this._z=c*l*u+h*f*d,this._w=c*l*d-h*f*u;break;case"YXZ":this._x=h*l*d+c*f*u,this._y=c*f*d-h*l*u,this._z=c*l*u-h*f*d,this._w=c*l*d+h*f*u;break;case"ZXY":this._x=h*l*d-c*f*u,this._y=c*f*d+h*l*u,this._z=c*l*u+h*f*d,this._w=c*l*d-h*f*u;break;case"ZYX":this._x=h*l*d-c*f*u,this._y=c*f*d+h*l*u,this._z=c*l*u-h*f*d,this._w=c*l*d+h*f*u;break;case"YZX":this._x=h*l*d+c*f*u,this._y=c*f*d+h*l*u,this._z=c*l*u-h*f*d,this._w=c*l*d-h*f*u;break;case"XZY":this._x=h*l*d-c*f*u,this._y=c*f*d-h*l*u,this._z=c*l*u+h*f*d,this._w=c*l*d+h*f*u;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+r)}return!1!==t&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const n=t/2,i=Math.sin(n);return this._x=e.x*i,this._y=e.y*i,this._z=e.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,n=t[0],i=t[4],o=t[8],r=t[1],a=t[5],s=t[9],c=t[2],l=t[6],d=t[10],h=n+a+d;if(h>0){const e=.5/Math.sqrt(h+1);this._w=.25/e,this._x=(l-s)*e,this._y=(o-c)*e,this._z=(r-i)*e}else if(n>a&&n>d){const e=2*Math.sqrt(1+n-a-d);this._w=(l-s)/e,this._x=.25*e,this._y=(i+r)/e,this._z=(o+c)/e}else if(a>d){const e=2*Math.sqrt(1+a-n-d);this._w=(o-c)/e,this._x=(i+r)/e,this._y=.25*e,this._z=(s+l)/e}else{const e=2*Math.sqrt(1+d-n-a);this._w=(r-i)/e,this._x=(o+c)/e,this._y=(s+l)/e,this._z=.25*e}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let n=e.dot(t)+1;return n<1e-6?(n=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=n):(this._x=0,this._y=-e.z,this._z=e.y,this._w=n)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=n),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(M.clamp(this.dot(e),-1,1)))}rotateTowards(e,t){const n=this.angleTo(e);if(0===n)return this;const i=Math.min(1,t/n);return this.slerp(e,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return 0===e?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e,t){return void 0!==t?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(e,t)):this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const n=e._x,i=e._y,o=e._z,r=e._w,a=t._x,s=t._y,c=t._z,l=t._w;return this._x=n*l+r*a+i*c-o*s,this._y=i*l+r*s+o*a-n*c,this._z=o*l+r*c+n*s-i*a,this._w=r*l-n*a-i*s-o*c,this._onChangeCallback(),this}slerp(e,t){if(0===t)return this;if(1===t)return this.copy(e);const n=this._x,i=this._y,o=this._z,r=this._w;let a=r*e._w+n*e._x+i*e._y+o*e._z;if(a<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,a=-a):this.copy(e),a>=1)return this._w=r,this._x=n,this._y=i,this._z=o,this;const s=1-a*a;if(s<=Number.EPSILON){const e=1-t;return this._w=e*r+t*this._w,this._x=e*n+t*this._x,this._y=e*i+t*this._y,this._z=e*o+t*this._z,this.normalize(),this._onChangeCallback(),this}const c=Math.sqrt(s),l=Math.atan2(c,a),d=Math.sin((1-t)*l)/c,h=Math.sin(t*l)/c;return this._w=r*d+this._w*h,this._x=n*d+this._x*h,this._y=i*d+this._y*h,this._z=o*d+this._z*h,this._onChangeCallback(),this}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}class V{constructor(e=0,t=0,n=0){Object.defineProperty(this,"isVector3",{value:!0}),this.x=e,this.y=t,this.z=n}set(e,t,n){return void 0===n&&(n=this.z),this.x=e,this.y=t,this.z=n,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e,t){return void 0!==t?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e,t){return void 0!==t?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e,t){return void 0!==t?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(e,t)):(this.x*=e.x,this.y*=e.y,this.z*=e.z,this)}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return e&&e.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(j.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(j.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,n=this.y,i=this.z,o=e.elements;return this.x=o[0]*t+o[3]*n+o[6]*i,this.y=o[1]*t+o[4]*n+o[7]*i,this.z=o[2]*t+o[5]*n+o[8]*i,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,n=this.y,i=this.z,o=e.elements,r=1/(o[3]*t+o[7]*n+o[11]*i+o[15]);return this.x=(o[0]*t+o[4]*n+o[8]*i+o[12])*r,this.y=(o[1]*t+o[5]*n+o[9]*i+o[13])*r,this.z=(o[2]*t+o[6]*n+o[10]*i+o[14])*r,this}applyQuaternion(e){const t=this.x,n=this.y,i=this.z,o=e.x,r=e.y,a=e.z,s=e.w,c=s*t+r*i-a*n,l=s*n+a*t-o*i,d=s*i+o*n-r*t,h=-o*t-r*n-a*i;return this.x=c*s+h*-o+l*-a-d*-r,this.y=l*s+h*-r+d*-o-c*-a,this.z=d*s+h*-a+c*-r-l*-o,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,n=this.y,i=this.z,o=e.elements;return this.x=o[0]*t+o[4]*n+o[8]*i,this.y=o[1]*t+o[5]*n+o[9]*i,this.z=o[2]*t+o[6]*n+o[10]*i,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this}cross(e,t){return void 0!==t?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(e,t)):this.crossVectors(this,e)}crossVectors(e,t){const n=e.x,i=e.y,o=e.z,r=t.x,a=t.y,s=t.z;return this.x=i*s-o*a,this.y=o*r-n*s,this.z=n*a-i*r,this}projectOnVector(e){const t=e.lengthSq();if(0===t)return this.set(0,0,0);const n=e.dot(this)/t;return this.copy(e).multiplyScalar(n)}projectOnPlane(e){return k.copy(this).projectOnVector(e),this.sub(k)}reflect(e){return this.sub(k.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(0===t)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(M.clamp(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y,i=this.z-e.z;return t*t+n*n+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,n){const i=Math.sin(t)*e;return this.x=i*Math.sin(n),this.y=Math.cos(t)*e,this.z=i*Math.cos(n),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,n){return this.x=e*Math.sin(t),this.y=n,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),n=this.setFromMatrixColumn(e,1).length(),i=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=n,this.z=i,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,4*t)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,3*t)}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t,n){return void 0!==n&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}}const k=new V,j=new Y;class X{constructor(e,t){Object.defineProperty(this,"isBox3",{value:!0}),this.min=void 0!==e?e:new V(1/0,1/0,1/0),this.max=void 0!==t?t:new V(-1/0,-1/0,-1/0)}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,n=1/0,i=1/0,o=-1/0,r=-1/0,a=-1/0;for(let s=0,c=e.length;s<c;s+=3){const c=e[s],l=e[s+1],d=e[s+2];c<t&&(t=c),l<n&&(n=l),d<i&&(i=d),c>o&&(o=c),l>r&&(r=l),d>a&&(a=d)}return this.min.set(t,n,i),this.max.set(o,r,a),this}setFromBufferAttribute(e){let t=1/0,n=1/0,i=1/0,o=-1/0,r=-1/0,a=-1/0;for(let s=0,c=e.count;s<c;s++){const c=e.getX(s),l=e.getY(s),d=e.getZ(s);c<t&&(t=c),l<n&&(n=l),d<i&&(i=d),c>o&&(o=c),l>r&&(r=l),d>a&&(a=d)}return this.min.set(t,n,i),this.max.set(o,r,a),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=Z.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}setFromObject(e){return this.makeEmpty(),this.expandByObject(e)}clone(){return(new this.constructor).copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return void 0===e&&(console.warn("THREE.Box3: .getCenter() target is now required"),e=new V),this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return void 0===e&&(console.warn("THREE.Box3: .getSize() target is now required"),e=new V),this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e){e.updateWorldMatrix(!1,!1);const t=e.geometry;void 0!==t&&(null===t.boundingBox&&t.computeBoundingBox(),J.copy(t.boundingBox),J.applyMatrix4(e.matrixWorld),this.union(J));const n=e.children;for(let e=0,t=n.length;e<t;e++)this.expandByObject(n[e]);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return void 0===t&&(console.warn("THREE.Box3: .getParameter() target is now required"),t=new V),t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,Z),Z.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,n;return e.normal.x>0?(t=e.normal.x*this.min.x,n=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,n=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,n+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,n+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,n+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,n+=e.normal.z*this.min.z),t<=-e.constant&&n>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(oe),re.subVectors(this.max,oe),Q.subVectors(e.a,oe),$.subVectors(e.b,oe),ee.subVectors(e.c,oe),te.subVectors($,Q),ne.subVectors(ee,$),ie.subVectors(Q,ee);let t=[0,-te.z,te.y,0,-ne.z,ne.y,0,-ie.z,ie.y,te.z,0,-te.x,ne.z,0,-ne.x,ie.z,0,-ie.x,-te.y,te.x,0,-ne.y,ne.x,0,-ie.y,ie.x,0];return!!q(t,Q,$,ee,re)&&(t=[1,0,0,0,1,0,0,0,1],!!q(t,Q,$,ee,re)&&(ae.crossVectors(te,ne),t=[ae.x,ae.y,ae.z],q(t,Q,$,ee,re)))}clampPoint(e,t){return void 0===t&&(console.warn("THREE.Box3: .clampPoint() target is now required"),t=new V),t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return Z.copy(e).clamp(this.min,this.max).sub(e).length()}getBoundingSphere(e){return void 0===e&&console.error("THREE.Box3: .getBoundingSphere() target is now required"),this.getCenter(e.center),e.radius=.5*this.getSize(Z).length(),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()||(K[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),K[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),K[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),K[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),K[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),K[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),K[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),K[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(K)),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}function q(e,t,n,i,o){for(let r=0,a=e.length-3;r<=a;r+=3){se.fromArray(e,r);const a=o.x*Math.abs(se.x)+o.y*Math.abs(se.y)+o.z*Math.abs(se.z),s=t.dot(se),c=n.dot(se),l=i.dot(se);if(Math.max(-Math.max(s,c,l),Math.min(s,c,l))>a)return!1}return!0}const K=[new V,new V,new V,new V,new V,new V,new V,new V],Z=new V,J=new X,Q=new V,$=new V,ee=new V,te=new V,ne=new V,ie=new V,oe=new V,re=new V,ae=new V,se=new V,ce=new X;class le{constructor(e,t){this.center=void 0!==e?e:new V,this.radius=void 0!==t?t:-1}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const n=this.center;void 0!==t?n.copy(t):ce.setFromPoints(e).getCenter(n);let i=0;for(let t=0,o=e.length;t<o;t++)i=Math.max(i,n.distanceToSquared(e[t]));return this.radius=Math.sqrt(i),this}clone(){return(new this.constructor).copy(this)}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const n=this.center.distanceToSquared(e);return void 0===t&&(console.warn("THREE.Sphere: .clampPoint() target is now required"),t=new V),t.copy(e),n>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return void 0===e&&(console.warn("THREE.Sphere: .getBoundingBox() target is now required"),e=new X),this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}}const de=new V,he=new V,fe=new V,ue=new V,pe=new V,me=new V,ge=new V;class Ee{constructor(e,t){this.origin=void 0!==e?e:new V,this.direction=void 0!==t?t:new V(0,0,-1)}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}clone(){return(new this.constructor).copy(this)}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return void 0===t&&(console.warn("THREE.Ray: .at() target is now required"),t=new V),t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,de)),this}closestPointToPoint(e,t){void 0===t&&(console.warn("THREE.Ray: .closestPointToPoint() target is now required"),t=new V),t.subVectors(e,this.origin);const n=t.dot(this.direction);return n<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=de.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(de.copy(this.direction).multiplyScalar(t).add(this.origin),de.distanceToSquared(e))}distanceSqToSegment(e,t,n,i){he.copy(e).add(t).multiplyScalar(.5),fe.copy(t).sub(e).normalize(),ue.copy(this.origin).sub(he);const o=.5*e.distanceTo(t),r=-this.direction.dot(fe),a=ue.dot(this.direction),s=-ue.dot(fe),c=ue.lengthSq(),l=Math.abs(1-r*r);let d,h,f,u;if(l>0)if(d=r*s-a,h=r*a-s,u=o*l,d>=0)if(h>=-u)if(h<=u){const e=1/l;d*=e,h*=e,f=d*(d+r*h+2*a)+h*(r*d+h+2*s)+c}else h=o,d=Math.max(0,-(r*h+a)),f=-d*d+h*(h+2*s)+c;else h=-o,d=Math.max(0,-(r*h+a)),f=-d*d+h*(h+2*s)+c;else h<=-u?(d=Math.max(0,-(-r*o+a)),h=d>0?-o:Math.min(Math.max(-o,-s),o),f=-d*d+h*(h+2*s)+c):h<=u?(d=0,h=Math.min(Math.max(-o,-s),o),f=h*(h+2*s)+c):(d=Math.max(0,-(r*o+a)),h=d>0?o:Math.min(Math.max(-o,-s),o),f=-d*d+h*(h+2*s)+c);else h=r>0?-o:o,d=Math.max(0,-(r*h+a)),f=-d*d+h*(h+2*s)+c;return n&&n.copy(this.direction).multiplyScalar(d).add(this.origin),i&&i.copy(fe).multiplyScalar(h).add(he),f}intersectSphere(e,t){de.subVectors(e.center,this.origin);const n=de.dot(this.direction),i=de.dot(de)-n*n,o=e.radius*e.radius;if(i>o)return null;const r=Math.sqrt(o-i),a=n-r,s=n+r;return a<0&&s<0?null:a<0?this.at(s,t):this.at(a,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(0===t)return 0===e.distanceToPoint(this.origin)?0:null;const n=-(this.origin.dot(e.normal)+e.constant)/t;return n>=0?n:null}intersectPlane(e,t){const n=this.distanceToPlane(e);return null===n?null:this.at(n,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return 0===t||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let n,i,o,r,a,s;const c=1/this.direction.x,l=1/this.direction.y,d=1/this.direction.z,h=this.origin;return c>=0?(n=(e.min.x-h.x)*c,i=(e.max.x-h.x)*c):(n=(e.max.x-h.x)*c,i=(e.min.x-h.x)*c),l>=0?(o=(e.min.y-h.y)*l,r=(e.max.y-h.y)*l):(o=(e.max.y-h.y)*l,r=(e.min.y-h.y)*l),n>r||o>i?null:((o>n||n!=n)&&(n=o),(r<i||i!=i)&&(i=r),d>=0?(a=(e.min.z-h.z)*d,s=(e.max.z-h.z)*d):(a=(e.max.z-h.z)*d,s=(e.min.z-h.z)*d),n>s||a>i?null:((a>n||n!=n)&&(n=a),(s<i||i!=i)&&(i=s),i<0?null:this.at(n>=0?n:i,t)))}intersectsBox(e){return null!==this.intersectBox(e,de)}intersectTriangle(e,t,n,i,o){pe.subVectors(t,e),me.subVectors(n,e),ge.crossVectors(pe,me);let r,a=this.direction.dot(ge);if(a>0){if(i)return null;r=1}else{if(!(a<0))return null;r=-1,a=-a}ue.subVectors(this.origin,e);const s=r*this.direction.dot(me.crossVectors(ue,me));if(s<0)return null;const c=r*this.direction.dot(pe.cross(ue));if(c<0)return null;if(s+c>a)return null;const l=-r*ue.dot(ge);return l<0?null:this.at(l/a,o)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}}class Te{constructor(){Object.defineProperty(this,"isMatrix4",{value:!0}),this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,i,o,r,a,s,c,l,d,h,f,u,p,m){const g=this.elements;return g[0]=e,g[4]=t,g[8]=n,g[12]=i,g[1]=o,g[5]=r,g[9]=a,g[13]=s,g[2]=c,g[6]=l,g[10]=d,g[14]=h,g[3]=f,g[7]=u,g[11]=p,g[15]=m,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new Te).fromArray(this.elements)}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],this}copyPosition(e){const t=this.elements,n=e.elements;return t[12]=n[12],t[13]=n[13],t[14]=n[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,n){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(e,t,n){return this.set(e.x,t.x,n.x,0,e.y,t.y,n.y,0,e.z,t.z,n.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,n=e.elements,i=1/ve.setFromMatrixColumn(e,0).length(),o=1/ve.setFromMatrixColumn(e,1).length(),r=1/ve.setFromMatrixColumn(e,2).length();return t[0]=n[0]*i,t[1]=n[1]*i,t[2]=n[2]*i,t[3]=0,t[4]=n[4]*o,t[5]=n[5]*o,t[6]=n[6]*o,t[7]=0,t[8]=n[8]*r,t[9]=n[9]*r,t[10]=n[10]*r,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const t=this.elements,n=e.x,i=e.y,o=e.z,r=Math.cos(n),a=Math.sin(n),s=Math.cos(i),c=Math.sin(i),l=Math.cos(o),d=Math.sin(o);if("XYZ"===e.order){const e=r*l,n=r*d,i=a*l,o=a*d;t[0]=s*l,t[4]=-s*d,t[8]=c,t[1]=n+i*c,t[5]=e-o*c,t[9]=-a*s,t[2]=o-e*c,t[6]=i+n*c,t[10]=r*s}else if("YXZ"===e.order){const e=s*l,n=s*d,i=c*l,o=c*d;t[0]=e+o*a,t[4]=i*a-n,t[8]=r*c,t[1]=r*d,t[5]=r*l,t[9]=-a,t[2]=n*a-i,t[6]=o+e*a,t[10]=r*s}else if("ZXY"===e.order){const e=s*l,n=s*d,i=c*l,o=c*d;t[0]=e-o*a,t[4]=-r*d,t[8]=i+n*a,t[1]=n+i*a,t[5]=r*l,t[9]=o-e*a,t[2]=-r*c,t[6]=a,t[10]=r*s}else if("ZYX"===e.order){const e=r*l,n=r*d,i=a*l,o=a*d;t[0]=s*l,t[4]=i*c-n,t[8]=e*c+o,t[1]=s*d,t[5]=o*c+e,t[9]=n*c-i,t[2]=-c,t[6]=a*s,t[10]=r*s}else if("YZX"===e.order){const e=r*s,n=r*c,i=a*s,o=a*c;t[0]=s*l,t[4]=o-e*d,t[8]=i*d+n,t[1]=d,t[5]=r*l,t[9]=-a*l,t[2]=-c*l,t[6]=n*d+i,t[10]=e-o*d}else if("XZY"===e.order){const e=r*s,n=r*c,i=a*s,o=a*c;t[0]=s*l,t[4]=-d,t[8]=c*l,t[1]=e*d+o,t[5]=r*l,t[9]=n*d-i,t[2]=i*d-n,t[6]=a*l,t[10]=o*d+e}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(Re,e,Ie)}lookAt(e,t,n){const i=this.elements;return Ne.subVectors(e,t),0===Ne.lengthSq()&&(Ne.z=1),Ne.normalize(),Oe.crossVectors(n,Ne),0===Oe.lengthSq()&&(1===Math.abs(n.z)?Ne.x+=1e-4:Ne.z+=1e-4,Ne.normalize(),Oe.crossVectors(n,Ne)),Oe.normalize(),Se.crossVectors(Ne,Oe),i[0]=Oe.x,i[4]=Se.x,i[8]=Ne.x,i[1]=Oe.y,i[5]=Se.y,i[9]=Ne.y,i[2]=Oe.z,i[6]=Se.z,i[10]=Ne.z,this}multiply(e,t){return void 0!==t?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(e,t)):this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,i=t.elements,o=this.elements,r=n[0],a=n[4],s=n[8],c=n[12],l=n[1],d=n[5],h=n[9],f=n[13],u=n[2],p=n[6],m=n[10],g=n[14],E=n[3],T=n[7],v=n[11],A=n[15],R=i[0],I=i[4],O=i[8],S=i[12],N=i[1],b=i[5],y=i[9],x=i[13],L=i[2],_=i[6],w=i[10],C=i[14],M=i[3],D=i[7],P=i[11],F=i[15];return o[0]=r*R+a*N+s*L+c*M,o[4]=r*I+a*b+s*_+c*D,o[8]=r*O+a*y+s*w+c*P,o[12]=r*S+a*x+s*C+c*F,o[1]=l*R+d*N+h*L+f*M,o[5]=l*I+d*b+h*_+f*D,o[9]=l*O+d*y+h*w+f*P,o[13]=l*S+d*x+h*C+f*F,o[2]=u*R+p*N+m*L+g*M,o[6]=u*I+p*b+m*_+g*D,o[10]=u*O+p*y+m*w+g*P,o[14]=u*S+p*x+m*C+g*F,o[3]=E*R+T*N+v*L+A*M,o[7]=E*I+T*b+v*_+A*D,o[11]=E*O+T*y+v*w+A*P,o[15]=E*S+T*x+v*C+A*F,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[4],i=e[8],o=e[12],r=e[1],a=e[5],s=e[9],c=e[13],l=e[2],d=e[6],h=e[10],f=e[14];return e[3]*(+o*s*d-i*c*d-o*a*h+n*c*h+i*a*f-n*s*f)+e[7]*(+t*s*f-t*c*h+o*r*h-i*r*f+i*c*l-o*s*l)+e[11]*(+t*c*d-t*a*f-o*r*d+n*r*f+o*a*l-n*c*l)+e[15]*(-i*a*l-t*s*d+t*a*h+i*r*d-n*r*h+n*s*l)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,n){const i=this.elements;return e.isVector3?(i[12]=e.x,i[13]=e.y,i[14]=e.z):(i[12]=e,i[13]=t,i[14]=n),this}invert(){const e=this.elements,t=e[0],n=e[1],i=e[2],o=e[3],r=e[4],a=e[5],s=e[6],c=e[7],l=e[8],d=e[9],h=e[10],f=e[11],u=e[12],p=e[13],m=e[14],g=e[15],E=d*m*c-p*h*c+p*s*f-a*m*f-d*s*g+a*h*g,T=u*h*c-l*m*c-u*s*f+r*m*f+l*s*g-r*h*g,v=l*p*c-u*d*c+u*a*f-r*p*f-l*a*g+r*d*g,A=u*d*s-l*p*s-u*a*h+r*p*h+l*a*m-r*d*m,R=t*E+n*T+i*v+o*A;if(0===R)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const I=1/R;return e[0]=E*I,e[1]=(p*h*o-d*m*o-p*i*f+n*m*f+d*i*g-n*h*g)*I,e[2]=(a*m*o-p*s*o+p*i*c-n*m*c-a*i*g+n*s*g)*I,e[3]=(d*s*o-a*h*o-d*i*c+n*h*c+a*i*f-n*s*f)*I,e[4]=T*I,e[5]=(l*m*o-u*h*o+u*i*f-t*m*f-l*i*g+t*h*g)*I,e[6]=(u*s*o-r*m*o-u*i*c+t*m*c+r*i*g-t*s*g)*I,e[7]=(r*h*o-l*s*o+l*i*c-t*h*c-r*i*f+t*s*f)*I,e[8]=v*I,e[9]=(u*d*o-l*p*o-u*n*f+t*p*f+l*n*g-t*d*g)*I,e[10]=(r*p*o-u*a*o+u*n*c-t*p*c-r*n*g+t*a*g)*I,e[11]=(l*a*o-r*d*o-l*n*c+t*d*c+r*n*f-t*a*f)*I,e[12]=A*I,e[13]=(l*p*i-u*d*i+u*n*h-t*p*h-l*n*m+t*d*m)*I,e[14]=(u*a*i-r*p*i-u*n*s+t*p*s+r*n*m-t*a*m)*I,e[15]=(r*d*i-l*a*i+l*n*s-t*d*s-r*n*h+t*a*h)*I,this}scale(e){const t=this.elements,n=e.x,i=e.y,o=e.z;return t[0]*=n,t[4]*=i,t[8]*=o,t[1]*=n,t[5]*=i,t[9]*=o,t[2]*=n,t[6]*=i,t[10]*=o,t[3]*=n,t[7]*=i,t[11]*=o,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],n=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],i=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,n,i))}makeTranslation(e,t,n){return this.set(1,0,0,e,0,1,0,t,0,0,1,n,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),n=Math.sin(e);return this.set(1,0,0,0,0,t,-n,0,0,n,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,0,n,0,0,1,0,0,-n,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,0,n,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const n=Math.cos(t),i=Math.sin(t),o=1-n,r=e.x,a=e.y,s=e.z,c=o*r,l=o*a;return this.set(c*r+n,c*a-i*s,c*s+i*a,0,c*a+i*s,l*a+n,l*s-i*r,0,c*s-i*a,l*s+i*r,o*s*s+n,0,0,0,0,1),this}makeScale(e,t,n){return this.set(e,0,0,0,0,t,0,0,0,0,n,0,0,0,0,1),this}makeShear(e,t,n){return this.set(1,t,n,0,e,1,n,0,e,t,1,0,0,0,0,1),this}compose(e,t,n){const i=this.elements,o=t._x,r=t._y,a=t._z,s=t._w,c=o+o,l=r+r,d=a+a,h=o*c,f=o*l,u=o*d,p=r*l,m=r*d,g=a*d,E=s*c,T=s*l,v=s*d,A=n.x,R=n.y,I=n.z;return i[0]=(1-(p+g))*A,i[1]=(f+v)*A,i[2]=(u-T)*A,i[3]=0,i[4]=(f-v)*R,i[5]=(1-(h+g))*R,i[6]=(m+E)*R,i[7]=0,i[8]=(u+T)*I,i[9]=(m-E)*I,i[10]=(1-(h+p))*I,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this}decompose(e,t,n){const i=this.elements;let o=ve.set(i[0],i[1],i[2]).length();const r=ve.set(i[4],i[5],i[6]).length(),a=ve.set(i[8],i[9],i[10]).length();this.determinant()<0&&(o=-o),e.x=i[12],e.y=i[13],e.z=i[14],Ae.copy(this);const s=1/o,c=1/r,l=1/a;return Ae.elements[0]*=s,Ae.elements[1]*=s,Ae.elements[2]*=s,Ae.elements[4]*=c,Ae.elements[5]*=c,Ae.elements[6]*=c,Ae.elements[8]*=l,Ae.elements[9]*=l,Ae.elements[10]*=l,t.setFromRotationMatrix(Ae),n.x=o,n.y=r,n.z=a,this}makePerspective(e,t,n,i,o,r){void 0===r&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const a=this.elements,s=2*o/(t-e),c=2*o/(n-i),l=(t+e)/(t-e),d=(n+i)/(n-i),h=-(r+o)/(r-o),f=-2*r*o/(r-o);return a[0]=s,a[4]=0,a[8]=l,a[12]=0,a[1]=0,a[5]=c,a[9]=d,a[13]=0,a[2]=0,a[6]=0,a[10]=h,a[14]=f,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(e,t,n,i,o,r){const a=this.elements,s=1/(t-e),c=1/(n-i),l=1/(r-o),d=(t+e)*s,h=(n+i)*c,f=(r+o)*l;return a[0]=2*s,a[4]=0,a[8]=0,a[12]=-d,a[1]=0,a[5]=2*c,a[9]=0,a[13]=-h,a[2]=0,a[6]=0,a[10]=-2*l,a[14]=-f,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(e){const t=this.elements,n=e.elements;for(let e=0;e<16;e++)if(t[e]!==n[e])return!1;return!0}fromArray(e,t=0){for(let n=0;n<16;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e[t+9]=n[9],e[t+10]=n[10],e[t+11]=n[11],e[t+12]=n[12],e[t+13]=n[13],e[t+14]=n[14],e[t+15]=n[15],e}}const ve=new V,Ae=new Te,Re=new V(0,0,0),Ie=new V(1,1,1),Oe=new V,Se=new V,Ne=new V;class be{constructor(e=0,t=0,n=0,i=be.DefaultOrder){Object.defineProperty(this,"isEuler",{value:!0}),this._x=e,this._y=t,this._z=n,this._order=i}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,n,i){return this._x=e,this._y=t,this._z=n,this._order=i||this._order,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t,n){const i=M.clamp,o=e.elements,r=o[0],a=o[4],s=o[8],c=o[1],l=o[5],d=o[9],h=o[2],f=o[6],u=o[10];switch(t=t||this._order){case"XYZ":this._y=Math.asin(i(s,-1,1)),Math.abs(s)<.9999999?(this._x=Math.atan2(-d,u),this._z=Math.atan2(-a,r)):(this._x=Math.atan2(f,l),this._z=0);break;case"YXZ":this._x=Math.asin(-i(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(s,u),this._z=Math.atan2(c,l)):(this._y=Math.atan2(-h,r),this._z=0);break;case"ZXY":this._x=Math.asin(i(f,-1,1)),Math.abs(f)<.9999999?(this._y=Math.atan2(-h,u),this._z=Math.atan2(-a,l)):(this._y=0,this._z=Math.atan2(c,r));break;case"ZYX":this._y=Math.asin(-i(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(f,u),this._z=Math.atan2(c,r)):(this._x=0,this._z=Math.atan2(-a,l));break;case"YZX":this._z=Math.asin(i(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(-d,l),this._y=Math.atan2(-h,r)):(this._x=0,this._y=Math.atan2(s,u));break;case"XZY":this._z=Math.asin(-i(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(f,l),this._y=Math.atan2(s,r)):(this._x=Math.atan2(-d,u),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,!1!==n&&this._onChangeCallback(),this}setFromQuaternion(e,t,n){return ye.makeRotationFromQuaternion(e),this.setFromRotationMatrix(ye,t,n)}setFromVector3(e,t){return this.set(e.x,e.y,e.z,t||this._order)}reorder(e){return xe.setFromEuler(this),this.setFromQuaternion(xe,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],void 0!==e[3]&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}toVector3(e){return e?e.set(this._x,this._y,this._z):new V(this._x,this._y,this._z)}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}be.DefaultOrder="XYZ",be.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];const ye=new Te,xe=new Y;class Le{constructor(){this.mask=1}set(e){this.mask=1<<e|0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return 0!=(this.mask&e.mask)}}let _e=0;const we=new V,Ce=new Y,Me=new Te,De=new V,Pe=new V,Fe=new V,He=new Y,Ue=new V(1,0,0),Be=new V(0,1,0),ze=new V(0,0,1),Ge={type:"added"},We={type:"removed"};function Ye(){Object.defineProperty(this,"id",{value:_e++}),this.uuid=M.generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Ye.DefaultUp.clone();const e=new V,t=new be,n=new Y,i=new V(1,1,1);t._onChange((function(){n.setFromEuler(t,!1)})),n._onChange((function(){t.setFromQuaternion(n,void 0,!1)})),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new Te},normalMatrix:{value:new P}}),this.matrix=new Te,this.matrixWorld=new Te,this.matrixAutoUpdate=Ye.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new Le,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}Ye.DefaultUp=new V(0,1,0),Ye.DefaultMatrixAutoUpdate=!0,Ye.prototype=Object.assign(Object.create(_.prototype),{constructor:Ye,isObject3D:!0,onBeforeRender:function(){},onAfterRender:function(){},applyMatrix4:function(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)},applyQuaternion:function(e){return this.quaternion.premultiply(e),this},setRotationFromAxisAngle:function(e,t){this.quaternion.setFromAxisAngle(e,t)},setRotationFromEuler:function(e){this.quaternion.setFromEuler(e,!0)},setRotationFromMatrix:function(e){this.quaternion.setFromRotationMatrix(e)},setRotationFromQuaternion:function(e){this.quaternion.copy(e)},rotateOnAxis:function(e,t){return Ce.setFromAxisAngle(e,t),this.quaternion.multiply(Ce),this},rotateOnWorldAxis:function(e,t){return Ce.setFromAxisAngle(e,t),this.quaternion.premultiply(Ce),this},rotateX:function(e){return this.rotateOnAxis(Ue,e)},rotateY:function(e){return this.rotateOnAxis(Be,e)},rotateZ:function(e){return this.rotateOnAxis(ze,e)},translateOnAxis:function(e,t){return we.copy(e).applyQuaternion(this.quaternion),this.position.add(we.multiplyScalar(t)),this},translateX:function(e){return this.translateOnAxis(Ue,e)},translateY:function(e){return this.translateOnAxis(Be,e)},translateZ:function(e){return this.translateOnAxis(ze,e)},localToWorld:function(e){return e.applyMatrix4(this.matrixWorld)},worldToLocal:function(e){return e.applyMatrix4(Me.copy(this.matrixWorld).invert())},lookAt:function(e,t,n){e.isVector3?De.copy(e):De.set(e,t,n);const i=this.parent;this.updateWorldMatrix(!0,!1),Pe.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Me.lookAt(Pe,De,this.up):Me.lookAt(De,Pe,this.up),this.quaternion.setFromRotationMatrix(Me),i&&(Me.extractRotation(i.matrixWorld),Ce.setFromRotationMatrix(Me),this.quaternion.premultiply(Ce.invert()))},add:function(e){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(null!==e.parent&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(Ge)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)},remove:function(e){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.remove(arguments[e]);return this}const t=this.children.indexOf(e);return-1!==t&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(We)),this},clear:function(){for(let e=0;e<this.children.length;e++){const t=this.children[e];t.parent=null,t.dispatchEvent(We)}return this.children.length=0,this},attach:function(e){return this.updateWorldMatrix(!0,!1),Me.copy(this.matrixWorld).invert(),null!==e.parent&&(e.parent.updateWorldMatrix(!0,!1),Me.multiply(e.parent.matrixWorld)),e.applyMatrix4(Me),e.updateWorldMatrix(!1,!1),this.add(e),this},getObjectById:function(e){return this.getObjectByProperty("id",e)},getObjectByName:function(e){return this.getObjectByProperty("name",e)},getObjectByProperty:function(e,t){if(this[e]===t)return this;for(let n=0,i=this.children.length;n<i;n++){const i=this.children[n].getObjectByProperty(e,t);if(void 0!==i)return i}},getWorldPosition:function(e){return void 0===e&&(console.warn("THREE.Object3D: .getWorldPosition() target is now required"),e=new V),this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)},getWorldQuaternion:function(e){return void 0===e&&(console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),e=new Y),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Pe,e,Fe),e},getWorldScale:function(e){return void 0===e&&(console.warn("THREE.Object3D: .getWorldScale() target is now required"),e=new V),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Pe,He,e),e},getWorldDirection:function(e){void 0===e&&(console.warn("THREE.Object3D: .getWorldDirection() target is now required"),e=new V),this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()},raycast:function(){},traverse:function(e){e(this);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].traverse(e)},traverseVisible:function(e){if(!1===this.visible)return;e(this);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].traverseVisible(e)},traverseAncestors:function(e){const t=this.parent;null!==t&&(e(t),t.traverseAncestors(e))},updateMatrix:function(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].updateMatrixWorld(e)},updateWorldMatrix:function(e,t){const n=this.parent;if(!0===e&&null!==n&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===t){const e=this.children;for(let t=0,n=e.length;t<n;t++)e[t].updateWorldMatrix(!1,!0)}},toJSON:function(e){const t=void 0===e||"string"==typeof e,n={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const i={};function o(t,n){return void 0===t[n.uuid]&&(t[n.uuid]=n.toJSON(e)),n.uuid}if(i.uuid=this.uuid,i.type=this.type,""!==this.name&&(i.name=this.name),!0===this.castShadow&&(i.castShadow=!0),!0===this.receiveShadow&&(i.receiveShadow=!0),!1===this.visible&&(i.visible=!1),!1===this.frustumCulled&&(i.frustumCulled=!1),0!==this.renderOrder&&(i.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON()),this.isMesh||this.isLine||this.isPoints){i.geometry=o(e.geometries,this.geometry);const t=this.geometry.parameters;if(void 0!==t&&void 0!==t.shapes){const n=t.shapes;if(Array.isArray(n))for(let t=0,i=n.length;t<i;t++){const i=n[t];o(e.shapes,i)}else o(e.shapes,n)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(o(e.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const t=[];for(let n=0,i=this.material.length;n<i;n++)t.push(o(e.materials,this.material[n]));i.material=t}else i.material=o(e.materials,this.material);if(this.children.length>0){i.children=[];for(let t=0;t<this.children.length;t++)i.children.push(this.children[t].toJSON(e).object)}if(this.animations.length>0){i.animations=[];for(let t=0;t<this.animations.length;t++){const n=this.animations[t];i.animations.push(o(e.animations,n))}}if(t){const t=r(e.geometries),i=r(e.materials),o=r(e.textures),a=r(e.images),s=r(e.shapes),c=r(e.skeletons),l=r(e.animations);t.length>0&&(n.geometries=t),i.length>0&&(n.materials=i),o.length>0&&(n.textures=o),a.length>0&&(n.images=a),s.length>0&&(n.shapes=s),c.length>0&&(n.skeletons=c),l.length>0&&(n.animations=l)}return n.object=i,n;function r(e){const t=[];for(const n in e){const i=e[n];delete i.metadata,t.push(i)}return t}},clone:function(e){return(new this.constructor).copy(this,e)},copy:function(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),!0===t)for(let t=0;t<e.children.length;t++){const n=e.children[t];this.add(n.clone())}return this}});const Ve=new V,ke=new V,je=new P;class Xe{constructor(e,t){Object.defineProperty(this,"isPlane",{value:!0}),this.normal=void 0!==e?e:new V(1,0,0),this.constant=void 0!==t?t:0}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,n,i){return this.normal.set(e,t,n),this.constant=i,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,n){const i=Ve.subVectors(n,t).cross(ke.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(i,e),this}clone(){return(new this.constructor).copy(this)}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return void 0===t&&(console.warn("THREE.Plane: .projectPoint() target is now required"),t=new V),t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){void 0===t&&(console.warn("THREE.Plane: .intersectLine() target is now required"),t=new V);const n=e.delta(Ve),i=this.normal.dot(n);if(0===i)return 0===this.distanceToPoint(e.start)?t.copy(e.start):void 0;const o=-(e.start.dot(this.normal)+this.constant)/i;return o<0||o>1?void 0:t.copy(n).multiplyScalar(o).add(e.start)}intersectsLine(e){const t=this.distanceToPoint(e.start),n=this.distanceToPoint(e.end);return t<0&&n>0||n<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return void 0===e&&(console.warn("THREE.Plane: .coplanarPoint() target is now required"),e=new V),e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const n=t||je.getNormalMatrix(e),i=this.coplanarPoint(Ve).applyMatrix4(e),o=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(o),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}}const qe=new V,Ke=new V,Ze=new V,Je=new V,Qe=new V,$e=new V,et=new V,tt=new V,nt=new V,it=new V;class ot{constructor(e,t,n){this.a=void 0!==e?e:new V,this.b=void 0!==t?t:new V,this.c=void 0!==n?n:new V}static getNormal(e,t,n,i){void 0===i&&(console.warn("THREE.Triangle: .getNormal() target is now required"),i=new V),i.subVectors(n,t),qe.subVectors(e,t),i.cross(qe);const o=i.lengthSq();return o>0?i.multiplyScalar(1/Math.sqrt(o)):i.set(0,0,0)}static getBarycoord(e,t,n,i,o){qe.subVectors(i,t),Ke.subVectors(n,t),Ze.subVectors(e,t);const r=qe.dot(qe),a=qe.dot(Ke),s=qe.dot(Ze),c=Ke.dot(Ke),l=Ke.dot(Ze),d=r*c-a*a;if(void 0===o&&(console.warn("THREE.Triangle: .getBarycoord() target is now required"),o=new V),0===d)return o.set(-2,-1,-1);const h=1/d,f=(c*s-a*l)*h,u=(r*l-a*s)*h;return o.set(1-f-u,u,f)}static containsPoint(e,t,n,i){return this.getBarycoord(e,t,n,i,Je),Je.x>=0&&Je.y>=0&&Je.x+Je.y<=1}static getUV(e,t,n,i,o,r,a,s){return this.getBarycoord(e,t,n,i,Je),s.set(0,0),s.addScaledVector(o,Je.x),s.addScaledVector(r,Je.y),s.addScaledVector(a,Je.z),s}static isFrontFacing(e,t,n,i){return qe.subVectors(n,t),Ke.subVectors(e,t),qe.cross(Ke).dot(i)<0}set(e,t,n){return this.a.copy(e),this.b.copy(t),this.c.copy(n),this}setFromPointsAndIndices(e,t,n,i){return this.a.copy(e[t]),this.b.copy(e[n]),this.c.copy(e[i]),this}clone(){return(new this.constructor).copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return qe.subVectors(this.c,this.b),Ke.subVectors(this.a,this.b),.5*qe.cross(Ke).length()}getMidpoint(e){return void 0===e&&(console.warn("THREE.Triangle: .getMidpoint() target is now required"),e=new V),e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return ot.getNormal(this.a,this.b,this.c,e)}getPlane(e){return void 0===e&&(console.warn("THREE.Triangle: .getPlane() target is now required"),e=new Xe),e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return ot.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,n,i,o){return ot.getUV(e,this.a,this.b,this.c,t,n,i,o)}containsPoint(e){return ot.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return ot.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){void 0===t&&(console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),t=new V);const n=this.a,i=this.b,o=this.c;let r,a;Qe.subVectors(i,n),$e.subVectors(o,n),tt.subVectors(e,n);const s=Qe.dot(tt),c=$e.dot(tt);if(s<=0&&c<=0)return t.copy(n);nt.subVectors(e,i);const l=Qe.dot(nt),d=$e.dot(nt);if(l>=0&&d<=l)return t.copy(i);const h=s*d-l*c;if(h<=0&&s>=0&&l<=0)return r=s/(s-l),t.copy(n).addScaledVector(Qe,r);it.subVectors(e,o);const f=Qe.dot(it),u=$e.dot(it);if(u>=0&&f<=u)return t.copy(o);const p=f*c-s*u;if(p<=0&&c>=0&&u<=0)return a=c/(c-u),t.copy(n).addScaledVector($e,a);const m=l*u-f*d;if(m<=0&&d-l>=0&&f-u>=0)return et.subVectors(o,i),a=(d-l)/(d-l+(f-u)),t.copy(i).addScaledVector(et,a);const g=1/(m+p+h);return r=p*g,a=h*g,t.copy(n).addScaledVector(Qe,r).addScaledVector($e,a)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}const rt={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},at={h:0,s:0,l:0},st={h:0,s:0,l:0};function ct(e,t,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?e+6*(t-e)*n:n<.5?t:n<2/3?e+6*(t-e)*(2/3-n):e}function lt(e){return e<.04045?.0773993808*e:Math.pow(.9478672986*e+.0521327014,2.4)}function dt(e){return e<.0031308?12.92*e:1.055*Math.pow(e,.41666)-.055}class ht{constructor(e,t,n){return Object.defineProperty(this,"isColor",{value:!0}),void 0===t&&void 0===n?this.set(e):this.setRGB(e,t,n)}set(e){return e&&e.isColor?this.copy(e):"number"==typeof e?this.setHex(e):"string"==typeof e&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(255&e)/255,this}setRGB(e,t,n){return this.r=e,this.g=t,this.b=n,this}setHSL(e,t,n){if(e=M.euclideanModulo(e,1),t=M.clamp(t,0,1),n=M.clamp(n,0,1),0===t)this.r=this.g=this.b=n;else{const i=n<=.5?n*(1+t):n+t-n*t,o=2*n-i;this.r=ct(o,i,e+1/3),this.g=ct(o,i,e),this.b=ct(o,i,e-1/3)}return this}setStyle(e){function t(t){void 0!==t&&parseFloat(t)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let n;if(n=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)){let e;const i=n[1],o=n[2];switch(i){case"rgb":case"rgba":if(e=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(255,parseInt(e[1],10))/255,this.g=Math.min(255,parseInt(e[2],10))/255,this.b=Math.min(255,parseInt(e[3],10))/255,t(e[4]),this;if(e=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(100,parseInt(e[1],10))/100,this.g=Math.min(100,parseInt(e[2],10))/100,this.b=Math.min(100,parseInt(e[3],10))/100,t(e[4]),this;break;case"hsl":case"hsla":if(e=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)){const n=parseFloat(e[1])/360,i=parseInt(e[2],10)/100,o=parseInt(e[3],10)/100;return t(e[4]),this.setHSL(n,i,o)}}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(e)){const e=n[1],t=e.length;if(3===t)return this.r=parseInt(e.charAt(0)+e.charAt(0),16)/255,this.g=parseInt(e.charAt(1)+e.charAt(1),16)/255,this.b=parseInt(e.charAt(2)+e.charAt(2),16)/255,this;if(6===t)return this.r=parseInt(e.charAt(0)+e.charAt(1),16)/255,this.g=parseInt(e.charAt(2)+e.charAt(3),16)/255,this.b=parseInt(e.charAt(4)+e.charAt(5),16)/255,this}return e&&e.length>0?this.setColorName(e):this}setColorName(e){const t=rt[e];return void 0!==t?this.setHex(t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copyGammaToLinear(e,t=2){return this.r=Math.pow(e.r,t),this.g=Math.pow(e.g,t),this.b=Math.pow(e.b,t),this}copyLinearToGamma(e,t=2){const n=t>0?1/t:1;return this.r=Math.pow(e.r,n),this.g=Math.pow(e.g,n),this.b=Math.pow(e.b,n),this}convertGammaToLinear(e){return this.copyGammaToLinear(this,e),this}convertLinearToGamma(e){return this.copyLinearToGamma(this,e),this}copySRGBToLinear(e){return this.r=lt(e.r),this.g=lt(e.g),this.b=lt(e.b),this}copyLinearToSRGB(e){return this.r=dt(e.r),this.g=dt(e.g),this.b=dt(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(e){void 0===e&&(console.warn("THREE.Color: .getHSL() target is now required"),e={h:0,s:0,l:0});const t=this.r,n=this.g,i=this.b,o=Math.max(t,n,i),r=Math.min(t,n,i);let a,s;const c=(r+o)/2;if(r===o)a=0,s=0;else{const e=o-r;switch(s=c<=.5?e/(o+r):e/(2-o-r),o){case t:a=(n-i)/e+(n<i?6:0);break;case n:a=(i-t)/e+2;break;case i:a=(t-n)/e+4}a/=6}return e.h=a,e.s=s,e.l=c,e}getStyle(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"}offsetHSL(e,t,n){return this.getHSL(at),at.h+=e,at.s+=t,at.l+=n,this.setHSL(at.h,at.s,at.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,n){return this.r=e.r+(t.r-e.r)*n,this.g=e.g+(t.g-e.g)*n,this.b=e.b+(t.b-e.b)*n,this}lerpHSL(e,t){this.getHSL(at),e.getHSL(st);const n=M.lerp(at.h,st.h,t),i=M.lerp(at.s,st.s,t),o=M.lerp(at.l,st.l,t);return this.setHSL(n,i,o),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),!0===e.normalized&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}ht.NAMES=rt,ht.prototype.r=1,ht.prototype.g=1,ht.prototype.b=1;class ft{constructor(e,t,n,i,o,r=0){this.a=e,this.b=t,this.c=n,this.normal=i&&i.isVector3?i:new V,this.vertexNormals=Array.isArray(i)?i:[],this.color=o&&o.isColor?o:new ht,this.vertexColors=Array.isArray(o)?o:[],this.materialIndex=r}clone(){return(new this.constructor).copy(this)}copy(e){this.a=e.a,this.b=e.b,this.c=e.c,this.normal.copy(e.normal),this.color.copy(e.color),this.materialIndex=e.materialIndex;for(let t=0,n=e.vertexNormals.length;t<n;t++)this.vertexNormals[t]=e.vertexNormals[t].clone();for(let t=0,n=e.vertexColors.length;t<n;t++)this.vertexColors[t]=e.vertexColors[t].clone();return this}}let ut=0;function pt(){Object.defineProperty(this,"id",{value:ut++}),this.uuid=M.generateUUID(),this.name="",this.type="Material",this.fog=!0,this.blending=1,this.side=0,this.flatShading=!1,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=204,this.blendDst=205,this.blendEquation=n,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=b,this.stencilZFail=b,this.stencilZPass=b,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaTest=0,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0}function mt(e){pt.call(this),this.type="MeshBasicMaterial",this.color=new ht(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.setValues(e)}pt.prototype=Object.assign(Object.create(_.prototype),{constructor:pt,isMaterial:!0,onBeforeCompile:function(){},customProgramCacheKey:function(){return this.onBeforeCompile.toString()},setValues:function(e){if(void 0!==e)for(const t in e){const n=e[t];if(void 0===n){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}if("shading"===t){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===n;continue}const i=this[t];void 0!==i?i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[t]=n:console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.")}},toJSON:function(e){const t=void 0===e||"string"==typeof e;t&&(e={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function i(e){const t=[];for(const n in e){const i=e[n];delete i.metadata,t.push(i)}return t}if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),void 0!==this.roughness&&(n.roughness=this.roughness),void 0!==this.metalness&&(n.metalness=this.metalness),this.sheen&&this.sheen.isColor&&(n.sheen=this.sheen.getHex()),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),void 0!==this.shininess&&(n.shininess=this.shininess),void 0!==this.clearcoat&&(n.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(e).uuid),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(e).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(e).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(e).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(e).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(e).uuid,n.reflectivity=this.reflectivity,n.refractionRatio=this.refractionRatio,void 0!==this.combine&&(n.combine=this.combine),void 0!==this.envMapIntensity&&(n.envMapIntensity=this.envMapIntensity)),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(e).uuid),void 0!==this.size&&(n.size=this.size),void 0!==this.sizeAttenuation&&(n.sizeAttenuation=this.sizeAttenuation),1!==this.blending&&(n.blending=this.blending),!0===this.flatShading&&(n.flatShading=this.flatShading),0!==this.side&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),!0===this.transparent&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation&&0!==this.rotation&&(n.rotation=this.rotation),!0===this.polygonOffset&&(n.polygonOffset=!0),0!==this.polygonOffsetFactor&&(n.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&1!==this.linewidth&&(n.linewidth=this.linewidth),void 0!==this.dashSize&&(n.dashSize=this.dashSize),void 0!==this.gapSize&&(n.gapSize=this.gapSize),void 0!==this.scale&&(n.scale=this.scale),!0===this.dithering&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),!0===this.premultipliedAlpha&&(n.premultipliedAlpha=this.premultipliedAlpha),!0===this.wireframe&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(n.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(n.wireframeLinejoin=this.wireframeLinejoin),!0===this.morphTargets&&(n.morphTargets=!0),!0===this.morphNormals&&(n.morphNormals=!0),!0===this.skinning&&(n.skinning=!0),!1===this.visible&&(n.visible=!1),!1===this.toneMapped&&(n.toneMapped=!1),"{}"!==JSON.stringify(this.userData)&&(n.userData=this.userData),t){const t=i(e.textures),o=i(e.images);t.length>0&&(n.textures=t),o.length>0&&(n.images=o)}return n},clone:function(){return(new this.constructor).copy(this)},copy:function(e){this.name=e.name,this.fog=e.fog,this.blending=e.blending,this.side=e.side,this.flatShading=e.flatShading,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let n=null;if(null!==t){const e=t.length;n=new Array(e);for(let i=0;i!==e;++i)n[i]=t[i].clone()}return this.clippingPlanes=n,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.premultipliedAlpha=e.premultipliedAlpha,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this},dispose:function(){this.dispatchEvent({type:"dispose"})}}),Object.defineProperty(pt.prototype,"needsUpdate",{set:function(e){!0===e&&this.version++}}),mt.prototype=Object.create(pt.prototype),mt.prototype.constructor=mt,mt.prototype.isMeshBasicMaterial=!0,mt.prototype.copy=function(e){return pt.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this};const gt=new V,Et=new D;function Tt(e,t,n){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=e,this.itemSize=t,this.count=void 0!==e?e.length/t:0,this.normalized=!0===n,this.usage=y,this.updateRange={offset:0,count:-1},this.version=0}function vt(e,t,n){Tt.call(this,new Int8Array(e),t,n)}function At(e,t,n){Tt.call(this,new Uint8Array(e),t,n)}function Rt(e,t,n){Tt.call(this,new Uint8ClampedArray(e),t,n)}function It(e,t,n){Tt.call(this,new Int16Array(e),t,n)}function Ot(e,t,n){Tt.call(this,new Uint16Array(e),t,n)}function St(e,t,n){Tt.call(this,new Int32Array(e),t,n)}function Nt(e,t,n){Tt.call(this,new Uint32Array(e),t,n)}function bt(e,t,n){Tt.call(this,new Uint16Array(e),t,n)}function yt(e,t,n){Tt.call(this,new Float32Array(e),t,n)}function xt(e,t,n){Tt.call(this,new Float64Array(e),t,n)}function Lt(e){if(0===e.length)return-1/0;let t=e[0];for(let n=1,i=e.length;n<i;++n)e[n]>t&&(t=e[n]);return t}Object.defineProperty(Tt.prototype,"needsUpdate",{set:function(e){!0===e&&this.version++}}),Object.assign(Tt.prototype,{isBufferAttribute:!0,onUploadCallback:function(){},setUsage:function(e){return this.usage=e,this},copy:function(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this},copyAt:function(e,t,n){e*=this.itemSize,n*=t.itemSize;for(let i=0,o=this.itemSize;i<o;i++)this.array[e+i]=t.array[n+i];return this},copyArray:function(e){return this.array.set(e),this},copyColorsArray:function(e){const t=this.array;let n=0;for(let i=0,o=e.length;i<o;i++){let o=e[i];void 0===o&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",i),o=new ht),t[n++]=o.r,t[n++]=o.g,t[n++]=o.b}return this},copyVector2sArray:function(e){const t=this.array;let n=0;for(let i=0,o=e.length;i<o;i++){let o=e[i];void 0===o&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",i),o=new D),t[n++]=o.x,t[n++]=o.y}return this},copyVector3sArray:function(e){const t=this.array;let n=0;for(let i=0,o=e.length;i<o;i++){let o=e[i];void 0===o&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",i),o=new V),t[n++]=o.x,t[n++]=o.y,t[n++]=o.z}return this},copyVector4sArray:function(e){const t=this.array;let n=0;for(let i=0,o=e.length;i<o;i++){let o=e[i];void 0===o&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",i),o=new G),t[n++]=o.x,t[n++]=o.y,t[n++]=o.z,t[n++]=o.w}return this},applyMatrix3:function(e){if(2===this.itemSize)for(let t=0,n=this.count;t<n;t++)Et.fromBufferAttribute(this,t),Et.applyMatrix3(e),this.setXY(t,Et.x,Et.y);else if(3===this.itemSize)for(let t=0,n=this.count;t<n;t++)gt.fromBufferAttribute(this,t),gt.applyMatrix3(e),this.setXYZ(t,gt.x,gt.y,gt.z);return this},applyMatrix4:function(e){for(let t=0,n=this.count;t<n;t++)gt.x=this.getX(t),gt.y=this.getY(t),gt.z=this.getZ(t),gt.applyMatrix4(e),this.setXYZ(t,gt.x,gt.y,gt.z);return this},applyNormalMatrix:function(e){for(let t=0,n=this.count;t<n;t++)gt.x=this.getX(t),gt.y=this.getY(t),gt.z=this.getZ(t),gt.applyNormalMatrix(e),this.setXYZ(t,gt.x,gt.y,gt.z);return this},transformDirection:function(e){for(let t=0,n=this.count;t<n;t++)gt.x=this.getX(t),gt.y=this.getY(t),gt.z=this.getZ(t),gt.transformDirection(e),this.setXYZ(t,gt.x,gt.y,gt.z);return this},set:function(e,t=0){return this.array.set(e,t),this},getX:function(e){return this.array[e*this.itemSize]},setX:function(e,t){return this.array[e*this.itemSize]=t,this},getY:function(e){return this.array[e*this.itemSize+1]},setY:function(e,t){return this.array[e*this.itemSize+1]=t,this},getZ:function(e){return this.array[e*this.itemSize+2]},setZ:function(e,t){return this.array[e*this.itemSize+2]=t,this},getW:function(e){return this.array[e*this.itemSize+3]},setW:function(e,t){return this.array[e*this.itemSize+3]=t,this},setXY:function(e,t,n){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this},setXYZ:function(e,t,n,i){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=i,this},setXYZW:function(e,t,n,i,o){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=i,this.array[e+3]=o,this},onUpload:function(e){return this.onUploadCallback=e,this},clone:function(){return new this.constructor(this.array,this.itemSize).copy(this)},toJSON:function(){return{itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized}}}),vt.prototype=Object.create(Tt.prototype),vt.prototype.constructor=vt,At.prototype=Object.create(Tt.prototype),At.prototype.constructor=At,Rt.prototype=Object.create(Tt.prototype),Rt.prototype.constructor=Rt,It.prototype=Object.create(Tt.prototype),It.prototype.constructor=It,Ot.prototype=Object.create(Tt.prototype),Ot.prototype.constructor=Ot,St.prototype=Object.create(Tt.prototype),St.prototype.constructor=St,Nt.prototype=Object.create(Tt.prototype),Nt.prototype.constructor=Nt,bt.prototype=Object.create(Tt.prototype),bt.prototype.constructor=bt,bt.prototype.isFloat16BufferAttribute=!0,yt.prototype=Object.create(Tt.prototype),yt.prototype.constructor=yt,xt.prototype=Object.create(Tt.prototype),xt.prototype.constructor=xt;const _t={Int8Array,Uint8Array,Uint8ClampedArray:"undefined"!=typeof Uint8ClampedArray?Uint8ClampedArray:Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function wt(e,t){return new _t[e](t)}let Ct=0;const Mt=new Te,Dt=new Ye,Pt=new V,Ft=new X,Ht=new X,Ut=new V;function Bt(){Object.defineProperty(this,"id",{value:Ct++}),this.uuid=M.generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}Bt.prototype=Object.assign(Object.create(_.prototype),{constructor:Bt,isBufferGeometry:!0,getIndex:function(){return this.index},setIndex:function(e){return Array.isArray(e)?this.index=new(Lt(e)>65535?Nt:Ot)(e,1):this.index=e,this},getAttribute:function(e){return this.attributes[e]},setAttribute:function(e,t){return this.attributes[e]=t,this},deleteAttribute:function(e){return delete this.attributes[e],this},hasAttribute:function(e){return void 0!==this.attributes[e]},addGroup:function(e,t,n=0){this.groups.push({start:e,count:t,materialIndex:n})},clearGroups:function(){this.groups=[]},setDrawRange:function(e,t){this.drawRange.start=e,this.drawRange.count=t},applyMatrix4:function(e){const t=this.attributes.position;void 0!==t&&(t.applyMatrix4(e),t.needsUpdate=!0);const n=this.attributes.normal;if(void 0!==n){const t=(new P).getNormalMatrix(e);n.applyNormalMatrix(t),n.needsUpdate=!0}const i=this.attributes.tangent;return void 0!==i&&(i.transformDirection(e),i.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this},rotateX:function(e){return Mt.makeRotationX(e),this.applyMatrix4(Mt),this},rotateY:function(e){return Mt.makeRotationY(e),this.applyMatrix4(Mt),this},rotateZ:function(e){return Mt.makeRotationZ(e),this.applyMatrix4(Mt),this},translate:function(e,t,n){return Mt.makeTranslation(e,t,n),this.applyMatrix4(Mt),this},scale:function(e,t,n){return Mt.makeScale(e,t,n),this.applyMatrix4(Mt),this},lookAt:function(e){return Dt.lookAt(e),Dt.updateMatrix(),this.applyMatrix4(Dt.matrix),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(Pt).negate(),this.translate(Pt.x,Pt.y,Pt.z),this},setFromPoints:function(e){const t=[];for(let n=0,i=e.length;n<i;n++){const i=e[n];t.push(i.x,i.y,i.z||0)}return this.setAttribute("position",new yt(t,3)),this},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new X);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new V(-1/0,-1/0,-1/0),new V(1/0,1/0,1/0));if(void 0!==e){if(this.boundingBox.setFromBufferAttribute(e),t)for(let e=0,n=t.length;e<n;e++){const n=t[e];Ft.setFromBufferAttribute(n),this.morphTargetsRelative?(Ut.addVectors(this.boundingBox.min,Ft.min),this.boundingBox.expandByPoint(Ut),Ut.addVectors(this.boundingBox.max,Ft.max),this.boundingBox.expandByPoint(Ut)):(this.boundingBox.expandByPoint(Ft.min),this.boundingBox.expandByPoint(Ft.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new le);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new V,1/0);if(e){const n=this.boundingSphere.center;if(Ft.setFromBufferAttribute(e),t)for(let e=0,n=t.length;e<n;e++){const n=t[e];Ht.setFromBufferAttribute(n),this.morphTargetsRelative?(Ut.addVectors(Ft.min,Ht.min),Ft.expandByPoint(Ut),Ut.addVectors(Ft.max,Ht.max),Ft.expandByPoint(Ut)):(Ft.expandByPoint(Ht.min),Ft.expandByPoint(Ht.max))}Ft.getCenter(n);let i=0;for(let t=0,o=e.count;t<o;t++)Ut.fromBufferAttribute(e,t),i=Math.max(i,n.distanceToSquared(Ut));if(t)for(let o=0,r=t.length;o<r;o++){const r=t[o],a=this.morphTargetsRelative;for(let t=0,o=r.count;t<o;t++)Ut.fromBufferAttribute(r,t),a&&(Pt.fromBufferAttribute(e,t),Ut.add(Pt)),i=Math.max(i,n.distanceToSquared(Ut))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}},computeFaceNormals:function(){},computeTangents:function(){const e=this.index,t=this.attributes;if(null===e||void 0===t.position||void 0===t.normal||void 0===t.uv)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const n=e.array,i=t.position.array,o=t.normal.array,r=t.uv.array,a=i.length/3;void 0===t.tangent&&this.setAttribute("tangent",new Tt(new Float32Array(4*a),4));const s=t.tangent.array,c=[],l=[];for(let e=0;e<a;e++)c[e]=new V,l[e]=new V;const d=new V,h=new V,f=new V,u=new D,p=new D,m=new D,g=new V,E=new V;function T(e,t,n){d.fromArray(i,3*e),h.fromArray(i,3*t),f.fromArray(i,3*n),u.fromArray(r,2*e),p.fromArray(r,2*t),m.fromArray(r,2*n),h.sub(d),f.sub(d),p.sub(u),m.sub(u);const o=1/(p.x*m.y-m.x*p.y);isFinite(o)&&(g.copy(h).multiplyScalar(m.y).addScaledVector(f,-p.y).multiplyScalar(o),E.copy(f).multiplyScalar(p.x).addScaledVector(h,-m.x).multiplyScalar(o),c[e].add(g),c[t].add(g),c[n].add(g),l[e].add(E),l[t].add(E),l[n].add(E))}let v=this.groups;0===v.length&&(v=[{start:0,count:n.length}]);for(let e=0,t=v.length;e<t;++e){const t=v[e],i=t.start;for(let e=i,o=i+t.count;e<o;e+=3)T(n[e+0],n[e+1],n[e+2])}const A=new V,R=new V,I=new V,O=new V;function S(e){I.fromArray(o,3*e),O.copy(I);const t=c[e];A.copy(t),A.sub(I.multiplyScalar(I.dot(t))).normalize(),R.crossVectors(O,t);const n=R.dot(l[e])<0?-1:1;s[4*e]=A.x,s[4*e+1]=A.y,s[4*e+2]=A.z,s[4*e+3]=n}for(let e=0,t=v.length;e<t;++e){const t=v[e],i=t.start;for(let e=i,o=i+t.count;e<o;e+=3)S(n[e+0]),S(n[e+1]),S(n[e+2])}},computeVertexNormals:function(){const e=this.index,t=this.getAttribute("position");if(void 0!==t){let n=this.getAttribute("normal");if(void 0===n)n=new Tt(new Float32Array(3*t.count),3),this.setAttribute("normal",n);else for(let e=0,t=n.count;e<t;e++)n.setXYZ(e,0,0,0);const i=new V,o=new V,r=new V,a=new V,s=new V,c=new V,l=new V,d=new V;if(e)for(let h=0,f=e.count;h<f;h+=3){const f=e.getX(h+0),u=e.getX(h+1),p=e.getX(h+2);i.fromBufferAttribute(t,f),o.fromBufferAttribute(t,u),r.fromBufferAttribute(t,p),l.subVectors(r,o),d.subVectors(i,o),l.cross(d),a.fromBufferAttribute(n,f),s.fromBufferAttribute(n,u),c.fromBufferAttribute(n,p),a.add(l),s.add(l),c.add(l),n.setXYZ(f,a.x,a.y,a.z),n.setXYZ(u,s.x,s.y,s.z),n.setXYZ(p,c.x,c.y,c.z)}else for(let e=0,a=t.count;e<a;e+=3)i.fromBufferAttribute(t,e+0),o.fromBufferAttribute(t,e+1),r.fromBufferAttribute(t,e+2),l.subVectors(r,o),d.subVectors(i,o),l.cross(d),n.setXYZ(e+0,l.x,l.y,l.z),n.setXYZ(e+1,l.x,l.y,l.z),n.setXYZ(e+2,l.x,l.y,l.z);this.normalizeNormals(),n.needsUpdate=!0}},merge:function(e,t){if(!e||!e.isBufferGeometry)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",e);void 0===t&&(t=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const i in n){if(void 0===e.attributes[i])continue;const o=n[i].array,r=e.attributes[i],a=r.array,s=r.itemSize*t,c=Math.min(a.length,o.length-s);for(let e=0,t=s;e<c;e++,t++)o[t]=a[e]}return this},normalizeNormals:function(){const e=this.attributes.normal;for(let t=0,n=e.count;t<n;t++)Ut.fromBufferAttribute(e,t),Ut.normalize(),e.setXYZ(t,Ut.x,Ut.y,Ut.z)},toNonIndexed:function(){function e(e,t){const n=e.array,i=e.itemSize,o=e.normalized,r=new n.constructor(t.length*i);let a=0,s=0;for(let e=0,o=t.length;e<o;e++){a=t[e]*i;for(let e=0;e<i;e++)r[s++]=n[a++]}return new Tt(r,i,o)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new Bt,n=this.index.array,i=this.attributes;for(const o in i){const r=e(i[o],n);t.setAttribute(o,r)}const o=this.morphAttributes;for(const i in o){const r=[],a=o[i];for(let t=0,i=a.length;t<i;t++){const i=e(a[t],n);r.push(i)}t.morphAttributes[i]=r}t.morphTargetsRelative=this.morphTargetsRelative;const r=this.groups;for(let e=0,n=r.length;e<n;e++){const n=r[e];t.addGroup(n.start,n.count,n.materialIndex)}return t},toJSON:function(){const e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,""!==this.name&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),void 0!==this.parameters){const t=this.parameters;for(const n in t)void 0!==t[n]&&(e[n]=t[n]);return e}e.data={attributes:{}};const t=this.index;null!==t&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const n=this.attributes;for(const t in n){const i=n[t],o=i.toJSON(e.data);""!==i.name&&(o.name=i.name),e.data.attributes[t]=o}const i={};let o=!1;for(const t in this.morphAttributes){const n=this.morphAttributes[t],r=[];for(let t=0,i=n.length;t<i;t++){const i=n[t],o=i.toJSON(e.data);""!==i.name&&(o.name=i.name),r.push(o)}r.length>0&&(i[t]=r,o=!0)}o&&(e.data.morphAttributes=i,e.data.morphTargetsRelative=this.morphTargetsRelative);const r=this.groups;r.length>0&&(e.data.groups=JSON.parse(JSON.stringify(r)));const a=this.boundingSphere;return null!==a&&(e.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),e},clone:function(){return(new Bt).copy(this)},copy:function(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const n=e.index;null!==n&&this.setIndex(n.clone(t));const i=e.attributes;for(const e in i){const n=i[e];this.setAttribute(e,n.clone(t))}const o=e.morphAttributes;for(const e in o){const n=[],i=o[e];for(let e=0,o=i.length;e<o;e++)n.push(i[e].clone(t));this.morphAttributes[e]=n}this.morphTargetsRelative=e.morphTargetsRelative;const r=e.groups;for(let e=0,t=r.length;e<t;e++){const t=r[e];this.addGroup(t.start,t.count,t.materialIndex)}const a=e.boundingBox;null!==a&&(this.boundingBox=a.clone());const s=e.boundingSphere;return null!==s&&(this.boundingSphere=s.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this},dispose:function(){this.dispatchEvent({type:"dispose"})}});const zt=new Te,Gt=new Ee,Wt=new le,Yt=new V,Vt=new V,kt=new V,jt=new V,Xt=new V,qt=new V,Kt=new V,Zt=new V,Jt=new V,Qt=new D,$t=new D,en=new D,tn=new V,nn=new V;function on(e=new Bt,t=new mt){Ye.call(this),this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}function rn(e,t,n,i,o,r,a,s,c,l,d,h){Yt.fromBufferAttribute(o,l),Vt.fromBufferAttribute(o,d),kt.fromBufferAttribute(o,h);const f=e.morphTargetInfluences;if(t.morphTargets&&r&&f){Kt.set(0,0,0),Zt.set(0,0,0),Jt.set(0,0,0);for(let e=0,t=r.length;e<t;e++){const t=f[e],n=r[e];0!==t&&(jt.fromBufferAttribute(n,l),Xt.fromBufferAttribute(n,d),qt.fromBufferAttribute(n,h),a?(Kt.addScaledVector(jt,t),Zt.addScaledVector(Xt,t),Jt.addScaledVector(qt,t)):(Kt.addScaledVector(jt.sub(Yt),t),Zt.addScaledVector(Xt.sub(Vt),t),Jt.addScaledVector(qt.sub(kt),t)))}Yt.add(Kt),Vt.add(Zt),kt.add(Jt)}e.isSkinnedMesh&&(e.boneTransform(l,Yt),e.boneTransform(d,Vt),e.boneTransform(h,kt));const u=function(e,t,n,i,o,r,a,s){let c;if(c=1===t.side?i.intersectTriangle(a,r,o,!0,s):i.intersectTriangle(o,r,a,2!==t.side,s),null===c)return null;nn.copy(s),nn.applyMatrix4(e.matrixWorld);const l=n.ray.origin.distanceTo(nn);return l<n.near||l>n.far?null:{distance:l,point:nn.clone(),object:e}}(e,t,n,i,Yt,Vt,kt,tn);if(u){s&&(Qt.fromBufferAttribute(s,l),$t.fromBufferAttribute(s,d),en.fromBufferAttribute(s,h),u.uv=ot.getUV(tn,Yt,Vt,kt,Qt,$t,en,new D)),c&&(Qt.fromBufferAttribute(c,l),$t.fromBufferAttribute(c,d),en.fromBufferAttribute(c,h),u.uv2=ot.getUV(tn,Yt,Vt,kt,Qt,$t,en,new D));const e=new ft(l,d,h);ot.getNormal(Yt,Vt,kt,e.normal),u.face=e}return u}on.prototype=Object.assign(Object.create(Ye.prototype),{constructor:on,isMesh:!0,copy:function(e){return Ye.prototype.copy.call(this,e),void 0!==e.morphTargetInfluences&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),void 0!==e.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this},updateMorphTargets:function(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const e=t[n[0]];if(void 0!==e){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,n=e.length;t<n;t++){const n=e[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=t}}}}else{const t=e.morphTargets;void 0!==t&&t.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}},raycast:function(e,t){const n=this.geometry,i=this.material,o=this.matrixWorld;if(void 0===i)return;if(null===n.boundingSphere&&n.computeBoundingSphere(),Wt.copy(n.boundingSphere),Wt.applyMatrix4(o),!1===e.ray.intersectsSphere(Wt))return;if(zt.copy(o).invert(),Gt.copy(e.ray).applyMatrix4(zt),null!==n.boundingBox&&!1===Gt.intersectsBox(n.boundingBox))return;let r;if(n.isBufferGeometry){const o=n.index,a=n.attributes.position,s=n.morphAttributes.position,c=n.morphTargetsRelative,l=n.attributes.uv,d=n.attributes.uv2,h=n.groups,f=n.drawRange;if(null!==o)if(Array.isArray(i))for(let n=0,u=h.length;n<u;n++){const u=h[n],p=i[u.materialIndex];for(let n=Math.max(u.start,f.start),i=Math.min(u.start+u.count,f.start+f.count);n<i;n+=3){const i=o.getX(n),h=o.getX(n+1),f=o.getX(n+2);r=rn(this,p,e,Gt,a,s,c,l,d,i,h,f),r&&(r.faceIndex=Math.floor(n/3),r.face.materialIndex=u.materialIndex,t.push(r))}}else for(let n=Math.max(0,f.start),h=Math.min(o.count,f.start+f.count);n<h;n+=3){const h=o.getX(n),f=o.getX(n+1),u=o.getX(n+2);r=rn(this,i,e,Gt,a,s,c,l,d,h,f,u),r&&(r.faceIndex=Math.floor(n/3),t.push(r))}else if(void 0!==a)if(Array.isArray(i))for(let n=0,o=h.length;n<o;n++){const o=h[n],u=i[o.materialIndex];for(let n=Math.max(o.start,f.start),i=Math.min(o.start+o.count,f.start+f.count);n<i;n+=3)r=rn(this,u,e,Gt,a,s,c,l,d,n,n+1,n+2),r&&(r.faceIndex=Math.floor(n/3),r.face.materialIndex=o.materialIndex,t.push(r))}else for(let n=Math.max(0,f.start),o=Math.min(a.count,f.start+f.count);n<o;n+=3)r=rn(this,i,e,Gt,a,s,c,l,d,n,n+1,n+2),r&&(r.faceIndex=Math.floor(n/3),t.push(r))}else n.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}});class an extends Bt{constructor(e=1,t=1,n=1,i=1,o=1,r=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:n,widthSegments:i,heightSegments:o,depthSegments:r};const a=this;i=Math.floor(i),o=Math.floor(o),r=Math.floor(r);const s=[],c=[],l=[],d=[];let h=0,f=0;function u(e,t,n,i,o,r,u,p,m,g,E){const T=r/m,v=u/g,A=r/2,R=u/2,I=p/2,O=m+1,S=g+1;let N=0,b=0;const y=new V;for(let r=0;r<S;r++){const a=r*v-R;for(let s=0;s<O;s++){const h=s*T-A;y[e]=h*i,y[t]=a*o,y[n]=I,c.push(y.x,y.y,y.z),y[e]=0,y[t]=0,y[n]=p>0?1:-1,l.push(y.x,y.y,y.z),d.push(s/m),d.push(1-r/g),N+=1}}for(let e=0;e<g;e++)for(let t=0;t<m;t++){const n=h+t+O*e,i=h+t+O*(e+1),o=h+(t+1)+O*(e+1),r=h+(t+1)+O*e;s.push(n,i,r),s.push(i,o,r),b+=6}a.addGroup(f,b,E),f+=b,h+=N}u("z","y","x",-1,-1,n,t,e,r,o,0),u("z","y","x",1,-1,n,t,-e,r,o,1),u("x","z","y",1,1,e,n,t,i,r,2),u("x","z","y",1,-1,e,n,-t,i,r,3),u("x","y","z",1,-1,e,t,n,i,o,4),u("x","y","z",-1,-1,e,t,-n,i,o,5),this.setIndex(s),this.setAttribute("position",new yt(c,3)),this.setAttribute("normal",new yt(l,3)),this.setAttribute("uv",new yt(d,2))}}function sn(e){const t={};for(const n in e){t[n]={};for(const i in e[n]){const o=e[n][i];o&&(o.isColor||o.isMatrix3||o.isMatrix4||o.isVector2||o.isVector3||o.isVector4||o.isTexture)?t[n][i]=o.clone():Array.isArray(o)?t[n][i]=o.slice():t[n][i]=o}}return t}function cn(e){const t={};for(let n=0;n<e.length;n++){const i=sn(e[n]);for(const e in i)t[e]=i[e]}return t}const ln={clone:sn,merge:cn};function dn(e){pt.call(this),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==e&&(void 0!==e.attributes&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(e))}function hn(){Ye.call(this),this.type="Camera",this.matrixWorldInverse=new Te,this.projectionMatrix=new Te,this.projectionMatrixInverse=new Te}function fn(e=50,t=1,n=.1,i=2e3){hn.call(this),this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}dn.prototype=Object.create(pt.prototype),dn.prototype.constructor=dn,dn.prototype.isShaderMaterial=!0,dn.prototype.copy=function(e){return pt.prototype.copy.call(this,e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=sn(e.uniforms),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.lights=e.lights,this.clipping=e.clipping,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this},dn.prototype.toJSON=function(e){const t=pt.prototype.toJSON.call(this,e);t.glslVersion=this.glslVersion,t.uniforms={};for(const n in this.uniforms){const i=this.uniforms[n].value;i&&i.isTexture?t.uniforms[n]={type:"t",value:i.toJSON(e).uuid}:i&&i.isColor?t.uniforms[n]={type:"c",value:i.getHex()}:i&&i.isVector2?t.uniforms[n]={type:"v2",value:i.toArray()}:i&&i.isVector3?t.uniforms[n]={type:"v3",value:i.toArray()}:i&&i.isVector4?t.uniforms[n]={type:"v4",value:i.toArray()}:i&&i.isMatrix3?t.uniforms[n]={type:"m3",value:i.toArray()}:i&&i.isMatrix4?t.uniforms[n]={type:"m4",value:i.toArray()}:t.uniforms[n]={value:i}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const n={};for(const e in this.extensions)!0===this.extensions[e]&&(n[e]=!0);return Object.keys(n).length>0&&(t.extensions=n),t},hn.prototype=Object.assign(Object.create(Ye.prototype),{constructor:hn,isCamera:!0,copy:function(e,t){return Ye.prototype.copy.call(this,e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this},getWorldDirection:function(e){void 0===e&&(console.warn("THREE.Camera: .getWorldDirection() target is now required"),e=new V),this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()},updateMatrixWorld:function(e){Ye.prototype.updateMatrixWorld.call(this,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()},updateWorldMatrix:function(e,t){Ye.prototype.updateWorldMatrix.call(this,e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()},clone:function(){return(new this.constructor).copy(this)}}),fn.prototype=Object.assign(Object.create(hn.prototype),{constructor:fn,isPerspectiveCamera:!0,copy:function(e,t){return hn.prototype.copy.call(this,e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=null===e.view?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this},setFocalLength:function(e){const t=.5*this.getFilmHeight()/e;this.fov=2*M.RAD2DEG*Math.atan(t),this.updateProjectionMatrix()},getFocalLength:function(){const e=Math.tan(.5*M.DEG2RAD*this.fov);return.5*this.getFilmHeight()/e},getEffectiveFOV:function(){return 2*M.RAD2DEG*Math.atan(Math.tan(.5*M.DEG2RAD*this.fov)/this.zoom)},getFilmWidth:function(){return this.filmGauge*Math.min(this.aspect,1)},getFilmHeight:function(){return this.filmGauge/Math.max(this.aspect,1)},setViewOffset:function(e,t,n,i,o,r){this.aspect=e/t,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=i,this.view.width=o,this.view.height=r,this.updateProjectionMatrix()},clearViewOffset:function(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){const e=this.near;let t=e*Math.tan(.5*M.DEG2RAD*this.fov)/this.zoom,n=2*t,i=this.aspect*n,o=-.5*i;const r=this.view;if(null!==this.view&&this.view.enabled){const e=r.fullWidth,a=r.fullHeight;o+=r.offsetX*i/e,t-=r.offsetY*n/a,i*=r.width/e,n*=r.height/a}const a=this.filmOffset;0!==a&&(o+=e*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(o,o+i,t,t-n,e,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()},toJSON:function(e){const t=Ye.prototype.toJSON.call(this,e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,null!==this.view&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}});const un=90;function pn(e,t,n){if(Ye.call(this),this.type="CubeCamera",!0!==n.isWebGLCubeRenderTarget)return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");this.renderTarget=n;const i=new fn(un,1,e,t);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new V(1,0,0)),this.add(i);const o=new fn(un,1,e,t);o.layers=this.layers,o.up.set(0,-1,0),o.lookAt(new V(-1,0,0)),this.add(o);const r=new fn(un,1,e,t);r.layers=this.layers,r.up.set(0,0,1),r.lookAt(new V(0,1,0)),this.add(r);const a=new fn(un,1,e,t);a.layers=this.layers,a.up.set(0,0,-1),a.lookAt(new V(0,-1,0)),this.add(a);const s=new fn(un,1,e,t);s.layers=this.layers,s.up.set(0,-1,0),s.lookAt(new V(0,0,1)),this.add(s);const c=new fn(un,1,e,t);c.layers=this.layers,c.up.set(0,-1,0),c.lookAt(new V(0,0,-1)),this.add(c),this.update=function(e,t){null===this.parent&&this.updateMatrixWorld();const l=e.xr.enabled,d=e.getRenderTarget();e.xr.enabled=!1;const h=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,e.setRenderTarget(n,0),e.render(t,i),e.setRenderTarget(n,1),e.render(t,o),e.setRenderTarget(n,2),e.render(t,r),e.setRenderTarget(n,3),e.render(t,a),e.setRenderTarget(n,4),e.render(t,s),n.texture.generateMipmaps=h,e.setRenderTarget(n,5),e.render(t,c),e.setRenderTarget(d),e.xr.enabled=l}}function mn(e,t,n,i,o,r,a,s,c,l){e=void 0!==e?e:[],t=void 0!==t?t:301,a=void 0!==a?a:p,B.call(this,e,t,n,i,o,r,a,s,c,l),this.flipY=!1,this._needsFlipEnvMap=!0}pn.prototype=Object.create(Ye.prototype),pn.prototype.constructor=pn,mn.prototype=Object.create(B.prototype),mn.prototype.constructor=mn,mn.prototype.isCubeTexture=!0,Object.defineProperty(mn.prototype,"images",{get:function(){return this.image},set:function(e){this.image=e}});class gn extends W{constructor(e,t,n){Number.isInteger(t)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),t=n),super(e,e,t),Object.defineProperty(this,"isWebGLCubeRenderTarget",{value:!0}),t=t||{},this.texture=new mn(void 0,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.format=m,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const n={tEquirect:{value:null}},i="\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",o="\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",r=new an(5,5,5),a=new dn({name:"CubemapFromEquirect",uniforms:sn(n),vertexShader:i,fragmentShader:o,side:1,blending:0});a.uniforms.tEquirect.value=t;const l=new on(r,a),d=t.minFilter;return t.minFilter===c&&(t.minFilter=s),new pn(1,10,this).update(e,l),t.minFilter=d,l.geometry.dispose(),l.material.dispose(),this}clear(e,t,n,i){const o=e.getRenderTarget();for(let o=0;o<6;o++)e.setRenderTarget(this,o),e.clear(t,n,i);e.setRenderTarget(o)}}function En(e,t,n,i,o,r,s,c,l,d,h,f){B.call(this,null,r,s,c,l,d,i,o,h,f),this.image={data:e||null,width:t||1,height:n||1},this.magFilter=void 0!==l?l:a,this.minFilter=void 0!==d?d:a,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}En.prototype=Object.create(B.prototype),En.prototype.constructor=En,En.prototype.isDataTexture=!0;const Tn=new le,vn=new V;class An{constructor(e,t,n,i,o,r){this.planes=[void 0!==e?e:new Xe,void 0!==t?t:new Xe,void 0!==n?n:new Xe,void 0!==i?i:new Xe,void 0!==o?o:new Xe,void 0!==r?r:new Xe]}set(e,t,n,i,o,r){const a=this.planes;return a[0].copy(e),a[1].copy(t),a[2].copy(n),a[3].copy(i),a[4].copy(o),a[5].copy(r),this}clone(){return(new this.constructor).copy(this)}copy(e){const t=this.planes;for(let n=0;n<6;n++)t[n].copy(e.planes[n]);return this}setFromProjectionMatrix(e){const t=this.planes,n=e.elements,i=n[0],o=n[1],r=n[2],a=n[3],s=n[4],c=n[5],l=n[6],d=n[7],h=n[8],f=n[9],u=n[10],p=n[11],m=n[12],g=n[13],E=n[14],T=n[15];return t[0].setComponents(a-i,d-s,p-h,T-m).normalize(),t[1].setComponents(a+i,d+s,p+h,T+m).normalize(),t[2].setComponents(a+o,d+c,p+f,T+g).normalize(),t[3].setComponents(a-o,d-c,p-f,T-g).normalize(),t[4].setComponents(a-r,d-l,p-u,T-E).normalize(),t[5].setComponents(a+r,d+l,p+u,T+E).normalize(),this}intersectsObject(e){const t=e.geometry;return null===t.boundingSphere&&t.computeBoundingSphere(),Tn.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(Tn)}intersectsSprite(e){return Tn.center.set(0,0,0),Tn.radius=.7071067811865476,Tn.applyMatrix4(e.matrixWorld),this.intersectsSphere(Tn)}intersectsSphere(e){const t=this.planes,n=e.center,i=-e.radius;for(let e=0;e<6;e++)if(t[e].distanceToPoint(n)<i)return!1;return!0}intersectsBox(e){const t=this.planes;for(let n=0;n<6;n++){const i=t[n];if(vn.x=i.normal.x>0?e.max.x:e.min.x,vn.y=i.normal.y>0?e.max.y:e.min.y,vn.z=i.normal.z>0?e.max.z:e.min.z,i.distanceToPoint(vn)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let n=0;n<6;n++)if(t[n].distanceToPoint(e)<0)return!1;return!0}}function Rn(){let e=null,t=!1,n=null,i=null;function o(t,r){n(t,r),i=e.requestAnimationFrame(o)}return{start:function(){!0!==t&&null!==n&&(i=e.requestAnimationFrame(o),t=!0)},stop:function(){e.cancelAnimationFrame(i),t=!1},setAnimationLoop:function(e){n=e},setContext:function(t){e=t}}}function In(e,t){const n=t.isWebGL2,i=new WeakMap;return{get:function(e){return e.isInterleavedBufferAttribute&&(e=e.data),i.get(e)},remove:function(t){t.isInterleavedBufferAttribute&&(t=t.data);const n=i.get(t);n&&(e.deleteBuffer(n.buffer),i.delete(t))},update:function(t,o){if(t.isGLBufferAttribute){const e=i.get(t);return void((!e||e.version<t.version)&&i.set(t,{buffer:t.buffer,type:t.type,bytesPerElement:t.elementSize,version:t.version}))}t.isInterleavedBufferAttribute&&(t=t.data);const r=i.get(t);void 0===r?i.set(t,function(t,i){const o=t.array,r=t.usage,a=e.createBuffer();e.bindBuffer(i,a),e.bufferData(i,o,r),t.onUploadCallback();let s=5126;return o instanceof Float32Array?s=5126:o instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):o instanceof Uint16Array?t.isFloat16BufferAttribute?n?s=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):s=5123:o instanceof Int16Array?s=5122:o instanceof Uint32Array?s=5125:o instanceof Int32Array?s=5124:o instanceof Int8Array?s=5120:o instanceof Uint8Array&&(s=5121),{buffer:a,type:s,bytesPerElement:o.BYTES_PER_ELEMENT,version:t.version}}(t,o)):r.version<t.version&&(function(t,i,o){const r=i.array,a=i.updateRange;e.bindBuffer(o,t),-1===a.count?e.bufferSubData(o,0,r):(n?e.bufferSubData(o,a.offset*r.BYTES_PER_ELEMENT,r,a.offset,a.count):e.bufferSubData(o,a.offset*r.BYTES_PER_ELEMENT,r.subarray(a.offset,a.offset+a.count)),a.count=-1)}(r.buffer,t,o),r.version=t.version)}}}class On extends Bt{constructor(e=1,t=1,n=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:n,heightSegments:i};const o=e/2,r=t/2,a=Math.floor(n),s=Math.floor(i),c=a+1,l=s+1,d=e/a,h=t/s,f=[],u=[],p=[],m=[];for(let e=0;e<l;e++){const t=e*h-r;for(let n=0;n<c;n++){const i=n*d-o;u.push(i,-t,0),p.push(0,0,1),m.push(n/a),m.push(1-e/s)}}for(let e=0;e<s;e++)for(let t=0;t<a;t++){const n=t+c*e,i=t+c*(e+1),o=t+1+c*(e+1),r=t+1+c*e;f.push(n,i,r),f.push(i,o,r)}this.setIndex(f),this.setAttribute("position",new yt(u,3)),this.setAttribute("normal",new yt(p,3)),this.setAttribute("uv",new yt(m,2))}}const Sn={alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:"\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",lightmap_fragment:"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_vertex:"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",normal_fragment_begin:"#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",normal_fragment_maps:"#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmissionmap_fragment:"#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",transmissionmap_pars_fragment:"#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",uv_pars_fragment:"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",uv_pars_vertex:"#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",uv_vertex:"#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",cube_frag:"#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",normal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",normal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",shadow_vert:"#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"},Nn={common:{diffuse:{value:new ht(15658734)},opacity:{value:1},map:{value:null},uvTransform:{value:new P},uv2Transform:{value:new P},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new D(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new ht(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new ht(15658734)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},uvTransform:{value:new P}},sprite:{diffuse:{value:new ht(15658734)},opacity:{value:1},center:{value:new D(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new P}}},bn={basic:{uniforms:cn([Nn.common,Nn.specularmap,Nn.envmap,Nn.aomap,Nn.lightmap,Nn.fog]),vertexShader:Sn.meshbasic_vert,fragmentShader:Sn.meshbasic_frag},lambert:{uniforms:cn([Nn.common,Nn.specularmap,Nn.envmap,Nn.aomap,Nn.lightmap,Nn.emissivemap,Nn.fog,Nn.lights,{emissive:{value:new ht(0)}}]),vertexShader:Sn.meshlambert_vert,fragmentShader:Sn.meshlambert_frag},phong:{uniforms:cn([Nn.common,Nn.specularmap,Nn.envmap,Nn.aomap,Nn.lightmap,Nn.emissivemap,Nn.bumpmap,Nn.normalmap,Nn.displacementmap,Nn.fog,Nn.lights,{emissive:{value:new ht(0)},specular:{value:new ht(1118481)},shininess:{value:30}}]),vertexShader:Sn.meshphong_vert,fragmentShader:Sn.meshphong_frag},standard:{uniforms:cn([Nn.common,Nn.envmap,Nn.aomap,Nn.lightmap,Nn.emissivemap,Nn.bumpmap,Nn.normalmap,Nn.displacementmap,Nn.roughnessmap,Nn.metalnessmap,Nn.fog,Nn.lights,{emissive:{value:new ht(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Sn.meshphysical_vert,fragmentShader:Sn.meshphysical_frag},toon:{uniforms:cn([Nn.common,Nn.aomap,Nn.lightmap,Nn.emissivemap,Nn.bumpmap,Nn.normalmap,Nn.displacementmap,Nn.gradientmap,Nn.fog,Nn.lights,{emissive:{value:new ht(0)}}]),vertexShader:Sn.meshtoon_vert,fragmentShader:Sn.meshtoon_frag},matcap:{uniforms:cn([Nn.common,Nn.bumpmap,Nn.normalmap,Nn.displacementmap,Nn.fog,{matcap:{value:null}}]),vertexShader:Sn.meshmatcap_vert,fragmentShader:Sn.meshmatcap_frag},points:{uniforms:cn([Nn.points,Nn.fog]),vertexShader:Sn.points_vert,fragmentShader:Sn.points_frag},dashed:{uniforms:cn([Nn.common,Nn.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Sn.linedashed_vert,fragmentShader:Sn.linedashed_frag},depth:{uniforms:cn([Nn.common,Nn.displacementmap]),vertexShader:Sn.depth_vert,fragmentShader:Sn.depth_frag},normal:{uniforms:cn([Nn.common,Nn.bumpmap,Nn.normalmap,Nn.displacementmap,{opacity:{value:1}}]),vertexShader:Sn.normal_vert,fragmentShader:Sn.normal_frag},sprite:{uniforms:cn([Nn.sprite,Nn.fog]),vertexShader:Sn.sprite_vert,fragmentShader:Sn.sprite_frag},background:{uniforms:{uvTransform:{value:new P},t2D:{value:null}},vertexShader:Sn.background_vert,fragmentShader:Sn.background_frag},cube:{uniforms:cn([Nn.envmap,{opacity:{value:1}}]),vertexShader:Sn.cube_vert,fragmentShader:Sn.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Sn.equirect_vert,fragmentShader:Sn.equirect_frag},distanceRGBA:{uniforms:cn([Nn.common,Nn.displacementmap,{referencePosition:{value:new V},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Sn.distanceRGBA_vert,fragmentShader:Sn.distanceRGBA_frag},shadow:{uniforms:cn([Nn.lights,Nn.fog,{color:{value:new ht(0)},opacity:{value:1}}]),vertexShader:Sn.shadow_vert,fragmentShader:Sn.shadow_frag}};function yn(e,t,n,i,o){const r=new ht(0);let a,s,c=0,l=null,d=0,h=null;function f(e,t){n.buffers.color.setClear(e.r,e.g,e.b,t,o)}return{getClearColor:function(){return r},setClearColor:function(e,t=1){r.set(e),c=t,f(r,c)},getClearAlpha:function(){return c},setClearAlpha:function(e){c=e,f(r,c)},render:function(n,o,u,p){let m=!0===o.isScene?o.background:null;m&&m.isTexture&&(m=t.get(m));const g=e.xr,E=g.getSession&&g.getSession();E&&"additive"===E.environmentBlendMode&&(m=null),null===m?f(r,c):m&&m.isColor&&(f(m,1),p=!0),(e.autoClear||p)&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),m&&(m.isCubeTexture||m.isWebGLCubeRenderTarget||306===m.mapping)?(void 0===s&&(s=new on(new an(1,1,1),new dn({name:"BackgroundCubeMaterial",uniforms:sn(bn.cube.uniforms),vertexShader:bn.cube.vertexShader,fragmentShader:bn.cube.fragmentShader,side:1,depthTest:!1,depthWrite:!1,fog:!1})),s.geometry.deleteAttribute("normal"),s.geometry.deleteAttribute("uv"),s.onBeforeRender=function(e,t,n){this.matrixWorld.copyPosition(n.matrixWorld)},Object.defineProperty(s.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(s)),m.isWebGLCubeRenderTarget&&(m=m.texture),s.material.uniforms.envMap.value=m,s.material.uniforms.flipEnvMap.value=m.isCubeTexture&&m._needsFlipEnvMap?-1:1,l===m&&d===m.version&&h===e.toneMapping||(s.material.needsUpdate=!0,l=m,d=m.version,h=e.toneMapping),n.unshift(s,s.geometry,s.material,0,0,null)):m&&m.isTexture&&(void 0===a&&(a=new on(new On(2,2),new dn({name:"BackgroundMaterial",uniforms:sn(bn.background.uniforms),vertexShader:bn.background.vertexShader,fragmentShader:bn.background.fragmentShader,side:0,depthTest:!1,depthWrite:!1,fog:!1})),a.geometry.deleteAttribute("normal"),Object.defineProperty(a.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(a)),a.material.uniforms.t2D.value=m,!0===m.matrixAutoUpdate&&m.updateMatrix(),a.material.uniforms.uvTransform.value.copy(m.matrix),l===m&&d===m.version&&h===e.toneMapping||(a.material.needsUpdate=!0,l=m,d=m.version,h=e.toneMapping),n.unshift(a,a.geometry,a.material,0,0,null))}}}function xn(e,t,n,i){const o=e.getParameter(34921),r=i.isWebGL2?null:t.get("OES_vertex_array_object"),a=i.isWebGL2||null!==r,s={},c=f(null);let l=c;function d(t){return i.isWebGL2?e.bindVertexArray(t):r.bindVertexArrayOES(t)}function h(t){return i.isWebGL2?e.deleteVertexArray(t):r.deleteVertexArrayOES(t)}function f(e){const t=[],n=[],i=[];for(let e=0;e<o;e++)t[e]=0,n[e]=0,i[e]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:t,enabledAttributes:n,attributeDivisors:i,object:e,attributes:{},index:null}}function u(){const e=l.newAttributes;for(let t=0,n=e.length;t<n;t++)e[t]=0}function p(e){m(e,0)}function m(n,o){const r=l.newAttributes,a=l.enabledAttributes,s=l.attributeDivisors;r[n]=1,0===a[n]&&(e.enableVertexAttribArray(n),a[n]=1),s[n]!==o&&((i.isWebGL2?e:t.get("ANGLE_instanced_arrays"))[i.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](n,o),s[n]=o)}function g(){const t=l.newAttributes,n=l.enabledAttributes;for(let i=0,o=n.length;i<o;i++)n[i]!==t[i]&&(e.disableVertexAttribArray(i),n[i]=0)}function E(t,n,o,r,a,s){!0!==i.isWebGL2||5124!==o&&5125!==o?e.vertexAttribPointer(t,n,o,r,a,s):e.vertexAttribIPointer(t,n,o,a,s)}function T(){v(),l!==c&&(l=c,d(l.object))}function v(){c.geometry=null,c.program=null,c.wireframe=!1}return{setup:function(o,c,h,T,v){let A=!1;if(a){const t=function(t,n,o){const a=!0===o.wireframe;let c=s[t.id];void 0===c&&(c={},s[t.id]=c);let l=c[n.id];void 0===l&&(l={},c[n.id]=l);let d=l[a];return void 0===d&&(d=f(i.isWebGL2?e.createVertexArray():r.createVertexArrayOES()),l[a]=d),d}(T,h,c);l!==t&&(l=t,d(l.object)),A=function(e,t){const n=l.attributes,i=e.attributes;let o=0;for(const e in i){const t=n[e],r=i[e];if(void 0===t)return!0;if(t.attribute!==r)return!0;if(t.data!==r.data)return!0;o++}return l.attributesNum!==o||l.index!==t}(T,v),A&&function(e,t){const n={},i=e.attributes;let o=0;for(const e in i){const t=i[e],r={};r.attribute=t,t.data&&(r.data=t.data),n[e]=r,o++}l.attributes=n,l.attributesNum=o,l.index=t}(T,v)}else{const e=!0===c.wireframe;l.geometry===T.id&&l.program===h.id&&l.wireframe===e||(l.geometry=T.id,l.program=h.id,l.wireframe=e,A=!0)}!0===o.isInstancedMesh&&(A=!0),null!==v&&n.update(v,34963),A&&(function(o,r,a,s){if(!1===i.isWebGL2&&(o.isInstancedMesh||s.isInstancedBufferGeometry)&&null===t.get("ANGLE_instanced_arrays"))return;u();const c=s.attributes,l=a.getAttributes(),d=r.defaultAttributeValues;for(const t in l){const i=l[t];if(i>=0){const r=c[t];if(void 0!==r){const t=r.normalized,o=r.itemSize,a=n.get(r);if(void 0===a)continue;const c=a.buffer,l=a.type,d=a.bytesPerElement;if(r.isInterleavedBufferAttribute){const n=r.data,a=n.stride,h=r.offset;n&&n.isInstancedInterleavedBuffer?(m(i,n.meshPerAttribute),void 0===s._maxInstanceCount&&(s._maxInstanceCount=n.meshPerAttribute*n.count)):p(i),e.bindBuffer(34962,c),E(i,o,l,t,a*d,h*d)}else r.isInstancedBufferAttribute?(m(i,r.meshPerAttribute),void 0===s._maxInstanceCount&&(s._maxInstanceCount=r.meshPerAttribute*r.count)):p(i),e.bindBuffer(34962,c),E(i,o,l,t,0,0)}else if("instanceMatrix"===t){const t=n.get(o.instanceMatrix);if(void 0===t)continue;const r=t.buffer,a=t.type;m(i+0,1),m(i+1,1),m(i+2,1),m(i+3,1),e.bindBuffer(34962,r),e.vertexAttribPointer(i+0,4,a,!1,64,0),e.vertexAttribPointer(i+1,4,a,!1,64,16),e.vertexAttribPointer(i+2,4,a,!1,64,32),e.vertexAttribPointer(i+3,4,a,!1,64,48)}else if("instanceColor"===t){const t=n.get(o.instanceColor);if(void 0===t)continue;const r=t.buffer,a=t.type;m(i,1),e.bindBuffer(34962,r),e.vertexAttribPointer(i,3,a,!1,12,0)}else if(void 0!==d){const n=d[t];if(void 0!==n)switch(n.length){case 2:e.vertexAttrib2fv(i,n);break;case 3:e.vertexAttrib3fv(i,n);break;case 4:e.vertexAttrib4fv(i,n);break;default:e.vertexAttrib1fv(i,n)}}}}g()}(o,c,h,T),null!==v&&e.bindBuffer(34963,n.get(v).buffer))},reset:T,resetDefaultState:v,dispose:function(){T();for(const e in s){const t=s[e];for(const e in t){const n=t[e];for(const e in n)h(n[e].object),delete n[e];delete t[e]}delete s[e]}},releaseStatesOfGeometry:function(e){if(void 0===s[e.id])return;const t=s[e.id];for(const e in t){const n=t[e];for(const e in n)h(n[e].object),delete n[e];delete t[e]}delete s[e.id]},releaseStatesOfProgram:function(e){for(const t in s){const n=s[t];if(void 0===n[e.id])continue;const i=n[e.id];for(const e in i)h(i[e].object),delete i[e];delete n[e.id]}},initAttributes:u,enableAttribute:p,disableUnusedAttributes:g}}function Ln(e,t,n,i){const o=i.isWebGL2;let r;this.setMode=function(e){r=e},this.render=function(t,i){e.drawArrays(r,t,i),n.update(i,r,1)},this.renderInstances=function(i,a,s){if(0===s)return;let c,l;if(o)c=e,l="drawArraysInstanced";else if(c=t.get("ANGLE_instanced_arrays"),l="drawArraysInstancedANGLE",null===c)return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");c[l](r,i,a,s),n.update(a,r,s)}}function _n(e,t,n){let i;function o(t){if("highp"===t){if(e.getShaderPrecisionFormat(35633,36338).precision>0&&e.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";t="mediump"}return"mediump"===t&&e.getShaderPrecisionFormat(35633,36337).precision>0&&e.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const r="undefined"!=typeof WebGL2RenderingContext&&e instanceof WebGL2RenderingContext||"undefined"!=typeof WebGL2ComputeRenderingContext&&e instanceof WebGL2ComputeRenderingContext;let a=void 0!==n.precision?n.precision:"highp";const s=o(a);s!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",s,"instead."),a=s);const c=!0===n.logarithmicDepthBuffer,l=e.getParameter(34930),d=e.getParameter(35660),h=e.getParameter(3379),f=e.getParameter(34076),u=e.getParameter(34921),p=e.getParameter(36347),m=e.getParameter(36348),g=e.getParameter(36349),E=d>0,T=r||!!t.get("OES_texture_float");return{isWebGL2:r,getMaxAnisotropy:function(){if(void 0!==i)return i;const n=t.get("EXT_texture_filter_anisotropic");return i=null!==n?e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT):0,i},getMaxPrecision:o,precision:a,logarithmicDepthBuffer:c,maxTextures:l,maxVertexTextures:d,maxTextureSize:h,maxCubemapSize:f,maxAttributes:u,maxVertexUniforms:p,maxVaryings:m,maxFragmentUniforms:g,vertexTextures:E,floatFragmentTextures:T,floatVertexTextures:E&&T,maxSamples:r?e.getParameter(36183):0}}function wn(e){const t=this;let n=null,i=0,o=!1,r=!1;const a=new Xe,s=new P,c={value:null,needsUpdate:!1};function l(){c.value!==n&&(c.value=n,c.needsUpdate=i>0),t.numPlanes=i,t.numIntersection=0}function d(e,n,i,o){const r=null!==e?e.length:0;let l=null;if(0!==r){if(l=c.value,!0!==o||null===l){const t=i+4*r,o=n.matrixWorldInverse;s.getNormalMatrix(o),(null===l||l.length<t)&&(l=new Float32Array(t));for(let t=0,n=i;t!==r;++t,n+=4)a.copy(e[t]).applyMatrix4(o,s),a.normal.toArray(l,n),l[n+3]=a.constant}c.value=l,c.needsUpdate=!0}return t.numPlanes=r,t.numIntersection=0,l}this.uniform=c,this.numPlanes=0,this.numIntersection=0,this.init=function(e,t,r){const a=0!==e.length||t||0!==i||o;return o=t,n=d(e,r,0),i=e.length,a},this.beginShadows=function(){r=!0,d(null)},this.endShadows=function(){r=!1,l()},this.setState=function(t,a,s){const h=t.clippingPlanes,f=t.clipIntersection,u=t.clipShadows,p=e.get(t);if(!o||null===h||0===h.length||r&&!u)r?d(null):l();else{const e=r?0:i,t=4*e;let o=p.clippingState||null;c.value=o,o=d(h,a,t,s);for(let e=0;e!==t;++e)o[e]=n[e];p.clippingState=o,this.numIntersection=f?this.numPlanes:0,this.numPlanes+=e}}}function Cn(e){let t=new WeakMap;function n(e,t){return 303===t?e.mapping=301:304===t&&(e.mapping=302),e}function i(e){const n=e.target;n.removeEventListener("dispose",i);const o=t.get(n);void 0!==o&&(t.delete(n),o.dispose())}return{get:function(o){if(o&&o.isTexture){const r=o.mapping;if(303===r||304===r){if(t.has(o))return n(t.get(o).texture,o.mapping);{const r=o.image;if(r&&r.height>0){const a=e.getRenderList(),s=e.getRenderTarget(),c=new gn(r.height/2);return c.fromEquirectangularTexture(e,o),t.set(o,c),e.setRenderTarget(s),e.setRenderList(a),o.addEventListener("dispose",i),n(c.texture,o.mapping)}return null}}}return o},dispose:function(){t=new WeakMap}}}function Mn(e){const t={};function n(n){if(void 0!==t[n])return t[n];let i;switch(n){case"WEBGL_depth_texture":i=e.getExtension("WEBGL_depth_texture")||e.getExtension("MOZ_WEBGL_depth_texture")||e.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=e.getExtension("EXT_texture_filter_anisotropic")||e.getExtension("MOZ_EXT_texture_filter_anisotropic")||e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=e.getExtension("WEBGL_compressed_texture_s3tc")||e.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=e.getExtension("WEBGL_compressed_texture_pvrtc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=e.getExtension(n)}return t[n]=i,i}return{has:function(e){return null!==n(e)},init:function(e){e.isWebGL2?n("EXT_color_buffer_float"):(n("WEBGL_depth_texture"),n("OES_texture_float"),n("OES_texture_half_float"),n("OES_texture_half_float_linear"),n("OES_standard_derivatives"),n("OES_element_index_uint"),n("OES_vertex_array_object"),n("ANGLE_instanced_arrays")),n("OES_texture_float_linear"),n("EXT_color_buffer_half_float")},get:function(e){const t=n(e);return null===t&&console.warn("THREE.WebGLRenderer: "+e+" extension not supported."),t}}}function Dn(e,t,n,i){const o={},r=new WeakMap;function a(e){const s=e.target;null!==s.index&&t.remove(s.index);for(const e in s.attributes)t.remove(s.attributes[e]);s.removeEventListener("dispose",a),delete o[s.id];const c=r.get(s);c&&(t.remove(c),r.delete(s)),i.releaseStatesOfGeometry(s),!0===s.isInstancedBufferGeometry&&delete s._maxInstanceCount,n.memory.geometries--}function s(e){const n=[],i=e.index,o=e.attributes.position;let a=0;if(null!==i){const e=i.array;a=i.version;for(let t=0,i=e.length;t<i;t+=3){const i=e[t+0],o=e[t+1],r=e[t+2];n.push(i,o,o,r,r,i)}}else{const e=o.array;a=o.version;for(let t=0,i=e.length/3-1;t<i;t+=3){const e=t+0,i=t+1,o=t+2;n.push(e,i,i,o,o,e)}}const s=new(Lt(n)>65535?Nt:Ot)(n,1);s.version=a;const c=r.get(e);c&&t.remove(c),r.set(e,s)}return{get:function(e,t){return!0===o[t.id]||(t.addEventListener("dispose",a),o[t.id]=!0,n.memory.geometries++),t},update:function(e){const n=e.attributes;for(const e in n)t.update(n[e],34962);const i=e.morphAttributes;for(const e in i){const n=i[e];for(let e=0,i=n.length;e<i;e++)t.update(n[e],34962)}},getWireframeAttribute:function(e){const t=r.get(e);if(t){const n=e.index;null!==n&&t.version<n.version&&s(e)}else s(e);return r.get(e)}}}function Pn(e,t,n,i){const o=i.isWebGL2;let r,a,s;this.setMode=function(e){r=e},this.setIndex=function(e){a=e.type,s=e.bytesPerElement},this.render=function(t,i){e.drawElements(r,i,a,t*s),n.update(i,r,1)},this.renderInstances=function(i,c,l){if(0===l)return;let d,h;if(o)d=e,h="drawElementsInstanced";else if(d=t.get("ANGLE_instanced_arrays"),h="drawElementsInstancedANGLE",null===d)return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");d[h](r,c,a,i*s,l),n.update(c,r,l)}}function Fn(e){const t={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:t,programs:null,autoReset:!0,reset:function(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0},update:function(e,n,i){switch(t.calls++,n){case 4:t.triangles+=i*(e/3);break;case 1:t.lines+=i*(e/2);break;case 3:t.lines+=i*(e-1);break;case 2:t.lines+=i*e;break;case 0:t.points+=i*e;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",n)}}}}function Hn(e,t){return e[0]-t[0]}function Un(e,t){return Math.abs(t[1])-Math.abs(e[1])}function Bn(e){const t={},n=new Float32Array(8),i=[];for(let e=0;e<8;e++)i[e]=[e,0];return{update:function(o,r,a,s){const c=o.morphTargetInfluences,l=void 0===c?0:c.length;let d=t[r.id];if(void 0===d){d=[];for(let e=0;e<l;e++)d[e]=[e,0];t[r.id]=d}for(let e=0;e<l;e++){const t=d[e];t[0]=e,t[1]=c[e]}d.sort(Un);for(let e=0;e<8;e++)e<l&&d[e][1]?(i[e][0]=d[e][0],i[e][1]=d[e][1]):(i[e][0]=Number.MAX_SAFE_INTEGER,i[e][1]=0);i.sort(Hn);const h=a.morphTargets&&r.morphAttributes.position,f=a.morphNormals&&r.morphAttributes.normal;let u=0;for(let e=0;e<8;e++){const t=i[e],o=t[0],a=t[1];o!==Number.MAX_SAFE_INTEGER&&a?(h&&r.getAttribute("morphTarget"+e)!==h[o]&&r.setAttribute("morphTarget"+e,h[o]),f&&r.getAttribute("morphNormal"+e)!==f[o]&&r.setAttribute("morphNormal"+e,f[o]),n[e]=a,u+=a):(h&&!0===r.hasAttribute("morphTarget"+e)&&r.deleteAttribute("morphTarget"+e),f&&!0===r.hasAttribute("morphNormal"+e)&&r.deleteAttribute("morphNormal"+e),n[e]=0)}const p=r.morphTargetsRelative?1:1-u;s.getUniforms().setValue(e,"morphTargetBaseInfluence",p),s.getUniforms().setValue(e,"morphTargetInfluences",n)}}}function zn(e,t,n,i){let o=new WeakMap;function r(e){const t=e.target;t.removeEventListener("dispose",r),n.remove(t.instanceMatrix),null!==t.instanceColor&&n.remove(t.instanceColor)}return{update:function(e){const a=i.render.frame,s=e.geometry,c=t.get(e,s);return o.get(c)!==a&&(t.update(c),o.set(c,a)),e.isInstancedMesh&&(!1===e.hasEventListener("dispose",r)&&e.addEventListener("dispose",r),n.update(e.instanceMatrix,34962),null!==e.instanceColor&&n.update(e.instanceColor,34962)),c},dispose:function(){o=new WeakMap}}}function Gn(e=null,t=1,n=1,i=1){B.call(this,null),this.image={data:e,width:t,height:n,depth:i},this.magFilter=a,this.minFilter=a,this.wrapR=o,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}function Wn(e=null,t=1,n=1,i=1){B.call(this,null),this.image={data:e,width:t,height:n,depth:i},this.magFilter=a,this.minFilter=a,this.wrapR=o,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}bn.physical={uniforms:cn([bn.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new D(1,1)},clearcoatNormalMap:{value:null},sheen:{value:new ht(0)},transmission:{value:0},transmissionMap:{value:null}}]),vertexShader:Sn.meshphysical_vert,fragmentShader:Sn.meshphysical_frag},Gn.prototype=Object.create(B.prototype),Gn.prototype.constructor=Gn,Gn.prototype.isDataTexture2DArray=!0,Wn.prototype=Object.create(B.prototype),Wn.prototype.constructor=Wn,Wn.prototype.isDataTexture3D=!0;const Yn=new B,Vn=new Gn,kn=new Wn,jn=new mn,Xn=[],qn=[],Kn=new Float32Array(16),Zn=new Float32Array(9),Jn=new Float32Array(4);function Qn(e,t,n){const i=e[0];if(i<=0||i>0)return e;const o=t*n;let r=Xn[o];if(void 0===r&&(r=new Float32Array(o),Xn[o]=r),0!==t){i.toArray(r,0);for(let i=1,o=0;i!==t;++i)o+=n,e[i].toArray(r,o)}return r}function $n(e,t){if(e.length!==t.length)return!1;for(let n=0,i=e.length;n<i;n++)if(e[n]!==t[n])return!1;return!0}function ei(e,t){for(let n=0,i=t.length;n<i;n++)e[n]=t[n]}function ti(e,t){let n=qn[t];void 0===n&&(n=new Int32Array(t),qn[t]=n);for(let i=0;i!==t;++i)n[i]=e.allocateTextureUnit();return n}function ni(e,t){const n=this.cache;n[0]!==t&&(e.uniform1f(this.addr,t),n[0]=t)}function ii(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y||(e.uniform2f(this.addr,t.x,t.y),n[0]=t.x,n[1]=t.y);else{if($n(n,t))return;e.uniform2fv(this.addr,t),ei(n,t)}}function oi(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y&&n[2]===t.z||(e.uniform3f(this.addr,t.x,t.y,t.z),n[0]=t.x,n[1]=t.y,n[2]=t.z);else if(void 0!==t.r)n[0]===t.r&&n[1]===t.g&&n[2]===t.b||(e.uniform3f(this.addr,t.r,t.g,t.b),n[0]=t.r,n[1]=t.g,n[2]=t.b);else{if($n(n,t))return;e.uniform3fv(this.addr,t),ei(n,t)}}function ri(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y&&n[2]===t.z&&n[3]===t.w||(e.uniform4f(this.addr,t.x,t.y,t.z,t.w),n[0]=t.x,n[1]=t.y,n[2]=t.z,n[3]=t.w);else{if($n(n,t))return;e.uniform4fv(this.addr,t),ei(n,t)}}function ai(e,t){const n=this.cache,i=t.elements;if(void 0===i){if($n(n,t))return;e.uniformMatrix2fv(this.addr,!1,t),ei(n,t)}else{if($n(n,i))return;Jn.set(i),e.uniformMatrix2fv(this.addr,!1,Jn),ei(n,i)}}function si(e,t){const n=this.cache,i=t.elements;if(void 0===i){if($n(n,t))return;e.uniformMatrix3fv(this.addr,!1,t),ei(n,t)}else{if($n(n,i))return;Zn.set(i),e.uniformMatrix3fv(this.addr,!1,Zn),ei(n,i)}}function ci(e,t){const n=this.cache,i=t.elements;if(void 0===i){if($n(n,t))return;e.uniformMatrix4fv(this.addr,!1,t),ei(n,t)}else{if($n(n,i))return;Kn.set(i),e.uniformMatrix4fv(this.addr,!1,Kn),ei(n,i)}}function li(e,t,n){const i=this.cache,o=n.allocateTextureUnit();i[0]!==o&&(e.uniform1i(this.addr,o),i[0]=o),n.safeSetTexture2D(t||Yn,o)}function di(e,t,n){const i=this.cache,o=n.allocateTextureUnit();i[0]!==o&&(e.uniform1i(this.addr,o),i[0]=o),n.setTexture2DArray(t||Vn,o)}function hi(e,t,n){const i=this.cache,o=n.allocateTextureUnit();i[0]!==o&&(e.uniform1i(this.addr,o),i[0]=o),n.setTexture3D(t||kn,o)}function fi(e,t,n){const i=this.cache,o=n.allocateTextureUnit();i[0]!==o&&(e.uniform1i(this.addr,o),i[0]=o),n.safeSetTextureCube(t||jn,o)}function ui(e,t){const n=this.cache;n[0]!==t&&(e.uniform1i(this.addr,t),n[0]=t)}function pi(e,t){const n=this.cache;$n(n,t)||(e.uniform2iv(this.addr,t),ei(n,t))}function mi(e,t){const n=this.cache;$n(n,t)||(e.uniform3iv(this.addr,t),ei(n,t))}function gi(e,t){const n=this.cache;$n(n,t)||(e.uniform4iv(this.addr,t),ei(n,t))}function Ei(e,t){const n=this.cache;n[0]!==t&&(e.uniform1ui(this.addr,t),n[0]=t)}function Ti(e,t){e.uniform1fv(this.addr,t)}function vi(e,t){e.uniform1iv(this.addr,t)}function Ai(e,t){e.uniform2iv(this.addr,t)}function Ri(e,t){e.uniform3iv(this.addr,t)}function Ii(e,t){e.uniform4iv(this.addr,t)}function Oi(e,t){const n=Qn(t,this.size,2);e.uniform2fv(this.addr,n)}function Si(e,t){const n=Qn(t,this.size,3);e.uniform3fv(this.addr,n)}function Ni(e,t){const n=Qn(t,this.size,4);e.uniform4fv(this.addr,n)}function bi(e,t){const n=Qn(t,this.size,4);e.uniformMatrix2fv(this.addr,!1,n)}function yi(e,t){const n=Qn(t,this.size,9);e.uniformMatrix3fv(this.addr,!1,n)}function xi(e,t){const n=Qn(t,this.size,16);e.uniformMatrix4fv(this.addr,!1,n)}function Li(e,t,n){const i=t.length,o=ti(n,i);e.uniform1iv(this.addr,o);for(let e=0;e!==i;++e)n.safeSetTexture2D(t[e]||Yn,o[e])}function _i(e,t,n){const i=t.length,o=ti(n,i);e.uniform1iv(this.addr,o);for(let e=0;e!==i;++e)n.safeSetTextureCube(t[e]||jn,o[e])}function wi(e,t,n){this.id=e,this.addr=n,this.cache=[],this.setValue=function(e){switch(e){case 5126:return ni;case 35664:return ii;case 35665:return oi;case 35666:return ri;case 35674:return ai;case 35675:return si;case 35676:return ci;case 5124:case 35670:return ui;case 35667:case 35671:return pi;case 35668:case 35672:return mi;case 35669:case 35673:return gi;case 5125:return Ei;case 35678:case 36198:case 36298:case 36306:case 35682:return li;case 35679:case 36299:case 36307:return hi;case 35680:case 36300:case 36308:case 36293:return fi;case 36289:case 36303:case 36311:case 36292:return di}}(t.type)}function Ci(e,t,n){this.id=e,this.addr=n,this.cache=[],this.size=t.size,this.setValue=function(e){switch(e){case 5126:return Ti;case 35664:return Oi;case 35665:return Si;case 35666:return Ni;case 35674:return bi;case 35675:return yi;case 35676:return xi;case 5124:case 35670:return vi;case 35667:case 35671:return Ai;case 35668:case 35672:return Ri;case 35669:case 35673:return Ii;case 35678:case 36198:case 36298:case 36306:case 35682:return Li;case 35680:case 36300:case 36308:case 36293:return _i}}(t.type)}function Mi(e){this.id=e,this.seq=[],this.map={}}Ci.prototype.updateCache=function(e){const t=this.cache;e instanceof Float32Array&&t.length!==e.length&&(this.cache=new Float32Array(e.length)),ei(t,e)},Mi.prototype.setValue=function(e,t,n){const i=this.seq;for(let o=0,r=i.length;o!==r;++o){const r=i[o];r.setValue(e,t[r.id],n)}};const Di=/(\w+)(\])?(\[|\.)?/g;function Pi(e,t){e.seq.push(t),e.map[t.id]=t}function Fi(e,t,n){const i=e.name,o=i.length;for(Di.lastIndex=0;;){const r=Di.exec(i),a=Di.lastIndex;let s=r[1];const c="]"===r[2],l=r[3];if(c&&(s|=0),void 0===l||"["===l&&a+2===o){Pi(n,void 0===l?new wi(s,e,t):new Ci(s,e,t));break}{let e=n.map[s];void 0===e&&(e=new Mi(s),Pi(n,e)),n=e}}}function Hi(e,t){this.seq=[],this.map={};const n=e.getProgramParameter(t,35718);for(let i=0;i<n;++i){const n=e.getActiveUniform(t,i);Fi(n,e.getUniformLocation(t,n.name),this)}}function Ui(e,t,n){const i=e.createShader(t);return e.shaderSource(i,n),e.compileShader(i),i}Hi.prototype.setValue=function(e,t,n,i){const o=this.map[t];void 0!==o&&o.setValue(e,n,i)},Hi.prototype.setOptional=function(e,t,n){const i=t[n];void 0!==i&&this.setValue(e,n,i)},Hi.upload=function(e,t,n,i){for(let o=0,r=t.length;o!==r;++o){const r=t[o],a=n[r.id];!1!==a.needsUpdate&&r.setValue(e,a.value,i)}},Hi.seqWithValue=function(e,t){const n=[];for(let i=0,o=e.length;i!==o;++i){const o=e[i];o.id in t&&n.push(o)}return n};let Bi=0;function zi(e){switch(e){case S:return["Linear","( value )"];case N:return["sRGB","( value )"];case 3002:return["RGBE","( value )"];case 3004:return["RGBM","( value, 7.0 )"];case 3005:return["RGBM","( value, 16.0 )"];case 3006:return["RGBD","( value, 256.0 )"];case 3007:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case 3003:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",e),["Linear","( value )"]}}function Gi(e,t,n){const i=e.getShaderParameter(t,35713),o=e.getShaderInfoLog(t).trim();return i&&""===o?"":"THREE.WebGLShader: gl.getShaderInfoLog() "+n+"\n"+o+function(e){const t=e.split("\n");for(let e=0;e<t.length;e++)t[e]=e+1+": "+t[e];return t.join("\n")}(e.getShaderSource(t))}function Wi(e,t){const n=zi(t);return"vec4 "+e+"( vec4 value ) { return "+n[0]+"ToLinear"+n[1]+"; }"}function Yi(e,t){const n=zi(t);return"vec4 "+e+"( vec4 value ) { return LinearTo"+n[0]+n[1]+"; }"}function Vi(e,t){let n;switch(t){case 1:n="Linear";break;case 2:n="Reinhard";break;case 3:n="OptimizedCineon";break;case 4:n="ACESFilmic";break;case 5:n="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),n="Linear"}return"vec3 "+e+"( vec3 color ) { return "+n+"ToneMapping( color ); }"}function ki(e){return""!==e}function ji(e,t){return e.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function Xi(e,t){return e.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const qi=/^[ \t]*#include +<([\w\d./]+)>/gm;function Ki(e){return e.replace(qi,Zi)}function Zi(e,t){const n=Sn[t];if(void 0===n)throw new Error("Can not resolve #include <"+t+">");return Ki(n)}const Ji=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,Qi=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function $i(e){return e.replace(Qi,to).replace(Ji,eo)}function eo(e,t,n,i){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),to(0,t,n,i)}function to(e,t,n,i){let o="";for(let e=parseInt(t);e<parseInt(n);e++)o+=i.replace(/\[\s*i\s*\]/g,"[ "+e+" ]").replace(/UNROLLED_LOOP_INDEX/g,e);return o}function no(e){let t="precision "+e.precision+" float;\nprecision "+e.precision+" int;";return"highp"===e.precision?t+="\n#define HIGH_PRECISION":"mediump"===e.precision?t+="\n#define MEDIUM_PRECISION":"lowp"===e.precision&&(t+="\n#define LOW_PRECISION"),t}function io(e,t,n,i){const o=e.getContext(),r=n.defines;let a=n.vertexShader,s=n.fragmentShader;const c=function(e){let t="SHADOWMAP_TYPE_BASIC";return 1===e.shadowMapType?t="SHADOWMAP_TYPE_PCF":2===e.shadowMapType?t="SHADOWMAP_TYPE_PCF_SOFT":3===e.shadowMapType&&(t="SHADOWMAP_TYPE_VSM"),t}(n),l=function(e){let t="ENVMAP_TYPE_CUBE";if(e.envMap)switch(e.envMapMode){case 301:case 302:t="ENVMAP_TYPE_CUBE";break;case 306:case 307:t="ENVMAP_TYPE_CUBE_UV"}return t}(n),d=function(e){let t="ENVMAP_MODE_REFLECTION";if(e.envMap)switch(e.envMapMode){case 302:case 307:t="ENVMAP_MODE_REFRACTION"}return t}(n),h=function(e){let t="ENVMAP_BLENDING_NONE";if(e.envMap)switch(e.combine){case 0:t="ENVMAP_BLENDING_MULTIPLY";break;case 1:t="ENVMAP_BLENDING_MIX";break;case 2:t="ENVMAP_BLENDING_ADD"}return t}(n),f=e.gammaFactor>0?e.gammaFactor:1,u=n.isWebGL2?"":function(e){return[e.extensionDerivatives||e.envMapCubeUV||e.bumpMap||e.tangentSpaceNormalMap||e.clearcoatNormalMap||e.flatShading||"physical"===e.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(e.extensionFragDepth||e.logarithmicDepthBuffer)&&e.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",e.extensionDrawBuffers&&e.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(e.extensionShaderTextureLOD||e.envMap)&&e.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(ki).join("\n")}(n),p=function(e){const t=[];for(const n in e){const i=e[n];!1!==i&&t.push("#define "+n+" "+i)}return t.join("\n")}(r),m=o.createProgram();let g,E,T=n.glslVersion?"#version "+n.glslVersion+"\n":"";n.isRawShaderMaterial?(g=[p].filter(ki).join("\n"),g.length>0&&(g+="\n"),E=[u,p].filter(ki).join("\n"),E.length>0&&(E+="\n")):(g=[no(n),"#define SHADER_NAME "+n.shaderName,p,n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+f,"#define MAX_BONES "+n.maxBones,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+d:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.displacementMap&&n.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.useVertexTexture?"#define BONE_TEXTURE":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&!1===n.flatShading?"#define USE_MORPHNORMALS":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+c:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#ifdef USE_COLOR","\tattribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(ki).join("\n"),E=[u,no(n),"#define SHADER_NAME "+n.shaderName,p,n.alphaTest?"#define ALPHATEST "+n.alphaTest+(n.alphaTest%1?"":".0"):"","#define GAMMA_FACTOR "+f,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+l:"",n.envMap?"#define "+d:"",n.envMap?"#define "+h:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.sheen?"#define USE_SHEEN":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor?"#define USE_COLOR":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+c:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(n.extensionShaderTextureLOD||n.envMap)&&n.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",0!==n.toneMapping?"#define TONE_MAPPING":"",0!==n.toneMapping?Sn.tonemapping_pars_fragment:"",0!==n.toneMapping?Vi("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",Sn.encodings_pars_fragment,n.map?Wi("mapTexelToLinear",n.mapEncoding):"",n.matcap?Wi("matcapTexelToLinear",n.matcapEncoding):"",n.envMap?Wi("envMapTexelToLinear",n.envMapEncoding):"",n.emissiveMap?Wi("emissiveMapTexelToLinear",n.emissiveMapEncoding):"",n.lightMap?Wi("lightMapTexelToLinear",n.lightMapEncoding):"",Yi("linearToOutputTexel",n.outputEncoding),n.depthPacking?"#define DEPTH_PACKING "+n.depthPacking:"","\n"].filter(ki).join("\n")),a=Ki(a),a=ji(a,n),a=Xi(a,n),s=Ki(s),s=ji(s,n),s=Xi(s,n),a=$i(a),s=$i(s),n.isWebGL2&&!0!==n.isRawShaderMaterial&&(T="#version 300 es\n",g=["#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+g,E=["#define varying in",n.glslVersion===L?"":"out highp vec4 pc_fragColor;",n.glslVersion===L?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+E);const v=T+E+s,A=Ui(o,35633,T+g+a),R=Ui(o,35632,v);if(o.attachShader(m,A),o.attachShader(m,R),void 0!==n.index0AttributeName?o.bindAttribLocation(m,0,n.index0AttributeName):!0===n.morphTargets&&o.bindAttribLocation(m,0,"position"),o.linkProgram(m),e.debug.checkShaderErrors){const e=o.getProgramInfoLog(m).trim(),t=o.getShaderInfoLog(A).trim(),n=o.getShaderInfoLog(R).trim();let i=!0,r=!0;if(!1===o.getProgramParameter(m,35714)){i=!1;const t=Gi(o,A,"vertex"),n=Gi(o,R,"fragment");console.error("THREE.WebGLProgram: shader error: ",o.getError(),"35715",o.getProgramParameter(m,35715),"gl.getProgramInfoLog",e,t,n)}else""!==e?console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",e):""!==t&&""!==n||(r=!1);r&&(this.diagnostics={runnable:i,programLog:e,vertexShader:{log:t,prefix:g},fragmentShader:{log:n,prefix:E}})}let I,O;return o.deleteShader(A),o.deleteShader(R),this.getUniforms=function(){return void 0===I&&(I=new Hi(o,m)),I},this.getAttributes=function(){return void 0===O&&(O=function(e,t){const n={},i=e.getProgramParameter(t,35721);for(let o=0;o<i;o++){const i=e.getActiveAttrib(t,o).name;n[i]=e.getAttribLocation(t,i)}return n}(o,m)),O},this.destroy=function(){i.releaseStatesOfProgram(this),o.deleteProgram(m),this.program=void 0},this.name=n.shaderName,this.id=Bi++,this.cacheKey=t,this.usedTimes=1,this.program=m,this.vertexShader=A,this.fragmentShader=R,this}function oo(e,t,n,i,o,r){const a=[],s=i.isWebGL2,c=i.logarithmicDepthBuffer,l=i.floatVertexTextures,d=i.maxVertexUniforms,h=i.vertexTextures;let f=i.precision;const u={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},p=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","maxMorphTargets","maxMorphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","sheen","transmissionMap"];function m(e){let t;return e&&e.isTexture?t=e.encoding:e&&e.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),t=e.texture.encoding):t=S,t}return{getParameters:function(o,a,p,g,E){const T=g.fog,v=o.isMeshStandardMaterial?g.environment:null,A=t.get(o.envMap||v),R=u[o.type],I=E.isSkinnedMesh?function(e){const t=e.skeleton.bones;if(l)return 1024;{const e=d,n=Math.floor((e-20)/4),i=Math.min(n,t.length);return i<t.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+t.length+" bones. This GPU supports "+i+"."),0):i}}(E):0;let O,S;if(null!==o.precision&&(f=i.getMaxPrecision(o.precision),f!==o.precision&&console.warn("THREE.WebGLProgram.getParameters:",o.precision,"not supported, using",f,"instead.")),R){const e=bn[R];O=e.vertexShader,S=e.fragmentShader}else O=o.vertexShader,S=o.fragmentShader;const N=e.getRenderTarget();return{isWebGL2:s,shaderID:R,shaderName:o.type,vertexShader:O,fragmentShader:S,defines:o.defines,isRawShaderMaterial:!0===o.isRawShaderMaterial,glslVersion:o.glslVersion,precision:f,instancing:!0===E.isInstancedMesh,instancingColor:!0===E.isInstancedMesh&&null!==E.instanceColor,supportsVertexTextures:h,outputEncoding:null!==N?m(N.texture):e.outputEncoding,map:!!o.map,mapEncoding:m(o.map),matcap:!!o.matcap,matcapEncoding:m(o.matcap),envMap:!!A,envMapMode:A&&A.mapping,envMapEncoding:m(A),envMapCubeUV:!!A&&(306===A.mapping||307===A.mapping),lightMap:!!o.lightMap,lightMapEncoding:m(o.lightMap),aoMap:!!o.aoMap,emissiveMap:!!o.emissiveMap,emissiveMapEncoding:m(o.emissiveMap),bumpMap:!!o.bumpMap,normalMap:!!o.normalMap,objectSpaceNormalMap:1===o.normalMapType,tangentSpaceNormalMap:0===o.normalMapType,clearcoatMap:!!o.clearcoatMap,clearcoatRoughnessMap:!!o.clearcoatRoughnessMap,clearcoatNormalMap:!!o.clearcoatNormalMap,displacementMap:!!o.displacementMap,roughnessMap:!!o.roughnessMap,metalnessMap:!!o.metalnessMap,specularMap:!!o.specularMap,alphaMap:!!o.alphaMap,gradientMap:!!o.gradientMap,sheen:!!o.sheen,transmissionMap:!!o.transmissionMap,combine:o.combine,vertexTangents:o.normalMap&&o.vertexTangents,vertexColors:o.vertexColors,vertexUvs:!!(o.map||o.bumpMap||o.normalMap||o.specularMap||o.alphaMap||o.emissiveMap||o.roughnessMap||o.metalnessMap||o.clearcoatMap||o.clearcoatRoughnessMap||o.clearcoatNormalMap||o.displacementMap||o.transmissionMap),uvsVertexOnly:!(o.map||o.bumpMap||o.normalMap||o.specularMap||o.alphaMap||o.emissiveMap||o.roughnessMap||o.metalnessMap||o.clearcoatNormalMap||o.transmissionMap||!o.displacementMap),fog:!!T,useFog:o.fog,fogExp2:T&&T.isFogExp2,flatShading:o.flatShading,sizeAttenuation:o.sizeAttenuation,logarithmicDepthBuffer:c,skinning:o.skinning&&I>0,maxBones:I,useVertexTexture:l,morphTargets:o.morphTargets,morphNormals:o.morphNormals,maxMorphTargets:e.maxMorphTargets,maxMorphNormals:e.maxMorphNormals,numDirLights:a.directional.length,numPointLights:a.point.length,numSpotLights:a.spot.length,numRectAreaLights:a.rectArea.length,numHemiLights:a.hemi.length,numDirLightShadows:a.directionalShadowMap.length,numPointLightShadows:a.pointShadowMap.length,numSpotLightShadows:a.spotShadowMap.length,numClippingPlanes:r.numPlanes,numClipIntersection:r.numIntersection,dithering:o.dithering,shadowMapEnabled:e.shadowMap.enabled&&p.length>0,shadowMapType:e.shadowMap.type,toneMapping:o.toneMapped?e.toneMapping:0,physicallyCorrectLights:e.physicallyCorrectLights,premultipliedAlpha:o.premultipliedAlpha,alphaTest:o.alphaTest,doubleSided:2===o.side,flipSided:1===o.side,depthPacking:void 0!==o.depthPacking&&o.depthPacking,index0AttributeName:o.index0AttributeName,extensionDerivatives:o.extensions&&o.extensions.derivatives,extensionFragDepth:o.extensions&&o.extensions.fragDepth,extensionDrawBuffers:o.extensions&&o.extensions.drawBuffers,extensionShaderTextureLOD:o.extensions&&o.extensions.shaderTextureLOD,rendererExtensionFragDepth:s||n.has("EXT_frag_depth"),rendererExtensionDrawBuffers:s||n.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:s||n.has("EXT_shader_texture_lod"),customProgramCacheKey:o.customProgramCacheKey()}},getProgramCacheKey:function(t){const n=[];if(t.shaderID?n.push(t.shaderID):(n.push(t.fragmentShader),n.push(t.vertexShader)),void 0!==t.defines)for(const e in t.defines)n.push(e),n.push(t.defines[e]);if(!1===t.isRawShaderMaterial){for(let e=0;e<p.length;e++)n.push(t[p[e]]);n.push(e.outputEncoding),n.push(e.gammaFactor)}return n.push(t.customProgramCacheKey),n.join()},getUniforms:function(e){const t=u[e.type];let n;if(t){const e=bn[t];n=ln.clone(e.uniforms)}else n=e.uniforms;return n},acquireProgram:function(t,n){let i;for(let e=0,t=a.length;e<t;e++){const t=a[e];if(t.cacheKey===n){i=t,++i.usedTimes;break}}return void 0===i&&(i=new io(e,n,t,o),a.push(i)),i},releaseProgram:function(e){if(0==--e.usedTimes){const t=a.indexOf(e);a[t]=a[a.length-1],a.pop(),e.destroy()}},programs:a}}function ro(){let e=new WeakMap;return{get:function(t){let n=e.get(t);return void 0===n&&(n={},e.set(t,n)),n},remove:function(t){e.delete(t)},update:function(t,n,i){e.get(t)[n]=i},dispose:function(){e=new WeakMap}}}function ao(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.program!==t.program?e.program.id-t.program.id:e.material.id!==t.material.id?e.material.id-t.material.id:e.z!==t.z?e.z-t.z:e.id-t.id}function so(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.z!==t.z?t.z-e.z:e.id-t.id}function co(e){const t=[];let n=0;const i=[],o=[],r={id:-1};function a(i,o,a,s,c,l){let d=t[n];const h=e.get(a);return void 0===d?(d={id:i.id,object:i,geometry:o,material:a,program:h.program||r,groupOrder:s,renderOrder:i.renderOrder,z:c,group:l},t[n]=d):(d.id=i.id,d.object=i,d.geometry=o,d.material=a,d.program=h.program||r,d.groupOrder=s,d.renderOrder=i.renderOrder,d.z=c,d.group=l),n++,d}return{opaque:i,transparent:o,init:function(){n=0,i.length=0,o.length=0},push:function(e,t,n,r,s,c){const l=a(e,t,n,r,s,c);(!0===n.transparent?o:i).push(l)},unshift:function(e,t,n,r,s,c){const l=a(e,t,n,r,s,c);(!0===n.transparent?o:i).unshift(l)},finish:function(){for(let e=n,i=t.length;e<i;e++){const n=t[e];if(null===n.id)break;n.id=null,n.object=null,n.geometry=null,n.material=null,n.program=null,n.group=null}},sort:function(e,t){i.length>1&&i.sort(e||ao),o.length>1&&o.sort(t||so)}}}function lo(e){let t=new WeakMap;return{get:function(n,i){const o=t.get(n);let r;return void 0===o?(r=new co(e),t.set(n,new WeakMap),t.get(n).set(i,r)):(r=o.get(i),void 0===r&&(r=new co(e),o.set(i,r))),r},dispose:function(){t=new WeakMap}}}function ho(){const e={};return{get:function(t){if(void 0!==e[t.id])return e[t.id];let n;switch(t.type){case"DirectionalLight":n={direction:new V,color:new ht};break;case"SpotLight":n={position:new V,direction:new V,color:new ht,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":n={position:new V,color:new ht,distance:0,decay:0};break;case"HemisphereLight":n={direction:new V,skyColor:new ht,groundColor:new ht};break;case"RectAreaLight":n={color:new ht,position:new V,halfWidth:new V,halfHeight:new V}}return e[t.id]=n,n}}}let fo=0;function uo(e,t){return(t.castShadow?1:0)-(e.castShadow?1:0)}function po(e,t){const n=new ho,i=function(){const e={};return{get:function(t){if(void 0!==e[t.id])return e[t.id];let n;switch(t.type){case"DirectionalLight":case"SpotLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new D};break;case"PointLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new D,shadowCameraNear:1,shadowCameraFar:1e3}}return e[t.id]=n,n}}}(),o={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let e=0;e<9;e++)o.probe.push(new V);const r=new V,a=new Te,s=new Te;return{setup:function(r){let a=0,s=0,c=0;for(let e=0;e<9;e++)o.probe[e].set(0,0,0);let l=0,d=0,h=0,f=0,u=0,p=0,m=0,g=0;r.sort(uo);for(let e=0,t=r.length;e<t;e++){const t=r[e],E=t.color,T=t.intensity,v=t.distance,A=t.shadow&&t.shadow.map?t.shadow.map.texture:null;if(t.isAmbientLight)a+=E.r*T,s+=E.g*T,c+=E.b*T;else if(t.isLightProbe)for(let e=0;e<9;e++)o.probe[e].addScaledVector(t.sh.coefficients[e],T);else if(t.isDirectionalLight){const e=n.get(t);if(e.color.copy(t.color).multiplyScalar(t.intensity),t.castShadow){const e=t.shadow,n=i.get(t);n.shadowBias=e.bias,n.shadowNormalBias=e.normalBias,n.shadowRadius=e.radius,n.shadowMapSize=e.mapSize,o.directionalShadow[l]=n,o.directionalShadowMap[l]=A,o.directionalShadowMatrix[l]=t.shadow.matrix,p++}o.directional[l]=e,l++}else if(t.isSpotLight){const e=n.get(t);if(e.position.setFromMatrixPosition(t.matrixWorld),e.color.copy(E).multiplyScalar(T),e.distance=v,e.coneCos=Math.cos(t.angle),e.penumbraCos=Math.cos(t.angle*(1-t.penumbra)),e.decay=t.decay,t.castShadow){const e=t.shadow,n=i.get(t);n.shadowBias=e.bias,n.shadowNormalBias=e.normalBias,n.shadowRadius=e.radius,n.shadowMapSize=e.mapSize,o.spotShadow[h]=n,o.spotShadowMap[h]=A,o.spotShadowMatrix[h]=t.shadow.matrix,g++}o.spot[h]=e,h++}else if(t.isRectAreaLight){const e=n.get(t);e.color.copy(E).multiplyScalar(T),e.halfWidth.set(.5*t.width,0,0),e.halfHeight.set(0,.5*t.height,0),o.rectArea[f]=e,f++}else if(t.isPointLight){const e=n.get(t);if(e.color.copy(t.color).multiplyScalar(t.intensity),e.distance=t.distance,e.decay=t.decay,t.castShadow){const e=t.shadow,n=i.get(t);n.shadowBias=e.bias,n.shadowNormalBias=e.normalBias,n.shadowRadius=e.radius,n.shadowMapSize=e.mapSize,n.shadowCameraNear=e.camera.near,n.shadowCameraFar=e.camera.far,o.pointShadow[d]=n,o.pointShadowMap[d]=A,o.pointShadowMatrix[d]=t.shadow.matrix,m++}o.point[d]=e,d++}else if(t.isHemisphereLight){const e=n.get(t);e.skyColor.copy(t.color).multiplyScalar(T),e.groundColor.copy(t.groundColor).multiplyScalar(T),o.hemi[u]=e,u++}}f>0&&(t.isWebGL2||!0===e.has("OES_texture_float_linear")?(o.rectAreaLTC1=Nn.LTC_FLOAT_1,o.rectAreaLTC2=Nn.LTC_FLOAT_2):!0===e.has("OES_texture_half_float_linear")?(o.rectAreaLTC1=Nn.LTC_HALF_1,o.rectAreaLTC2=Nn.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),o.ambient[0]=a,o.ambient[1]=s,o.ambient[2]=c;const E=o.hash;E.directionalLength===l&&E.pointLength===d&&E.spotLength===h&&E.rectAreaLength===f&&E.hemiLength===u&&E.numDirectionalShadows===p&&E.numPointShadows===m&&E.numSpotShadows===g||(o.directional.length=l,o.spot.length=h,o.rectArea.length=f,o.point.length=d,o.hemi.length=u,o.directionalShadow.length=p,o.directionalShadowMap.length=p,o.pointShadow.length=m,o.pointShadowMap.length=m,o.spotShadow.length=g,o.spotShadowMap.length=g,o.directionalShadowMatrix.length=p,o.pointShadowMatrix.length=m,o.spotShadowMatrix.length=g,E.directionalLength=l,E.pointLength=d,E.spotLength=h,E.rectAreaLength=f,E.hemiLength=u,E.numDirectionalShadows=p,E.numPointShadows=m,E.numSpotShadows=g,o.version=fo++)},setupView:function(e,t){let n=0,i=0,c=0,l=0,d=0;const h=t.matrixWorldInverse;for(let t=0,f=e.length;t<f;t++){const f=e[t];if(f.isDirectionalLight){const e=o.directional[n];e.direction.setFromMatrixPosition(f.matrixWorld),r.setFromMatrixPosition(f.target.matrixWorld),e.direction.sub(r),e.direction.transformDirection(h),n++}else if(f.isSpotLight){const e=o.spot[c];e.position.setFromMatrixPosition(f.matrixWorld),e.position.applyMatrix4(h),e.direction.setFromMatrixPosition(f.matrixWorld),r.setFromMatrixPosition(f.target.matrixWorld),e.direction.sub(r),e.direction.transformDirection(h),c++}else if(f.isRectAreaLight){const e=o.rectArea[l];e.position.setFromMatrixPosition(f.matrixWorld),e.position.applyMatrix4(h),s.identity(),a.copy(f.matrixWorld),a.premultiply(h),s.extractRotation(a),e.halfWidth.set(.5*f.width,0,0),e.halfHeight.set(0,.5*f.height,0),e.halfWidth.applyMatrix4(s),e.halfHeight.applyMatrix4(s),l++}else if(f.isPointLight){const e=o.point[i];e.position.setFromMatrixPosition(f.matrixWorld),e.position.applyMatrix4(h),i++}else if(f.isHemisphereLight){const e=o.hemi[d];e.direction.setFromMatrixPosition(f.matrixWorld),e.direction.transformDirection(h),e.direction.normalize(),d++}}},state:o}}function mo(e,t){const n=new po(e,t),i=[],o=[];return{init:function(){i.length=0,o.length=0},state:{lightsArray:i,shadowsArray:o,lights:n},setupLights:function(){n.setup(i)},setupLightsView:function(e){n.setupView(i,e)},pushLight:function(e){i.push(e)},pushShadow:function(e){o.push(e)}}}function go(e,t){let n=new WeakMap;return{get:function(i,o=0){let r;return!1===n.has(i)?(r=new mo(e,t),n.set(i,[]),n.get(i).push(r)):o>=n.get(i).length?(r=new mo(e,t),n.get(i).push(r)):r=n.get(i)[o],r},dispose:function(){n=new WeakMap}}}function Eo(e){pt.call(this),this.type="MeshDepthMaterial",this.depthPacking=3200,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(e)}function To(e){pt.call(this),this.type="MeshDistanceMaterial",this.referencePosition=new V,this.nearDistance=1,this.farDistance=1e3,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(e)}function vo(e,t,n){let i=new An;const o=new D,r=new D,c=new G,l=[],d=[],h={},f={0:1,1:0,2:2},u=new dn({defines:{SAMPLE_RATE:2/8,HALF_SAMPLE_RATE:1/8},uniforms:{shadow_pass:{value:null},resolution:{value:new D},radius:{value:4}},vertexShader:"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),p=u.clone();p.defines.HORIZONTAL_PASS=1;const g=new Bt;g.setAttribute("position",new Tt(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const E=new on(g,u),T=this;function v(n,i){const o=t.update(E);u.uniforms.shadow_pass.value=n.map.texture,u.uniforms.resolution.value=n.mapSize,u.uniforms.radius.value=n.radius,e.setRenderTarget(n.mapPass),e.clear(),e.renderBufferDirect(i,null,o,u,E,null),p.uniforms.shadow_pass.value=n.mapPass.texture,p.uniforms.resolution.value=n.mapSize,p.uniforms.radius.value=n.radius,e.setRenderTarget(n.map),e.clear(),e.renderBufferDirect(i,null,o,p,E,null)}function A(e,t,n){const i=e<<0|t<<1|n<<2;let o=l[i];return void 0===o&&(o=new Eo({depthPacking:3201,morphTargets:e,skinning:t}),l[i]=o),o}function R(e,t,n){const i=e<<0|t<<1|n<<2;let o=d[i];return void 0===o&&(o=new To({morphTargets:e,skinning:t}),d[i]=o),o}function I(t,n,i,o,r,a,s){let c=null,l=A,d=t.customDepthMaterial;if(!0===o.isPointLight&&(l=R,d=t.customDistanceMaterial),void 0===d){let e=!1;!0===i.morphTargets&&(e=n.morphAttributes&&n.morphAttributes.position&&n.morphAttributes.position.length>0);let o=!1;!0===t.isSkinnedMesh&&(!0===i.skinning?o=!0:console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",t)),c=l(e,o,!0===t.isInstancedMesh)}else c=d;if(e.localClippingEnabled&&!0===i.clipShadows&&0!==i.clippingPlanes.length){const e=c.uuid,t=i.uuid;let n=h[e];void 0===n&&(n={},h[e]=n);let o=n[t];void 0===o&&(o=c.clone(),n[t]=o),c=o}return c.visible=i.visible,c.wireframe=i.wireframe,c.side=3===s?null!==i.shadowSide?i.shadowSide:i.side:null!==i.shadowSide?i.shadowSide:f[i.side],c.clipShadows=i.clipShadows,c.clippingPlanes=i.clippingPlanes,c.clipIntersection=i.clipIntersection,c.wireframeLinewidth=i.wireframeLinewidth,c.linewidth=i.linewidth,!0===o.isPointLight&&!0===c.isMeshDistanceMaterial&&(c.referencePosition.setFromMatrixPosition(o.matrixWorld),c.nearDistance=r,c.farDistance=a),c}function O(n,o,r,a,s){if(!1===n.visible)return;if(n.layers.test(o.layers)&&(n.isMesh||n.isLine||n.isPoints)&&(n.castShadow||n.receiveShadow&&3===s)&&(!n.frustumCulled||i.intersectsObject(n))){n.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse,n.matrixWorld);const i=t.update(n),o=n.material;if(Array.isArray(o)){const t=i.groups;for(let c=0,l=t.length;c<l;c++){const l=t[c],d=o[l.materialIndex];if(d&&d.visible){const t=I(n,i,d,a,r.near,r.far,s);e.renderBufferDirect(r,null,i,t,n,l)}}}else if(o.visible){const t=I(n,i,o,a,r.near,r.far,s);e.renderBufferDirect(r,null,i,t,n,null)}}const c=n.children;for(let e=0,t=c.length;e<t;e++)O(c[e],o,r,a,s)}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=1,this.render=function(t,l,d){if(!1===T.enabled)return;if(!1===T.autoUpdate&&!1===T.needsUpdate)return;if(0===t.length)return;const h=e.getRenderTarget(),f=e.getActiveCubeFace(),u=e.getActiveMipmapLevel(),p=e.state;p.setBlending(0),p.buffers.color.setClear(1,1,1,1),p.buffers.depth.setTest(!0),p.setScissorTest(!1);for(let h=0,f=t.length;h<f;h++){const f=t[h],u=f.shadow;if(void 0===u){console.warn("THREE.WebGLShadowMap:",f,"has no shadow.");continue}if(!1===u.autoUpdate&&!1===u.needsUpdate)continue;o.copy(u.mapSize);const g=u.getFrameExtents();if(o.multiply(g),r.copy(u.mapSize),(o.x>n||o.y>n)&&(o.x>n&&(r.x=Math.floor(n/g.x),o.x=r.x*g.x,u.mapSize.x=r.x),o.y>n&&(r.y=Math.floor(n/g.y),o.y=r.y*g.y,u.mapSize.y=r.y)),null===u.map&&!u.isPointLightShadow&&3===this.type){const e={minFilter:s,magFilter:s,format:m};u.map=new W(o.x,o.y,e),u.map.texture.name=f.name+".shadowMap",u.mapPass=new W(o.x,o.y,e),u.camera.updateProjectionMatrix()}if(null===u.map){const e={minFilter:a,magFilter:a,format:m};u.map=new W(o.x,o.y,e),u.map.texture.name=f.name+".shadowMap",u.camera.updateProjectionMatrix()}e.setRenderTarget(u.map),e.clear();const E=u.getViewportCount();for(let e=0;e<E;e++){const t=u.getViewport(e);c.set(r.x*t.x,r.y*t.y,r.x*t.z,r.y*t.w),p.viewport(c),u.updateMatrices(f,e),i=u.getFrustum(),O(l,d,u.camera,f,this.type)}u.isPointLightShadow||3!==this.type||v(u,d),u.needsUpdate=!1}T.needsUpdate=!1,e.setRenderTarget(h,f,u)}}function Ao(e,t,i){const o=i.isWebGL2,r=new function(){let t=!1;const n=new G;let i=null;const o=new G(0,0,0,0);return{setMask:function(n){i===n||t||(e.colorMask(n,n,n,n),i=n)},setLocked:function(e){t=e},setClear:function(t,i,r,a,s){!0===s&&(t*=a,i*=a,r*=a),n.set(t,i,r,a),!1===o.equals(n)&&(e.clearColor(t,i,r,a),o.copy(n))},reset:function(){t=!1,i=null,o.set(-1,0,0,0)}}},a=new function(){let t=!1,n=null,i=null,o=null;return{setTest:function(e){e?D(2929):P(2929)},setMask:function(i){n===i||t||(e.depthMask(i),n=i)},setFunc:function(t){if(i!==t){if(t)switch(t){case 0:e.depthFunc(512);break;case 1:e.depthFunc(519);break;case 2:e.depthFunc(513);break;case 3:e.depthFunc(515);break;case 4:e.depthFunc(514);break;case 5:e.depthFunc(518);break;case 6:e.depthFunc(516);break;case 7:e.depthFunc(517);break;default:e.depthFunc(515)}else e.depthFunc(515);i=t}},setLocked:function(e){t=e},setClear:function(t){o!==t&&(e.clearDepth(t),o=t)},reset:function(){t=!1,n=null,i=null,o=null}}},s=new function(){let t=!1,n=null,i=null,o=null,r=null,a=null,s=null,c=null,l=null;return{setTest:function(e){t||(e?D(2960):P(2960))},setMask:function(i){n===i||t||(e.stencilMask(i),n=i)},setFunc:function(t,n,a){i===t&&o===n&&r===a||(e.stencilFunc(t,n,a),i=t,o=n,r=a)},setOp:function(t,n,i){a===t&&s===n&&c===i||(e.stencilOp(t,n,i),a=t,s=n,c=i)},setLocked:function(e){t=e},setClear:function(t){l!==t&&(e.clearStencil(t),l=t)},reset:function(){t=!1,n=null,i=null,o=null,r=null,a=null,s=null,c=null,l=null}}};let c={},l=null,d=null,h=null,f=null,u=null,p=null,m=null,g=null,E=null,T=!1,v=null,A=null,R=null,I=null,O=null;const S=e.getParameter(35661);let N=!1,b=0;const y=e.getParameter(7938);-1!==y.indexOf("WebGL")?(b=parseFloat(/^WebGL (\d)/.exec(y)[1]),N=b>=1):-1!==y.indexOf("OpenGL ES")&&(b=parseFloat(/^OpenGL ES (\d)/.exec(y)[1]),N=b>=2);let x=null,L={};const _=new G,w=new G;function C(t,n,i){const o=new Uint8Array(4),r=e.createTexture();e.bindTexture(t,r),e.texParameteri(t,10241,9728),e.texParameteri(t,10240,9728);for(let t=0;t<i;t++)e.texImage2D(n+t,0,6408,1,1,0,6408,5121,o);return r}const M={};function D(t){!0!==c[t]&&(e.enable(t),c[t]=!0)}function P(t){!1!==c[t]&&(e.disable(t),c[t]=!1)}M[3553]=C(3553,3553,1),M[34067]=C(34067,34069,6),r.setClear(0,0,0,1),a.setClear(1),s.setClear(0),D(2929),a.setFunc(3),B(!1),z(1),D(2884),U(0);const F={[n]:32774,101:32778,102:32779};if(o)F[103]=32775,F[104]=32776;else{const e=t.get("EXT_blend_minmax");null!==e&&(F[103]=e.MIN_EXT,F[104]=e.MAX_EXT)}const H={200:0,201:1,202:768,204:770,210:776,208:774,206:772,203:769,205:771,209:775,207:773};function U(t,i,o,r,a,s,c,l){if(0!==t){if(d||(D(3042),d=!0),5===t)a=a||i,s=s||o,c=c||r,i===f&&a===m||(e.blendEquationSeparate(F[i],F[a]),f=i,m=a),o===u&&r===p&&s===g&&c===E||(e.blendFuncSeparate(H[o],H[r],H[s],H[c]),u=o,p=r,g=s,E=c),h=t,T=null;else if(t!==h||l!==T){if(f===n&&m===n||(e.blendEquation(32774),f=n,m=n),l)switch(t){case 1:e.blendFuncSeparate(1,771,1,771);break;case 2:e.blendFunc(1,1);break;case 3:e.blendFuncSeparate(0,0,769,771);break;case 4:e.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",t)}else switch(t){case 1:e.blendFuncSeparate(770,771,1,771);break;case 2:e.blendFunc(770,1);break;case 3:e.blendFunc(0,769);break;case 4:e.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",t)}u=null,p=null,g=null,E=null,h=t,T=l}}else d&&(P(3042),d=!1)}function B(t){v!==t&&(t?e.frontFace(2304):e.frontFace(2305),v=t)}function z(t){0!==t?(D(2884),t!==A&&(1===t?e.cullFace(1029):2===t?e.cullFace(1028):e.cullFace(1032))):P(2884),A=t}function W(t,n,i){t?(D(32823),I===n&&O===i||(e.polygonOffset(n,i),I=n,O=i)):P(32823)}function Y(t){void 0===t&&(t=33984+S-1),x!==t&&(e.activeTexture(t),x=t)}return{buffers:{color:r,depth:a,stencil:s},enable:D,disable:P,useProgram:function(t){return l!==t&&(e.useProgram(t),l=t,!0)},setBlending:U,setMaterial:function(e,t){2===e.side?P(2884):D(2884);let n=1===e.side;t&&(n=!n),B(n),1===e.blending&&!1===e.transparent?U(0):U(e.blending,e.blendEquation,e.blendSrc,e.blendDst,e.blendEquationAlpha,e.blendSrcAlpha,e.blendDstAlpha,e.premultipliedAlpha),a.setFunc(e.depthFunc),a.setTest(e.depthTest),a.setMask(e.depthWrite),r.setMask(e.colorWrite);const i=e.stencilWrite;s.setTest(i),i&&(s.setMask(e.stencilWriteMask),s.setFunc(e.stencilFunc,e.stencilRef,e.stencilFuncMask),s.setOp(e.stencilFail,e.stencilZFail,e.stencilZPass)),W(e.polygonOffset,e.polygonOffsetFactor,e.polygonOffsetUnits)},setFlipSided:B,setCullFace:z,setLineWidth:function(t){t!==R&&(N&&e.lineWidth(t),R=t)},setPolygonOffset:W,setScissorTest:function(e){e?D(3089):P(3089)},activeTexture:Y,bindTexture:function(t,n){null===x&&Y();let i=L[x];void 0===i&&(i={type:void 0,texture:void 0},L[x]=i),i.type===t&&i.texture===n||(e.bindTexture(t,n||M[t]),i.type=t,i.texture=n)},unbindTexture:function(){const t=L[x];void 0!==t&&void 0!==t.type&&(e.bindTexture(t.type,null),t.type=void 0,t.texture=void 0)},compressedTexImage2D:function(){try{e.compressedTexImage2D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texImage2D:function(){try{e.texImage2D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texImage3D:function(){try{e.texImage3D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},scissor:function(t){!1===_.equals(t)&&(e.scissor(t.x,t.y,t.z,t.w),_.copy(t))},viewport:function(t){!1===w.equals(t)&&(e.viewport(t.x,t.y,t.z,t.w),w.copy(t))},reset:function(){c={},x=null,L={},l=null,d=null,h=null,f=null,u=null,p=null,m=null,g=null,E=null,T=!1,v=null,A=null,R=null,I=null,O=null,r.reset(),a.reset(),s.reset()}}}function Ro(e,t,n,T,v,A,R){const I=v.isWebGL2,O=v.maxTextures,S=v.maxCubemapSize,N=v.maxTextureSize,b=v.maxSamples,y=new WeakMap;let x,L=!1;try{L="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(e){}function _(e,t){return L?new OffscreenCanvas(e,t):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function w(e,t,n,i){let o=1;if((e.width>i||e.height>i)&&(o=i/Math.max(e.width,e.height)),o<1||!0===t){if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap){const i=t?M.floorPowerOfTwo:Math.floor,r=i(o*e.width),a=i(o*e.height);void 0===x&&(x=_(r,a));const s=n?_(r,a):x;return s.width=r,s.height=a,s.getContext("2d").drawImage(e,0,0,r,a),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+e.width+"x"+e.height+") to ("+r+"x"+a+")."),s}return"data"in e&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+e.width+"x"+e.height+")."),e}return e}function C(e){return M.isPowerOfTwo(e.width)&&M.isPowerOfTwo(e.height)}function D(e,t){return e.generateMipmaps&&t&&e.minFilter!==a&&e.minFilter!==s}function P(t,n,i,o){e.generateMipmap(t),T.get(n).__maxMipLevel=Math.log(Math.max(i,o))*Math.LOG2E}function F(n,i,o){if(!1===I)return i;if(null!==n){if(void 0!==e[n])return e[n];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+n+"'")}let r=i;return 6403===i&&(5126===o&&(r=33326),5131===o&&(r=33325),5121===o&&(r=33321)),6407===i&&(5126===o&&(r=34837),5131===o&&(r=34843),5121===o&&(r=32849)),6408===i&&(5126===o&&(r=34836),5131===o&&(r=34842),5121===o&&(r=32856)),33325!==r&&33326!==r&&34842!==r&&34836!==r||t.get("EXT_color_buffer_float"),r}function H(e){return e===a||1004===e||1005===e?9728:9729}function U(t){const n=t.target;n.removeEventListener("dispose",U),function(t){const n=T.get(t);void 0!==n.__webglInit&&(e.deleteTexture(n.__webglTexture),T.remove(t))}(n),n.isVideoTexture&&y.delete(n),R.memory.textures--}function B(t){const n=t.target;n.removeEventListener("dispose",B),function(t){const n=T.get(t),i=T.get(t.texture);if(t){if(void 0!==i.__webglTexture&&e.deleteTexture(i.__webglTexture),t.depthTexture&&t.depthTexture.dispose(),t.isWebGLCubeRenderTarget)for(let t=0;t<6;t++)e.deleteFramebuffer(n.__webglFramebuffer[t]),n.__webglDepthbuffer&&e.deleteRenderbuffer(n.__webglDepthbuffer[t]);else e.deleteFramebuffer(n.__webglFramebuffer),n.__webglDepthbuffer&&e.deleteRenderbuffer(n.__webglDepthbuffer),n.__webglMultisampledFramebuffer&&e.deleteFramebuffer(n.__webglMultisampledFramebuffer),n.__webglColorRenderbuffer&&e.deleteRenderbuffer(n.__webglColorRenderbuffer),n.__webglDepthRenderbuffer&&e.deleteRenderbuffer(n.__webglDepthRenderbuffer);T.remove(t.texture),T.remove(t)}}(n),R.memory.textures--}let z=0;function G(e,t){const i=T.get(e);if(e.isVideoTexture&&function(e){const t=R.render.frame;y.get(e)!==t&&(y.set(e,t),e.update())}(e),e.version>0&&i.__version!==e.version){const n=e.image;if(void 0===n)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else{if(!1!==n.complete)return void X(i,e,t);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}n.activeTexture(33984+t),n.bindTexture(3553,i.__webglTexture)}function W(t,i){const o=T.get(t);t.version>0&&o.__version!==t.version?function(t,i,o){if(6!==i.image.length)return;j(t,i),n.activeTexture(33984+o),n.bindTexture(34067,t.__webglTexture),e.pixelStorei(37440,i.flipY),e.pixelStorei(37441,i.premultiplyAlpha),e.pixelStorei(3317,i.unpackAlignment);const r=i&&(i.isCompressedTexture||i.image[0].isCompressedTexture),a=i.image[0]&&i.image[0].isDataTexture,s=[];for(let e=0;e<6;e++)s[e]=r||a?a?i.image[e].image:i.image[e]:w(i.image[e],!1,!0,S);const c=s[0],l=C(c)||I,d=A.convert(i.format),h=A.convert(i.type),f=F(i.internalFormat,d,h);let u;if(k(34067,i,l),r){for(let e=0;e<6;e++){u=s[e].mipmaps;for(let t=0;t<u.length;t++){const o=u[t];i.format!==m&&i.format!==p?null!==d?n.compressedTexImage2D(34069+e,t,f,o.width,o.height,0,o.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):n.texImage2D(34069+e,t,f,o.width,o.height,0,d,h,o.data)}}t.__maxMipLevel=u.length-1}else{u=i.mipmaps;for(let e=0;e<6;e++)if(a){n.texImage2D(34069+e,0,f,s[e].width,s[e].height,0,d,h,s[e].data);for(let t=0;t<u.length;t++){const i=u[t].image[e].image;n.texImage2D(34069+e,t+1,f,i.width,i.height,0,d,h,i.data)}}else{n.texImage2D(34069+e,0,f,d,h,s[e]);for(let t=0;t<u.length;t++){const i=u[t];n.texImage2D(34069+e,t+1,f,d,h,i.image[e])}}t.__maxMipLevel=u.length}D(i,l)&&P(34067,i,c.width,c.height),t.__version=i.version,i.onUpdate&&i.onUpdate(i)}(o,t,i):(n.activeTexture(33984+i),n.bindTexture(34067,o.__webglTexture))}const Y={[i]:10497,[o]:33071,[r]:33648},V={[a]:9728,1004:9984,1005:9986,[s]:9729,1007:9985,[c]:9987};function k(n,i,r){r?(e.texParameteri(n,10242,Y[i.wrapS]),e.texParameteri(n,10243,Y[i.wrapT]),32879!==n&&35866!==n||e.texParameteri(n,32882,Y[i.wrapR]),e.texParameteri(n,10240,V[i.magFilter]),e.texParameteri(n,10241,V[i.minFilter])):(e.texParameteri(n,10242,33071),e.texParameteri(n,10243,33071),32879!==n&&35866!==n||e.texParameteri(n,32882,33071),i.wrapS===o&&i.wrapT===o||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),e.texParameteri(n,10240,H(i.magFilter)),e.texParameteri(n,10241,H(i.minFilter)),i.minFilter!==a&&i.minFilter!==s&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));const c=t.get("EXT_texture_filter_anisotropic");if(c){if(i.type===h&&null===t.get("OES_texture_float_linear"))return;if(i.type===f&&null===(I||t.get("OES_texture_half_float_linear")))return;(i.anisotropy>1||T.get(i).__currentAnisotropy)&&(e.texParameterf(n,c.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(i.anisotropy,v.getMaxAnisotropy())),T.get(i).__currentAnisotropy=i.anisotropy)}}function j(t,n){void 0===t.__webglInit&&(t.__webglInit=!0,n.addEventListener("dispose",U),t.__webglTexture=e.createTexture(),R.memory.textures++)}function X(t,i,r){let c=3553;i.isDataTexture2DArray&&(c=35866),i.isDataTexture3D&&(c=32879),j(t,i),n.activeTexture(33984+r),n.bindTexture(c,t.__webglTexture),e.pixelStorei(37440,i.flipY),e.pixelStorei(37441,i.premultiplyAlpha),e.pixelStorei(3317,i.unpackAlignment);const f=function(e){return!I&&(e.wrapS!==o||e.wrapT!==o||e.minFilter!==a&&e.minFilter!==s)}(i)&&!1===C(i.image),T=w(i.image,f,!1,N),v=C(T)||I,R=A.convert(i.format);let O,S=A.convert(i.type),b=F(i.internalFormat,R,S);k(c,i,v);const y=i.mipmaps;if(i.isDepthTexture)b=6402,I?b=i.type===h?36012:i.type===d?33190:i.type===u?35056:33189:i.type===h&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),i.format===g&&6402===b&&i.type!==l&&i.type!==d&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),i.type=l,S=A.convert(i.type)),i.format===E&&6402===b&&(b=34041,i.type!==u&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),i.type=u,S=A.convert(i.type))),n.texImage2D(3553,0,b,T.width,T.height,0,R,S,null);else if(i.isDataTexture)if(y.length>0&&v){for(let e=0,t=y.length;e<t;e++)O=y[e],n.texImage2D(3553,e,b,O.width,O.height,0,R,S,O.data);i.generateMipmaps=!1,t.__maxMipLevel=y.length-1}else n.texImage2D(3553,0,b,T.width,T.height,0,R,S,T.data),t.__maxMipLevel=0;else if(i.isCompressedTexture){for(let e=0,t=y.length;e<t;e++)O=y[e],i.format!==m&&i.format!==p?null!==R?n.compressedTexImage2D(3553,e,b,O.width,O.height,0,O.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):n.texImage2D(3553,e,b,O.width,O.height,0,R,S,O.data);t.__maxMipLevel=y.length-1}else if(i.isDataTexture2DArray)n.texImage3D(35866,0,b,T.width,T.height,T.depth,0,R,S,T.data),t.__maxMipLevel=0;else if(i.isDataTexture3D)n.texImage3D(32879,0,b,T.width,T.height,T.depth,0,R,S,T.data),t.__maxMipLevel=0;else if(y.length>0&&v){for(let e=0,t=y.length;e<t;e++)O=y[e],n.texImage2D(3553,e,b,R,S,O);i.generateMipmaps=!1,t.__maxMipLevel=y.length-1}else n.texImage2D(3553,0,b,R,S,T),t.__maxMipLevel=0;D(i,v)&&P(c,i,T.width,T.height),t.__version=i.version,i.onUpdate&&i.onUpdate(i)}function q(t,i,o,r){const a=A.convert(i.texture.format),s=A.convert(i.texture.type),c=F(i.texture.internalFormat,a,s);n.texImage2D(r,0,c,i.width,i.height,0,a,s,null),e.bindFramebuffer(36160,t),e.framebufferTexture2D(36160,o,r,T.get(i.texture).__webglTexture,0),e.bindFramebuffer(36160,null)}function K(t,n,i){if(e.bindRenderbuffer(36161,t),n.depthBuffer&&!n.stencilBuffer){let o=33189;if(i){const t=n.depthTexture;t&&t.isDepthTexture&&(t.type===h?o=36012:t.type===d&&(o=33190));const i=Z(n);e.renderbufferStorageMultisample(36161,i,o,n.width,n.height)}else e.renderbufferStorage(36161,o,n.width,n.height);e.framebufferRenderbuffer(36160,36096,36161,t)}else if(n.depthBuffer&&n.stencilBuffer){if(i){const t=Z(n);e.renderbufferStorageMultisample(36161,t,35056,n.width,n.height)}else e.renderbufferStorage(36161,34041,n.width,n.height);e.framebufferRenderbuffer(36160,33306,36161,t)}else{const t=A.convert(n.texture.format),o=A.convert(n.texture.type),r=F(n.texture.internalFormat,t,o);if(i){const t=Z(n);e.renderbufferStorageMultisample(36161,t,r,n.width,n.height)}else e.renderbufferStorage(36161,r,n.width,n.height)}e.bindRenderbuffer(36161,null)}function Z(e){return I&&e.isWebGLMultisampleRenderTarget?Math.min(b,e.samples):0}let J=!1,Q=!1;this.allocateTextureUnit=function(){const e=z;return e>=O&&console.warn("THREE.WebGLTextures: Trying to use "+e+" texture units while this GPU supports only "+O),z+=1,e},this.resetTextureUnits=function(){z=0},this.setTexture2D=G,this.setTexture2DArray=function(e,t){const i=T.get(e);e.version>0&&i.__version!==e.version?X(i,e,t):(n.activeTexture(33984+t),n.bindTexture(35866,i.__webglTexture))},this.setTexture3D=function(e,t){const i=T.get(e);e.version>0&&i.__version!==e.version?X(i,e,t):(n.activeTexture(33984+t),n.bindTexture(32879,i.__webglTexture))},this.setTextureCube=W,this.setupRenderTarget=function(t){const i=T.get(t),o=T.get(t.texture);t.addEventListener("dispose",B),o.__webglTexture=e.createTexture(),R.memory.textures++;const r=!0===t.isWebGLCubeRenderTarget,a=!0===t.isWebGLMultisampleRenderTarget,s=C(t)||I;if(!I||t.texture.format!==p||t.texture.type!==h&&t.texture.type!==f||(t.texture.format=m,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),r){i.__webglFramebuffer=[];for(let t=0;t<6;t++)i.__webglFramebuffer[t]=e.createFramebuffer()}else if(i.__webglFramebuffer=e.createFramebuffer(),a)if(I){i.__webglMultisampledFramebuffer=e.createFramebuffer(),i.__webglColorRenderbuffer=e.createRenderbuffer(),e.bindRenderbuffer(36161,i.__webglColorRenderbuffer);const n=A.convert(t.texture.format),o=A.convert(t.texture.type),r=F(t.texture.internalFormat,n,o),a=Z(t);e.renderbufferStorageMultisample(36161,a,r,t.width,t.height),e.bindFramebuffer(36160,i.__webglMultisampledFramebuffer),e.framebufferRenderbuffer(36160,36064,36161,i.__webglColorRenderbuffer),e.bindRenderbuffer(36161,null),t.depthBuffer&&(i.__webglDepthRenderbuffer=e.createRenderbuffer(),K(i.__webglDepthRenderbuffer,t,!0)),e.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(r){n.bindTexture(34067,o.__webglTexture),k(34067,t.texture,s);for(let e=0;e<6;e++)q(i.__webglFramebuffer[e],t,36064,34069+e);D(t.texture,s)&&P(34067,t.texture,t.width,t.height),n.bindTexture(34067,null)}else n.bindTexture(3553,o.__webglTexture),k(3553,t.texture,s),q(i.__webglFramebuffer,t,36064,3553),D(t.texture,s)&&P(3553,t.texture,t.width,t.height),n.bindTexture(3553,null);t.depthBuffer&&function(t){const n=T.get(t),i=!0===t.isWebGLCubeRenderTarget;if(t.depthTexture){if(i)throw new Error("target.depthTexture not supported in Cube render targets");!function(t,n){if(n&&n.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(e.bindFramebuffer(36160,t),!n.depthTexture||!n.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");T.get(n.depthTexture).__webglTexture&&n.depthTexture.image.width===n.width&&n.depthTexture.image.height===n.height||(n.depthTexture.image.width=n.width,n.depthTexture.image.height=n.height,n.depthTexture.needsUpdate=!0),G(n.depthTexture,0);const i=T.get(n.depthTexture).__webglTexture;if(n.depthTexture.format===g)e.framebufferTexture2D(36160,36096,3553,i,0);else{if(n.depthTexture.format!==E)throw new Error("Unknown depthTexture format");e.framebufferTexture2D(36160,33306,3553,i,0)}}(n.__webglFramebuffer,t)}else if(i){n.__webglDepthbuffer=[];for(let i=0;i<6;i++)e.bindFramebuffer(36160,n.__webglFramebuffer[i]),n.__webglDepthbuffer[i]=e.createRenderbuffer(),K(n.__webglDepthbuffer[i],t,!1)}else e.bindFramebuffer(36160,n.__webglFramebuffer),n.__webglDepthbuffer=e.createRenderbuffer(),K(n.__webglDepthbuffer,t,!1);e.bindFramebuffer(36160,null)}(t)},this.updateRenderTargetMipmap=function(e){const t=e.texture;if(D(t,C(e)||I)){const i=e.isWebGLCubeRenderTarget?34067:3553,o=T.get(t).__webglTexture;n.bindTexture(i,o),P(i,t,e.width,e.height),n.bindTexture(i,null)}},this.updateMultisampleRenderTarget=function(t){if(t.isWebGLMultisampleRenderTarget)if(I){const n=T.get(t);e.bindFramebuffer(36008,n.__webglMultisampledFramebuffer),e.bindFramebuffer(36009,n.__webglFramebuffer);const i=t.width,o=t.height;let r=16384;t.depthBuffer&&(r|=256),t.stencilBuffer&&(r|=1024),e.blitFramebuffer(0,0,i,o,0,0,i,o,r,9728),e.bindFramebuffer(36160,n.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")},this.safeSetTexture2D=function(e,t){e&&e.isWebGLRenderTarget&&(!1===J&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),J=!0),e=e.texture),G(e,t)},this.safeSetTextureCube=function(e,t){e&&e.isWebGLCubeRenderTarget&&(!1===Q&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),Q=!0),e=e.texture),W(e,t)}}function Io(e,t,n){const i=n.isWebGL2;return{convert:function(e){let n;if(1009===e)return 5121;if(1017===e)return 32819;if(1018===e)return 32820;if(1019===e)return 33635;if(1010===e)return 5120;if(1011===e)return 5122;if(e===l)return 5123;if(1013===e)return 5124;if(e===d)return 5125;if(e===h)return 5126;if(e===f)return i?5131:(n=t.get("OES_texture_half_float"),null!==n?n.HALF_FLOAT_OES:null);if(1021===e)return 6406;if(e===p)return 6407;if(e===m)return 6408;if(1024===e)return 6409;if(1025===e)return 6410;if(e===g)return 6402;if(e===E)return 34041;if(1028===e)return 6403;if(1029===e)return 36244;if(1030===e)return 33319;if(1031===e)return 33320;if(1032===e)return 36248;if(1033===e)return 36249;if(33776===e||33777===e||33778===e||33779===e){if(n=t.get("WEBGL_compressed_texture_s3tc"),null===n)return null;if(33776===e)return n.COMPRESSED_RGB_S3TC_DXT1_EXT;if(33777===e)return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(33778===e)return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(33779===e)return n.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(35840===e||35841===e||35842===e||35843===e){if(n=t.get("WEBGL_compressed_texture_pvrtc"),null===n)return null;if(35840===e)return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(35841===e)return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(35842===e)return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(35843===e)return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(36196===e)return n=t.get("WEBGL_compressed_texture_etc1"),null!==n?n.COMPRESSED_RGB_ETC1_WEBGL:null;if((37492===e||37496===e)&&(n=t.get("WEBGL_compressed_texture_etc"),null!==n)){if(37492===e)return n.COMPRESSED_RGB8_ETC2;if(37496===e)return n.COMPRESSED_RGBA8_ETC2_EAC}return 37808===e||37809===e||37810===e||37811===e||37812===e||37813===e||37814===e||37815===e||37816===e||37817===e||37818===e||37819===e||37820===e||37821===e||37840===e||37841===e||37842===e||37843===e||37844===e||37845===e||37846===e||37847===e||37848===e||37849===e||37850===e||37851===e||37852===e||37853===e?(n=t.get("WEBGL_compressed_texture_astc"),null!==n?e:null):36492===e?(n=t.get("EXT_texture_compression_bptc"),null!==n?e:null):e===u?i?34042:(n=t.get("WEBGL_depth_texture"),null!==n?n.UNSIGNED_INT_24_8_WEBGL:null):void 0}}}function Oo(e=[]){fn.call(this),this.cameras=e}function So(){Ye.call(this),this.type="Group"}function No(){this._targetRay=null,this._grip=null,this._hand=null}function bo(e,t){const n=this;let i=null,o=1,r=null,a="local-floor",s=null;const c=[],l=new Map,d=new fn;d.layers.enable(1),d.viewport=new G;const h=new fn;h.layers.enable(2),h.viewport=new G;const f=[d,h],u=new Oo;u.layers.enable(1),u.layers.enable(2);let p=null,m=null;function g(e){const t=l.get(e.inputSource);t&&t.dispatchEvent({type:e.type,data:e.inputSource})}function E(){l.forEach((function(e,t){e.disconnect(t)})),l.clear(),p=null,m=null,e.setFramebuffer(null),e.setRenderTarget(e.getRenderTarget()),O.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}function T(e){const t=i.inputSources;for(let e=0;e<c.length;e++)l.set(t[e],c[e]);for(let t=0;t<e.removed.length;t++){const n=e.removed[t],i=l.get(n);i&&(i.dispatchEvent({type:"disconnected",data:n}),l.delete(n))}for(let t=0;t<e.added.length;t++){const n=e.added[t],i=l.get(n);i&&i.dispatchEvent({type:"connected",data:n})}}this.enabled=!1,this.isPresenting=!1,this.getController=function(e){let t=c[e];return void 0===t&&(t=new No,c[e]=t),t.getTargetRaySpace()},this.getControllerGrip=function(e){let t=c[e];return void 0===t&&(t=new No,c[e]=t),t.getGripSpace()},this.getHand=function(e){let t=c[e];return void 0===t&&(t=new No,c[e]=t),t.getHandSpace()},this.setFramebufferScaleFactor=function(e){o=e,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(e){a=e,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return r},this.getSession=function(){return i},this.setSession=async function(e){if(i=e,null!==i){i.addEventListener("select",g),i.addEventListener("selectstart",g),i.addEventListener("selectend",g),i.addEventListener("squeeze",g),i.addEventListener("squeezestart",g),i.addEventListener("squeezeend",g),i.addEventListener("end",E),i.addEventListener("inputsourceschange",T);const e=t.getContextAttributes();!0!==e.xrCompatible&&await t.makeXRCompatible();const s={antialias:e.antialias,alpha:e.alpha,depth:e.depth,stencil:e.stencil,framebufferScaleFactor:o},c=new XRWebGLLayer(i,t,s);i.updateRenderState({baseLayer:c}),r=await i.requestReferenceSpace(a),O.setContext(i),O.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};const v=new V,A=new V;function R(e,t){null===t?e.matrixWorld.copy(e.matrix):e.matrixWorld.multiplyMatrices(t.matrixWorld,e.matrix),e.matrixWorldInverse.copy(e.matrixWorld).invert()}this.getCamera=function(e){u.near=h.near=d.near=e.near,u.far=h.far=d.far=e.far,p===u.near&&m===u.far||(i.updateRenderState({depthNear:u.near,depthFar:u.far}),p=u.near,m=u.far);const t=e.parent,n=u.cameras;R(u,t);for(let e=0;e<n.length;e++)R(n[e],t);e.matrixWorld.copy(u.matrixWorld),e.matrix.copy(u.matrix),e.matrix.decompose(e.position,e.quaternion,e.scale);const o=e.children;for(let e=0,t=o.length;e<t;e++)o[e].updateMatrixWorld(!0);return 2===n.length?function(e,t,n){v.setFromMatrixPosition(t.matrixWorld),A.setFromMatrixPosition(n.matrixWorld);const i=v.distanceTo(A),o=t.projectionMatrix.elements,r=n.projectionMatrix.elements,a=o[14]/(o[10]-1),s=o[14]/(o[10]+1),c=(o[9]+1)/o[5],l=(o[9]-1)/o[5],d=(o[8]-1)/o[0],h=(r[8]+1)/r[0],f=a*d,u=a*h,p=i/(-d+h),m=p*-d;t.matrixWorld.decompose(e.position,e.quaternion,e.scale),e.translateX(m),e.translateZ(p),e.matrixWorld.compose(e.position,e.quaternion,e.scale),e.matrixWorldInverse.copy(e.matrixWorld).invert();const g=a+p,E=s+p,T=f-m,R=u+(i-m),I=c*s/E*g,O=l*s/E*g;e.projectionMatrix.makePerspective(T,R,I,O,g,E)}(u,d,h):u.projectionMatrix.copy(d.projectionMatrix),u};let I=null;const O=new Rn;O.setAnimationLoop((function(t,n){if(s=n.getViewerPose(r),null!==s){const t=s.views,n=i.renderState.baseLayer;e.setFramebuffer(n.framebuffer);let o=!1;t.length!==u.cameras.length&&(u.cameras.length=0,o=!0);for(let e=0;e<t.length;e++){const i=t[e],r=n.getViewport(i),a=f[e];a.matrix.fromArray(i.transform.matrix),a.projectionMatrix.fromArray(i.projectionMatrix),a.viewport.set(r.x,r.y,r.width,r.height),0===e&&u.matrix.copy(a.matrix),!0===o&&u.cameras.push(a)}}const o=i.inputSources;for(let e=0;e<c.length;e++){const t=c[e],i=o[e];t.update(i,n,r)}I&&I(t,n)})),this.setAnimationLoop=function(e){I=e},this.dispose=function(){}}function yo(e){function t(t,n){t.opacity.value=n.opacity,n.color&&t.diffuse.value.copy(n.color),n.emissive&&t.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),n.map&&(t.map.value=n.map),n.alphaMap&&(t.alphaMap.value=n.alphaMap),n.specularMap&&(t.specularMap.value=n.specularMap);const i=e.get(n).envMap;if(i){t.envMap.value=i,t.flipEnvMap.value=i.isCubeTexture&&i._needsFlipEnvMap?-1:1,t.reflectivity.value=n.reflectivity,t.refractionRatio.value=n.refractionRatio;const o=e.get(i).__maxMipLevel;void 0!==o&&(t.maxMipLevel.value=o)}let o,r;n.lightMap&&(t.lightMap.value=n.lightMap,t.lightMapIntensity.value=n.lightMapIntensity),n.aoMap&&(t.aoMap.value=n.aoMap,t.aoMapIntensity.value=n.aoMapIntensity),n.map?o=n.map:n.specularMap?o=n.specularMap:n.displacementMap?o=n.displacementMap:n.normalMap?o=n.normalMap:n.bumpMap?o=n.bumpMap:n.roughnessMap?o=n.roughnessMap:n.metalnessMap?o=n.metalnessMap:n.alphaMap?o=n.alphaMap:n.emissiveMap?o=n.emissiveMap:n.clearcoatMap?o=n.clearcoatMap:n.clearcoatNormalMap?o=n.clearcoatNormalMap:n.clearcoatRoughnessMap&&(o=n.clearcoatRoughnessMap),void 0!==o&&(o.isWebGLRenderTarget&&(o=o.texture),!0===o.matrixAutoUpdate&&o.updateMatrix(),t.uvTransform.value.copy(o.matrix)),n.aoMap?r=n.aoMap:n.lightMap&&(r=n.lightMap),void 0!==r&&(r.isWebGLRenderTarget&&(r=r.texture),!0===r.matrixAutoUpdate&&r.updateMatrix(),t.uv2Transform.value.copy(r.matrix))}function n(t,n){t.roughness.value=n.roughness,t.metalness.value=n.metalness,n.roughnessMap&&(t.roughnessMap.value=n.roughnessMap),n.metalnessMap&&(t.metalnessMap.value=n.metalnessMap),n.emissiveMap&&(t.emissiveMap.value=n.emissiveMap),n.bumpMap&&(t.bumpMap.value=n.bumpMap,t.bumpScale.value=n.bumpScale,1===n.side&&(t.bumpScale.value*=-1)),n.normalMap&&(t.normalMap.value=n.normalMap,t.normalScale.value.copy(n.normalScale),1===n.side&&t.normalScale.value.negate()),n.displacementMap&&(t.displacementMap.value=n.displacementMap,t.displacementScale.value=n.displacementScale,t.displacementBias.value=n.displacementBias),e.get(n).envMap&&(t.envMapIntensity.value=n.envMapIntensity)}return{refreshFogUniforms:function(e,t){e.fogColor.value.copy(t.color),t.isFog?(e.fogNear.value=t.near,e.fogFar.value=t.far):t.isFogExp2&&(e.fogDensity.value=t.density)},refreshMaterialUniforms:function(e,i,o,r){i.isMeshBasicMaterial?t(e,i):i.isMeshLambertMaterial?(t(e,i),function(e,t){t.emissiveMap&&(e.emissiveMap.value=t.emissiveMap)}(e,i)):i.isMeshToonMaterial?(t(e,i),function(e,t){t.gradientMap&&(e.gradientMap.value=t.gradientMap),t.emissiveMap&&(e.emissiveMap.value=t.emissiveMap),t.bumpMap&&(e.bumpMap.value=t.bumpMap,e.bumpScale.value=t.bumpScale,1===t.side&&(e.bumpScale.value*=-1)),t.normalMap&&(e.normalMap.value=t.normalMap,e.normalScale.value.copy(t.normalScale),1===t.side&&e.normalScale.value.negate()),t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias)}(e,i)):i.isMeshPhongMaterial?(t(e,i),function(e,t){e.specular.value.copy(t.specular),e.shininess.value=Math.max(t.shininess,1e-4),t.emissiveMap&&(e.emissiveMap.value=t.emissiveMap),t.bumpMap&&(e.bumpMap.value=t.bumpMap,e.bumpScale.value=t.bumpScale,1===t.side&&(e.bumpScale.value*=-1)),t.normalMap&&(e.normalMap.value=t.normalMap,e.normalScale.value.copy(t.normalScale),1===t.side&&e.normalScale.value.negate()),t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias)}(e,i)):i.isMeshStandardMaterial?(t(e,i),i.isMeshPhysicalMaterial?function(e,t){n(e,t),e.reflectivity.value=t.reflectivity,e.clearcoat.value=t.clearcoat,e.clearcoatRoughness.value=t.clearcoatRoughness,t.sheen&&e.sheen.value.copy(t.sheen),t.clearcoatMap&&(e.clearcoatMap.value=t.clearcoatMap),t.clearcoatRoughnessMap&&(e.clearcoatRoughnessMap.value=t.clearcoatRoughnessMap),t.clearcoatNormalMap&&(e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale),e.clearcoatNormalMap.value=t.clearcoatNormalMap,1===t.side&&e.clearcoatNormalScale.value.negate()),e.transmission.value=t.transmission,t.transmissionMap&&(e.transmissionMap.value=t.transmissionMap)}(e,i):n(e,i)):i.isMeshMatcapMaterial?(t(e,i),function(e,t){t.matcap&&(e.matcap.value=t.matcap),t.bumpMap&&(e.bumpMap.value=t.bumpMap,e.bumpScale.value=t.bumpScale,1===t.side&&(e.bumpScale.value*=-1)),t.normalMap&&(e.normalMap.value=t.normalMap,e.normalScale.value.copy(t.normalScale),1===t.side&&e.normalScale.value.negate()),t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias)}(e,i)):i.isMeshDepthMaterial?(t(e,i),function(e,t){t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias)}(e,i)):i.isMeshDistanceMaterial?(t(e,i),function(e,t){t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias),e.referencePosition.value.copy(t.referencePosition),e.nearDistance.value=t.nearDistance,e.farDistance.value=t.farDistance}(e,i)):i.isMeshNormalMaterial?(t(e,i),function(e,t){t.bumpMap&&(e.bumpMap.value=t.bumpMap,e.bumpScale.value=t.bumpScale,1===t.side&&(e.bumpScale.value*=-1)),t.normalMap&&(e.normalMap.value=t.normalMap,e.normalScale.value.copy(t.normalScale),1===t.side&&e.normalScale.value.negate()),t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias)}(e,i)):i.isLineBasicMaterial?(function(e,t){e.diffuse.value.copy(t.color),e.opacity.value=t.opacity}(e,i),i.isLineDashedMaterial&&function(e,t){e.dashSize.value=t.dashSize,e.totalSize.value=t.dashSize+t.gapSize,e.scale.value=t.scale}(e,i)):i.isPointsMaterial?function(e,t,n,i){let o;e.diffuse.value.copy(t.color),e.opacity.value=t.opacity,e.size.value=t.size*n,e.scale.value=.5*i,t.map&&(e.map.value=t.map),t.alphaMap&&(e.alphaMap.value=t.alphaMap),t.map?o=t.map:t.alphaMap&&(o=t.alphaMap),void 0!==o&&(!0===o.matrixAutoUpdate&&o.updateMatrix(),e.uvTransform.value.copy(o.matrix))}(e,i,o,r):i.isSpriteMaterial?function(e,t){let n;e.diffuse.value.copy(t.color),e.opacity.value=t.opacity,e.rotation.value=t.rotation,t.map&&(e.map.value=t.map),t.alphaMap&&(e.alphaMap.value=t.alphaMap),t.map?n=t.map:t.alphaMap&&(n=t.alphaMap),void 0!==n&&(!0===n.matrixAutoUpdate&&n.updateMatrix(),e.uvTransform.value.copy(n.matrix))}(e,i):i.isShadowMaterial?(e.color.value.copy(i.color),e.opacity.value=i.opacity):i.isShaderMaterial&&(i.uniformsNeedUpdate=!1)}}}function xo(e){const t=void 0!==(e=e||{}).canvas?e.canvas:function(){const e=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return e.style.display="block",e}(),n=void 0!==e.context?e.context:null,i=void 0!==e.alpha&&e.alpha,o=void 0===e.depth||e.depth,r=void 0===e.stencil||e.stencil,a=void 0!==e.antialias&&e.antialias,s=void 0===e.premultipliedAlpha||e.premultipliedAlpha,c=void 0!==e.preserveDrawingBuffer&&e.preserveDrawingBuffer,l=void 0!==e.powerPreference?e.powerPreference:"default",d=void 0!==e.failIfMajorPerformanceCaveat&&e.failIfMajorPerformanceCaveat;let u=null,p=null;const g=[];this.domElement=t,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=S,this.physicallyCorrectLights=!1,this.toneMapping=0,this.toneMappingExposure=1,this.maxMorphTargets=8,this.maxMorphNormals=4;const E=this;let T=!1,v=null,A=0,R=0,I=null,O=null,N=-1,b=null;const y=new G,x=new G;let L=null,_=t.width,w=t.height,C=1,P=null,F=null;const H=new G(0,0,_,w),U=new G(0,0,_,w);let B=!1;const z=new An;let W=!1,Y=!1;const k=new Te,j=new V,X={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function q(){return null===I?C:1}let K,Z,J,Q,$,ee,te,ne,ie,oe,re,ae,se,ce,le,de,he,fe,ue,pe,me,ge=n;function Ee(e,n){for(let i=0;i<e.length;i++){const o=e[i],r=t.getContext(o,n);if(null!==r)return r}return null}try{const e={alpha:i,depth:o,stencil:r,antialias:a,premultipliedAlpha:s,preserveDrawingBuffer:c,powerPreference:l,failIfMajorPerformanceCaveat:d};if(t.addEventListener("webglcontextlost",Ie,!1),t.addEventListener("webglcontextrestored",Oe,!1),null===ge){const t=["webgl2","webgl","experimental-webgl"];if(!0===E.isWebGL1Renderer&&t.shift(),ge=Ee(t,e),null===ge)throw Ee(t)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}void 0===ge.getShaderPrecisionFormat&&(ge.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(e){throw console.error("THREE.WebGLRenderer: "+e.message),e}function ve(){K=new Mn(ge),Z=new _n(ge,K,e),K.init(Z),pe=new Io(ge,K,Z),J=new Ao(ge,K,Z),J.scissor(x.copy(U).multiplyScalar(C).floor()),J.viewport(y.copy(H).multiplyScalar(C).floor()),Q=new Fn(ge),$=new ro,ee=new Ro(ge,K,J,$,Z,pe,Q),te=new Cn(E),ne=new In(ge,Z),me=new xn(ge,K,ne,Z),ie=new Dn(ge,ne,Q,me),oe=new zn(ge,ie,ne,Q),he=new Bn(ge),le=new wn($),re=new oo(E,te,K,Z,me,le),ae=new yo($),se=new lo($),ce=new go(K,Z),de=new yn(E,te,J,oe,s),fe=new Ln(ge,K,Q,Z),ue=new Pn(ge,K,Q,Z),Q.programs=re.programs,E.capabilities=Z,E.extensions=K,E.properties=$,E.renderLists=se,E.state=J,E.info=Q}ve();const Ae=new bo(E,ge);this.xr=Ae;const Re=new vo(E,oe,Z.maxTextureSize);function Ie(e){e.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),T=!0}function Oe(){console.log("THREE.WebGLRenderer: Context Restored."),T=!1,ve()}function Se(e){const t=e.target;t.removeEventListener("dispose",Se),function(e){Ne(e),$.remove(e)}(t)}function Ne(e){const t=$.get(e).program;void 0!==t&&re.releaseProgram(t)}this.shadowMap=Re,this.getContext=function(){return ge},this.getContextAttributes=function(){return ge.getContextAttributes()},this.forceContextLoss=function(){const e=K.get("WEBGL_lose_context");e&&e.loseContext()},this.forceContextRestore=function(){const e=K.get("WEBGL_lose_context");e&&e.restoreContext()},this.getPixelRatio=function(){return C},this.setPixelRatio=function(e){void 0!==e&&(C=e,this.setSize(_,w,!1))},this.getSize=function(e){return void 0===e&&(console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),e=new D),e.set(_,w)},this.setSize=function(e,n,i){Ae.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(_=e,w=n,t.width=Math.floor(e*C),t.height=Math.floor(n*C),!1!==i&&(t.style.width=e+"px",t.style.height=n+"px"),this.setViewport(0,0,e,n))},this.getDrawingBufferSize=function(e){return void 0===e&&(console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),e=new D),e.set(_*C,w*C).floor()},this.setDrawingBufferSize=function(e,n,i){_=e,w=n,C=i,t.width=Math.floor(e*i),t.height=Math.floor(n*i),this.setViewport(0,0,e,n)},this.getCurrentViewport=function(e){return void 0===e&&(console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),e=new G),e.copy(y)},this.getViewport=function(e){return e.copy(H)},this.setViewport=function(e,t,n,i){e.isVector4?H.set(e.x,e.y,e.z,e.w):H.set(e,t,n,i),J.viewport(y.copy(H).multiplyScalar(C).floor())},this.getScissor=function(e){return e.copy(U)},this.setScissor=function(e,t,n,i){e.isVector4?U.set(e.x,e.y,e.z,e.w):U.set(e,t,n,i),J.scissor(x.copy(U).multiplyScalar(C).floor())},this.getScissorTest=function(){return B},this.setScissorTest=function(e){J.setScissorTest(B=e)},this.setOpaqueSort=function(e){P=e},this.setTransparentSort=function(e){F=e},this.getClearColor=function(e){return void 0===e&&(console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"),e=new ht),e.copy(de.getClearColor())},this.setClearColor=function(){de.setClearColor.apply(de,arguments)},this.getClearAlpha=function(){return de.getClearAlpha()},this.setClearAlpha=function(){de.setClearAlpha.apply(de,arguments)},this.clear=function(e,t,n){let i=0;(void 0===e||e)&&(i|=16384),(void 0===t||t)&&(i|=256),(void 0===n||n)&&(i|=1024),ge.clear(i)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",Ie,!1),t.removeEventListener("webglcontextrestored",Oe,!1),se.dispose(),ce.dispose(),$.dispose(),te.dispose(),oe.dispose(),me.dispose(),Ae.dispose(),ye.stop()},this.renderBufferImmediate=function(e,t){me.initAttributes();const n=$.get(e);e.hasPositions&&!n.position&&(n.position=ge.createBuffer()),e.hasNormals&&!n.normal&&(n.normal=ge.createBuffer()),e.hasUvs&&!n.uv&&(n.uv=ge.createBuffer()),e.hasColors&&!n.color&&(n.color=ge.createBuffer());const i=t.getAttributes();e.hasPositions&&(ge.bindBuffer(34962,n.position),ge.bufferData(34962,e.positionArray,35048),me.enableAttribute(i.position),ge.vertexAttribPointer(i.position,3,5126,!1,0,0)),e.hasNormals&&(ge.bindBuffer(34962,n.normal),ge.bufferData(34962,e.normalArray,35048),me.enableAttribute(i.normal),ge.vertexAttribPointer(i.normal,3,5126,!1,0,0)),e.hasUvs&&(ge.bindBuffer(34962,n.uv),ge.bufferData(34962,e.uvArray,35048),me.enableAttribute(i.uv),ge.vertexAttribPointer(i.uv,2,5126,!1,0,0)),e.hasColors&&(ge.bindBuffer(34962,n.color),ge.bufferData(34962,e.colorArray,35048),me.enableAttribute(i.color),ge.vertexAttribPointer(i.color,3,5126,!1,0,0)),me.disableUnusedAttributes(),ge.drawArrays(4,0,e.count),e.count=0},this.renderBufferDirect=function(e,t,n,i,o,r){null===t&&(t=X);const a=o.isMesh&&o.matrixWorld.determinant()<0,s=Ce(e,t,i,o);J.setMaterial(i,a);let c=n.index;const l=n.attributes.position;if(null===c){if(void 0===l||0===l.count)return}else if(0===c.count)return;let d,h=1;!0===i.wireframe&&(c=ie.getWireframeAttribute(n),h=2),(i.morphTargets||i.morphNormals)&&he.update(o,n,i,s),me.setup(o,i,s,n,c);let f=fe;null!==c&&(d=ne.get(c),f=ue,f.setIndex(d));const u=null!==c?c.count:l.count,p=n.drawRange.start*h,m=n.drawRange.count*h,g=null!==r?r.start*h:0,E=null!==r?r.count*h:1/0,T=Math.max(p,g),v=Math.min(u,p+m,g+E)-1,A=Math.max(0,v-T+1);if(0!==A){if(o.isMesh)!0===i.wireframe?(J.setLineWidth(i.wireframeLinewidth*q()),f.setMode(1)):f.setMode(4);else if(o.isLine){let e=i.linewidth;void 0===e&&(e=1),J.setLineWidth(e*q()),o.isLineSegments?f.setMode(1):o.isLineLoop?f.setMode(2):f.setMode(3)}else o.isPoints?f.setMode(0):o.isSprite&&f.setMode(4);if(o.isInstancedMesh)f.renderInstances(T,A,o.count);else if(n.isInstancedBufferGeometry){const e=Math.min(n.instanceCount,n._maxInstanceCount);f.renderInstances(T,A,e)}else f.render(T,A)}},this.compile=function(e,t){p=ce.get(e),p.init(),e.traverseVisible((function(e){e.isLight&&e.layers.test(t.layers)&&(p.pushLight(e),e.castShadow&&p.pushShadow(e))})),p.setupLights();const n=new WeakMap;e.traverse((function(t){const i=t.material;if(i)if(Array.isArray(i))for(let o=0;o<i.length;o++){const r=i[o];!1===n.has(r)&&(we(r,e,t),n.set(r))}else!1===n.has(i)&&(we(i,e,t),n.set(i))}))};let be=null;const ye=new Rn;function xe(e,t,n,i){if(!1===e.visible)return;if(e.layers.test(t.layers))if(e.isGroup)n=e.renderOrder;else if(e.isLOD)!0===e.autoUpdate&&e.update(t);else if(e.isLight)p.pushLight(e),e.castShadow&&p.pushShadow(e);else if(e.isSprite){if(!e.frustumCulled||z.intersectsSprite(e)){i&&j.setFromMatrixPosition(e.matrixWorld).applyMatrix4(k);const t=oe.update(e),o=e.material;o.visible&&u.push(e,t,o,n,j.z,null)}}else if(e.isImmediateRenderObject)i&&j.setFromMatrixPosition(e.matrixWorld).applyMatrix4(k),u.push(e,null,e.material,n,j.z,null);else if((e.isMesh||e.isLine||e.isPoints)&&(e.isSkinnedMesh&&e.skeleton.frame!==Q.render.frame&&(e.skeleton.update(),e.skeleton.frame=Q.render.frame),!e.frustumCulled||z.intersectsObject(e))){i&&j.setFromMatrixPosition(e.matrixWorld).applyMatrix4(k);const t=oe.update(e),o=e.material;if(Array.isArray(o)){const i=t.groups;for(let r=0,a=i.length;r<a;r++){const a=i[r],s=o[a.materialIndex];s&&s.visible&&u.push(e,t,s,n,j.z,a)}}else o.visible&&u.push(e,t,o,n,j.z,null)}const o=e.children;for(let e=0,r=o.length;e<r;e++)xe(o[e],t,n,i)}function Le(e,t,n){const i=!0===t.isScene?t.overrideMaterial:null;for(let o=0,r=e.length;o<r;o++){const r=e[o],a=r.object,s=r.geometry,c=null===i?r.material:i,l=r.group;if(n.isArrayCamera){const e=n.cameras;for(let n=0,i=e.length;n<i;n++){const i=e[n];a.layers.test(i.layers)&&(J.viewport(y.copy(i.viewport)),p.setupLightsView(i),_e(a,t,i,s,c,l))}}else _e(a,t,n,s,c,l)}}function _e(e,t,n,i,o,r){if(e.onBeforeRender(E,t,n,i,o,r),e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse,e.matrixWorld),e.normalMatrix.getNormalMatrix(e.modelViewMatrix),e.isImmediateRenderObject){const i=Ce(n,t,o,e);J.setMaterial(o),me.reset(),function(e,t){e.render((function(e){E.renderBufferImmediate(e,t)}))}(e,i)}else E.renderBufferDirect(n,t,i,o,e,r);e.onAfterRender(E,t,n,i,o,r)}function we(e,t,n){!0!==t.isScene&&(t=X);const i=$.get(e),o=p.state.lights,r=p.state.shadowsArray,a=o.state.version,s=re.getParameters(e,o.state,r,t,n),c=re.getProgramCacheKey(s);let l=i.program,d=!0;if(i.environment=e.isMeshStandardMaterial?t.environment:null,i.fog=t.fog,i.envMap=te.get(e.envMap||i.environment),void 0===l)e.addEventListener("dispose",Se);else if(l.cacheKey!==c)Ne(e);else if(i.lightsStateVersion!==a)d=!1;else{if(void 0!==s.shaderID)return;d=!1}d&&(s.uniforms=re.getUniforms(e),e.onBeforeCompile(s,E),l=re.acquireProgram(s,c),i.program=l,i.uniforms=s.uniforms,i.outputEncoding=s.outputEncoding);const h=i.uniforms;(e.isShaderMaterial||e.isRawShaderMaterial)&&!0!==e.clipping||(i.numClippingPlanes=le.numPlanes,i.numIntersection=le.numIntersection,h.clippingPlanes=le.uniform),i.needsLights=function(e){return e.isMeshLambertMaterial||e.isMeshToonMaterial||e.isMeshPhongMaterial||e.isMeshStandardMaterial||e.isShadowMaterial||e.isShaderMaterial&&!0===e.lights}(e),i.lightsStateVersion=a,i.needsLights&&(h.ambientLightColor.value=o.state.ambient,h.lightProbe.value=o.state.probe,h.directionalLights.value=o.state.directional,h.directionalLightShadows.value=o.state.directionalShadow,h.spotLights.value=o.state.spot,h.spotLightShadows.value=o.state.spotShadow,h.rectAreaLights.value=o.state.rectArea,h.ltc_1.value=o.state.rectAreaLTC1,h.ltc_2.value=o.state.rectAreaLTC2,h.pointLights.value=o.state.point,h.pointLightShadows.value=o.state.pointShadow,h.hemisphereLights.value=o.state.hemi,h.directionalShadowMap.value=o.state.directionalShadowMap,h.directionalShadowMatrix.value=o.state.directionalShadowMatrix,h.spotShadowMap.value=o.state.spotShadowMap,h.spotShadowMatrix.value=o.state.spotShadowMatrix,h.pointShadowMap.value=o.state.pointShadowMap,h.pointShadowMatrix.value=o.state.pointShadowMatrix);const f=i.program.getUniforms(),u=Hi.seqWithValue(f.seq,h);i.uniformsList=u}function Ce(e,t,n,i){!0!==t.isScene&&(t=X),ee.resetTextureUnits();const o=t.fog,r=n.isMeshStandardMaterial?t.environment:null,a=null===I?E.outputEncoding:I.texture.encoding,s=te.get(n.envMap||r),c=$.get(n),l=p.state.lights;if(!0===W&&(!0===Y||e!==b)){const t=e===b&&n.id===N;le.setState(n,e,t)}n.version===c.__version?n.fog&&c.fog!==o||c.environment!==r||c.needsLights&&c.lightsStateVersion!==l.state.version?we(n,t,i):void 0===c.numClippingPlanes||c.numClippingPlanes===le.numPlanes&&c.numIntersection===le.numIntersection?(c.outputEncoding!==a||c.envMap!==s)&&we(n,t,i):we(n,t,i):(we(n,t,i),c.__version=n.version);let d=!1,f=!1,u=!1;const g=c.program,T=g.getUniforms(),v=c.uniforms;if(J.useProgram(g.program)&&(d=!0,f=!0,u=!0),n.id!==N&&(N=n.id,f=!0),d||b!==e){if(T.setValue(ge,"projectionMatrix",e.projectionMatrix),Z.logarithmicDepthBuffer&&T.setValue(ge,"logDepthBufFC",2/(Math.log(e.far+1)/Math.LN2)),b!==e&&(b=e,f=!0,u=!0),n.isShaderMaterial||n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshStandardMaterial||n.envMap){const t=T.map.cameraPosition;void 0!==t&&t.setValue(ge,j.setFromMatrixPosition(e.matrixWorld))}(n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshLambertMaterial||n.isMeshBasicMaterial||n.isMeshStandardMaterial||n.isShaderMaterial)&&T.setValue(ge,"isOrthographic",!0===e.isOrthographicCamera),(n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshLambertMaterial||n.isMeshBasicMaterial||n.isMeshStandardMaterial||n.isShaderMaterial||n.isShadowMaterial||n.skinning)&&T.setValue(ge,"viewMatrix",e.matrixWorldInverse)}if(n.skinning){T.setOptional(ge,i,"bindMatrix"),T.setOptional(ge,i,"bindMatrixInverse");const e=i.skeleton;if(e){const t=e.bones;if(Z.floatVertexTextures){if(null===e.boneTexture){let n=Math.sqrt(4*t.length);n=M.ceilPowerOfTwo(n),n=Math.max(n,4);const i=new Float32Array(n*n*4);i.set(e.boneMatrices);const o=new En(i,n,n,m,h);e.boneMatrices=i,e.boneTexture=o,e.boneTextureSize=n}T.setValue(ge,"boneTexture",e.boneTexture,ee),T.setValue(ge,"boneTextureSize",e.boneTextureSize)}else T.setOptional(ge,e,"boneMatrices")}}var A,R;return(f||c.receiveShadow!==i.receiveShadow)&&(c.receiveShadow=i.receiveShadow,T.setValue(ge,"receiveShadow",i.receiveShadow)),f&&(T.setValue(ge,"toneMappingExposure",E.toneMappingExposure),c.needsLights&&(R=u,(A=v).ambientLightColor.needsUpdate=R,A.lightProbe.needsUpdate=R,A.directionalLights.needsUpdate=R,A.directionalLightShadows.needsUpdate=R,A.pointLights.needsUpdate=R,A.pointLightShadows.needsUpdate=R,A.spotLights.needsUpdate=R,A.spotLightShadows.needsUpdate=R,A.rectAreaLights.needsUpdate=R,A.hemisphereLights.needsUpdate=R),o&&n.fog&&ae.refreshFogUniforms(v,o),ae.refreshMaterialUniforms(v,n,C,w),Hi.upload(ge,c.uniformsList,v,ee)),n.isShaderMaterial&&!0===n.uniformsNeedUpdate&&(Hi.upload(ge,c.uniformsList,v,ee),n.uniformsNeedUpdate=!1),n.isSpriteMaterial&&T.setValue(ge,"center",i.center),T.setValue(ge,"modelViewMatrix",i.modelViewMatrix),T.setValue(ge,"normalMatrix",i.normalMatrix),T.setValue(ge,"modelMatrix",i.matrixWorld),g}ye.setAnimationLoop((function(e){Ae.isPresenting||be&&be(e)})),"undefined"!=typeof window&&ye.setContext(window),this.setAnimationLoop=function(e){be=e,Ae.setAnimationLoop(e),null===e?ye.stop():ye.start()},this.render=function(e,t){let n,i;if(void 0!==arguments[2]&&(console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),n=arguments[2]),void 0!==arguments[3]&&(console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),i=arguments[3]),void 0!==t&&!0!==t.isCamera)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(!0===T)return;me.resetDefaultState(),N=-1,b=null,!0===e.autoUpdate&&e.updateMatrixWorld(),null===t.parent&&t.updateMatrixWorld(),!0===Ae.enabled&&!0===Ae.isPresenting&&(t=Ae.getCamera(t)),!0===e.isScene&&e.onBeforeRender(E,e,t,n||I),p=ce.get(e,g.length),p.init(),g.push(p),k.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),z.setFromProjectionMatrix(k),Y=this.localClippingEnabled,W=le.init(this.clippingPlanes,Y,t),u=se.get(e,t),u.init(),xe(e,t,0,E.sortObjects),u.finish(),!0===E.sortObjects&&u.sort(P,F),!0===W&&le.beginShadows();const o=p.state.shadowsArray;Re.render(o,e,t),p.setupLights(),p.setupLightsView(t),!0===W&&le.endShadows(),!0===this.info.autoReset&&this.info.reset(),void 0!==n&&this.setRenderTarget(n),de.render(u,e,t,i);const r=u.opaque,a=u.transparent;r.length>0&&Le(r,e,t),a.length>0&&Le(a,e,t),!0===e.isScene&&e.onAfterRender(E,e,t),null!==I&&(ee.updateRenderTargetMipmap(I),ee.updateMultisampleRenderTarget(I)),J.buffers.depth.setTest(!0),J.buffers.depth.setMask(!0),J.buffers.color.setMask(!0),J.setPolygonOffset(!1),g.pop(),p=g.length>0?g[g.length-1]:null,u=null},this.setFramebuffer=function(e){v!==e&&null===I&&ge.bindFramebuffer(36160,e),v=e},this.getActiveCubeFace=function(){return A},this.getActiveMipmapLevel=function(){return R},this.getRenderList=function(){return u},this.setRenderList=function(e){u=e},this.getRenderTarget=function(){return I},this.setRenderTarget=function(e,t=0,n=0){I=e,A=t,R=n,e&&void 0===$.get(e).__webglFramebuffer&&ee.setupRenderTarget(e);let i=v,o=!1;if(e){const n=$.get(e).__webglFramebuffer;e.isWebGLCubeRenderTarget?(i=n[t],o=!0):i=e.isWebGLMultisampleRenderTarget?$.get(e).__webglMultisampledFramebuffer:n,y.copy(e.viewport),x.copy(e.scissor),L=e.scissorTest}else y.copy(H).multiplyScalar(C).floor(),x.copy(U).multiplyScalar(C).floor(),L=B;if(O!==i&&(ge.bindFramebuffer(36160,i),O=i),J.viewport(y),J.scissor(x),J.setScissorTest(L),o){const i=$.get(e.texture);ge.framebufferTexture2D(36160,36064,34069+t,i.__webglTexture,n)}},this.readRenderTargetPixels=function(e,t,n,i,o,r,a){if(!e||!e.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let s=$.get(e).__webglFramebuffer;if(e.isWebGLCubeRenderTarget&&void 0!==a&&(s=s[a]),s){let a=!1;s!==O&&(ge.bindFramebuffer(36160,s),a=!0);try{const s=e.texture,c=s.format,l=s.type;if(c!==m&&pe.convert(c)!==ge.getParameter(35739))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");const d=l===f&&(K.has("EXT_color_buffer_half_float")||Z.isWebGL2&&K.has("EXT_color_buffer_float"));if(!(1009===l||pe.convert(l)===ge.getParameter(35738)||l===h&&(Z.isWebGL2||K.has("OES_texture_float")||K.has("WEBGL_color_buffer_float"))||d))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");36053===ge.checkFramebufferStatus(36160)?t>=0&&t<=e.width-i&&n>=0&&n<=e.height-o&&ge.readPixels(t,n,i,o,pe.convert(c),pe.convert(l),r):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{a&&ge.bindFramebuffer(36160,O)}}},this.copyFramebufferToTexture=function(e,t,n=0){const i=Math.pow(2,-n),o=Math.floor(t.image.width*i),r=Math.floor(t.image.height*i),a=pe.convert(t.format);ee.setTexture2D(t,0),ge.copyTexImage2D(3553,n,a,e.x,e.y,o,r,0),J.unbindTexture()},this.copyTextureToTexture=function(e,t,n,i=0){const o=t.image.width,r=t.image.height,a=pe.convert(n.format),s=pe.convert(n.type);ee.setTexture2D(n,0),ge.pixelStorei(37440,n.flipY),ge.pixelStorei(37441,n.premultiplyAlpha),ge.pixelStorei(3317,n.unpackAlignment),t.isDataTexture?ge.texSubImage2D(3553,i,e.x,e.y,o,r,a,s,t.image.data):t.isCompressedTexture?ge.compressedTexSubImage2D(3553,i,e.x,e.y,t.mipmaps[0].width,t.mipmaps[0].height,a,t.mipmaps[0].data):ge.texSubImage2D(3553,i,e.x,e.y,a,s,t.image),0===i&&n.generateMipmaps&&ge.generateMipmap(3553),J.unbindTexture()},this.initTexture=function(e){ee.setTexture2D(e,0),J.unbindTexture()},this.resetState=function(){J.reset(),me.reset()},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}function Lo(e){xo.call(this,e)}Eo.prototype=Object.create(pt.prototype),Eo.prototype.constructor=Eo,Eo.prototype.isMeshDepthMaterial=!0,Eo.prototype.copy=function(e){return pt.prototype.copy.call(this,e),this.depthPacking=e.depthPacking,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this},To.prototype=Object.create(pt.prototype),To.prototype.constructor=To,To.prototype.isMeshDistanceMaterial=!0,To.prototype.copy=function(e){return pt.prototype.copy.call(this,e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this},Oo.prototype=Object.assign(Object.create(fn.prototype),{constructor:Oo,isArrayCamera:!0}),So.prototype=Object.assign(Object.create(Ye.prototype),{constructor:So,isGroup:!0}),Object.assign(No.prototype,{constructor:No,getHandSpace:function(){return null===this._hand&&(this._hand=new So,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand},getTargetRaySpace:function(){return null===this._targetRay&&(this._targetRay=new So,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1),this._targetRay},getGripSpace:function(){return null===this._grip&&(this._grip=new So,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1),this._grip},dispatchEvent:function(e){return null!==this._targetRay&&this._targetRay.dispatchEvent(e),null!==this._grip&&this._grip.dispatchEvent(e),null!==this._hand&&this._hand.dispatchEvent(e),this},disconnect:function(e){return this.dispatchEvent({type:"disconnected",data:e}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this},update:function(e,t,n){let i=null,o=null,r=null;const a=this._targetRay,s=this._grip,c=this._hand;if(e&&"visible-blurred"!==t.session.visibilityState)if(c&&e.hand){r=!0;for(const i of e.hand.values()){const e=t.getJointPose(i,n);if(void 0===c.joints[i.jointName]){const e=new So;e.matrixAutoUpdate=!1,e.visible=!1,c.joints[i.jointName]=e,c.add(e)}const o=c.joints[i.jointName];null!==e&&(o.matrix.fromArray(e.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),o.jointRadius=e.radius),o.visible=null!==e}const i=c.joints["index-finger-tip"],o=c.joints["thumb-tip"],a=i.position.distanceTo(o.position),s=.02,l=.005;c.inputState.pinching&&a>s+l?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!c.inputState.pinching&&a<=s-l&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else null!==a&&(i=t.getPose(e.targetRaySpace,n),null!==i&&(a.matrix.fromArray(i.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale))),null!==s&&e.gripSpace&&(o=t.getPose(e.gripSpace,n),null!==o&&(s.matrix.fromArray(o.transform.matrix),s.matrix.decompose(s.position,s.rotation,s.scale)));return null!==a&&(a.visible=null!==i),null!==s&&(s.visible=null!==o),null!==c&&(c.visible=null!==r),this}}),Object.assign(bo.prototype,_.prototype),Lo.prototype=Object.assign(Object.create(xo.prototype),{constructor:Lo,isWebGL1Renderer:!0});class _o extends Ye{constructor(){super(),Object.defineProperty(this,"isScene",{value:!0}),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),null!==e.background&&(this.background=e.background.clone()),null!==e.environment&&(this.environment=e.environment.clone()),null!==e.fog&&(this.fog=e.fog.clone()),null!==e.overrideMaterial&&(this.overrideMaterial=e.overrideMaterial.clone()),this.autoUpdate=e.autoUpdate,this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return null!==this.background&&(t.object.background=this.background.toJSON(e)),null!==this.environment&&(t.object.environment=this.environment.toJSON(e)),null!==this.fog&&(t.object.fog=this.fog.toJSON()),t}}function wo(e,t){this.array=e,this.stride=t,this.count=void 0!==e?e.length/t:0,this.usage=y,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=M.generateUUID()}Object.defineProperty(wo.prototype,"needsUpdate",{set:function(e){!0===e&&this.version++}}),Object.assign(wo.prototype,{isInterleavedBuffer:!0,onUploadCallback:function(){},setUsage:function(e){return this.usage=e,this},copy:function(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this},copyAt:function(e,t,n){e*=this.stride,n*=t.stride;for(let i=0,o=this.stride;i<o;i++)this.array[e+i]=t.array[n+i];return this},set:function(e,t=0){return this.array.set(e,t),this},clone:function(e){void 0===e.arrayBuffers&&(e.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=M.generateUUID()),void 0===e.arrayBuffers[this.array.buffer._uuid]&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new wo(new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),this.stride);return t.setUsage(this.usage),t},onUpload:function(e){return this.onUploadCallback=e,this},toJSON:function(e){return void 0===e.arrayBuffers&&(e.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=M.generateUUID()),void 0===e.arrayBuffers[this.array.buffer._uuid]&&(e.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}});const Co=new V;function Mo(e,t,n,i){this.name="",this.data=e,this.itemSize=t,this.offset=n,this.normalized=!0===i}function Do(e){pt.call(this),this.type="SpriteMaterial",this.color=new ht(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(e)}let Po;Object.defineProperties(Mo.prototype,{count:{get:function(){return this.data.count}},array:{get:function(){return this.data.array}},needsUpdate:{set:function(e){this.data.needsUpdate=e}}}),Object.assign(Mo.prototype,{isInterleavedBufferAttribute:!0,applyMatrix4:function(e){for(let t=0,n=this.data.count;t<n;t++)Co.x=this.getX(t),Co.y=this.getY(t),Co.z=this.getZ(t),Co.applyMatrix4(e),this.setXYZ(t,Co.x,Co.y,Co.z);return this},setX:function(e,t){return this.data.array[e*this.data.stride+this.offset]=t,this},setY:function(e,t){return this.data.array[e*this.data.stride+this.offset+1]=t,this},setZ:function(e,t){return this.data.array[e*this.data.stride+this.offset+2]=t,this},setW:function(e,t){return this.data.array[e*this.data.stride+this.offset+3]=t,this},getX:function(e){return this.data.array[e*this.data.stride+this.offset]},getY:function(e){return this.data.array[e*this.data.stride+this.offset+1]},getZ:function(e){return this.data.array[e*this.data.stride+this.offset+2]},getW:function(e){return this.data.array[e*this.data.stride+this.offset+3]},setXY:function(e,t,n){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this},setXYZ:function(e,t,n,i){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=i,this},setXYZW:function(e,t,n,i,o){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=i,this.data.array[e+3]=o,this},clone:function(e){if(void 0===e){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let t=0;t<this.count;t++){const n=t*this.data.stride+this.offset;for(let t=0;t<this.itemSize;t++)e.push(this.data.array[n+t])}return new Tt(new this.array.constructor(e),this.itemSize,this.normalized)}return void 0===e.interleavedBuffers&&(e.interleavedBuffers={}),void 0===e.interleavedBuffers[this.data.uuid]&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new Mo(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)},toJSON:function(e){if(void 0===e){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let t=0;t<this.count;t++){const n=t*this.data.stride+this.offset;for(let t=0;t<this.itemSize;t++)e.push(this.data.array[n+t])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}return void 0===e.interleavedBuffers&&(e.interleavedBuffers={}),void 0===e.interleavedBuffers[this.data.uuid]&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}),Do.prototype=Object.create(pt.prototype),Do.prototype.constructor=Do,Do.prototype.isSpriteMaterial=!0,Do.prototype.copy=function(e){return pt.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this};const Fo=new V,Ho=new V,Uo=new V,Bo=new D,zo=new D,Go=new Te,Wo=new V,Yo=new V,Vo=new V,ko=new D,jo=new D,Xo=new D;function qo(e){if(Ye.call(this),this.type="Sprite",void 0===Po){Po=new Bt;const e=new wo(new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),5);Po.setIndex([0,1,2,0,2,3]),Po.setAttribute("position",new Mo(e,3,0,!1)),Po.setAttribute("uv",new Mo(e,2,3,!1))}this.geometry=Po,this.material=void 0!==e?e:new Do,this.center=new D(.5,.5)}function Ko(e,t,n,i,o,r){Bo.subVectors(e,n).addScalar(.5).multiply(i),void 0!==o?(zo.x=r*Bo.x-o*Bo.y,zo.y=o*Bo.x+r*Bo.y):zo.copy(Bo),e.copy(t),e.x+=zo.x,e.y+=zo.y,e.applyMatrix4(Go)}qo.prototype=Object.assign(Object.create(Ye.prototype),{constructor:qo,isSprite:!0,raycast:function(e,t){null===e.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Ho.setFromMatrixScale(this.matrixWorld),Go.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),Uo.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&Ho.multiplyScalar(-Uo.z);const n=this.material.rotation;let i,o;0!==n&&(o=Math.cos(n),i=Math.sin(n));const r=this.center;Ko(Wo.set(-.5,-.5,0),Uo,r,Ho,i,o),Ko(Yo.set(.5,-.5,0),Uo,r,Ho,i,o),Ko(Vo.set(.5,.5,0),Uo,r,Ho,i,o),ko.set(0,0),jo.set(1,0),Xo.set(1,1);let a=e.ray.intersectTriangle(Wo,Yo,Vo,!1,Fo);if(null===a&&(Ko(Yo.set(-.5,.5,0),Uo,r,Ho,i,o),jo.set(0,1),a=e.ray.intersectTriangle(Wo,Vo,Yo,!1,Fo),null===a))return;const s=e.ray.origin.distanceTo(Fo);s<e.near||s>e.far||t.push({distance:s,point:Fo.clone(),uv:ot.getUV(Fo,Wo,Yo,Vo,ko,jo,Xo,new D),face:null,object:this})},copy:function(e){return Ye.prototype.copy.call(this,e),void 0!==e.center&&this.center.copy(e.center),this.material=e.material,this}});const Zo=new V,Jo=new V;function Qo(){Ye.call(this),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]}}),this.autoUpdate=!0}Qo.prototype=Object.assign(Object.create(Ye.prototype),{constructor:Qo,isLOD:!0,copy:function(e){Ye.prototype.copy.call(this,e,!1);const t=e.levels;for(let e=0,n=t.length;e<n;e++){const n=t[e];this.addLevel(n.object.clone(),n.distance)}return this.autoUpdate=e.autoUpdate,this},addLevel:function(e,t=0){t=Math.abs(t);const n=this.levels;let i;for(i=0;i<n.length&&!(t<n[i].distance);i++);return n.splice(i,0,{distance:t,object:e}),this.add(e),this},getCurrentLevel:function(){return this._currentLevel},getObjectForDistance:function(e){const t=this.levels;if(t.length>0){let n,i;for(n=1,i=t.length;n<i&&!(e<t[n].distance);n++);return t[n-1].object}return null},raycast:function(e,t){if(this.levels.length>0){Zo.setFromMatrixPosition(this.matrixWorld);const n=e.ray.origin.distanceTo(Zo);this.getObjectForDistance(n).raycast(e,t)}},update:function(e){const t=this.levels;if(t.length>1){Zo.setFromMatrixPosition(e.matrixWorld),Jo.setFromMatrixPosition(this.matrixWorld);const n=Zo.distanceTo(Jo)/e.zoom;let i,o;for(t[0].object.visible=!0,i=1,o=t.length;i<o&&n>=t[i].distance;i++)t[i-1].object.visible=!1,t[i].object.visible=!0;for(this._currentLevel=i-1;i<o;i++)t[i].object.visible=!1}},toJSON:function(e){const t=Ye.prototype.toJSON.call(this,e);!1===this.autoUpdate&&(t.object.autoUpdate=!1),t.object.levels=[];const n=this.levels;for(let e=0,i=n.length;e<i;e++){const i=n[e];t.object.levels.push({object:i.object.uuid,distance:i.distance})}return t}});const $o=new V,er=new G,tr=new G,nr=new V,ir=new Te;function or(e,t){e&&e.isGeometry&&console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."),on.call(this,e,t),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Te,this.bindMatrixInverse=new Te}function rr(){Ye.call(this),this.type="Bone"}or.prototype=Object.assign(Object.create(on.prototype),{constructor:or,isSkinnedMesh:!0,copy:function(e){return on.prototype.copy.call(this,e),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,this},bind:function(e,t){this.skeleton=e,void 0===t&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()},pose:function(){this.skeleton.pose()},normalizeSkinWeights:function(){const e=new G,t=this.geometry.attributes.skinWeight;for(let n=0,i=t.count;n<i;n++){e.x=t.getX(n),e.y=t.getY(n),e.z=t.getZ(n),e.w=t.getW(n);const i=1/e.manhattanLength();i!==1/0?e.multiplyScalar(i):e.set(1,0,0,0),t.setXYZW(n,e.x,e.y,e.z,e.w)}},updateMatrixWorld:function(e){on.prototype.updateMatrixWorld.call(this,e),"attached"===this.bindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)},boneTransform:function(e,t){const n=this.skeleton,i=this.geometry;er.fromBufferAttribute(i.attributes.skinIndex,e),tr.fromBufferAttribute(i.attributes.skinWeight,e),$o.fromBufferAttribute(i.attributes.position,e).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let e=0;e<4;e++){const i=tr.getComponent(e);if(0!==i){const o=er.getComponent(e);ir.multiplyMatrices(n.bones[o].matrixWorld,n.boneInverses[o]),t.addScaledVector(nr.copy($o).applyMatrix4(ir),i)}}return t.applyMatrix4(this.bindMatrixInverse)}}),rr.prototype=Object.assign(Object.create(Ye.prototype),{constructor:rr,isBone:!0});const ar=new Te,sr=new Te;function cr(e=[],t=[]){this.uuid=M.generateUUID(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}Object.assign(cr.prototype,{init:function(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(16*e.length),0===t.length)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let e=0,t=this.bones.length;e<t;e++)this.boneInverses.push(new Te)}},calculateInverses:function(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const t=new Te;this.bones[e]&&t.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(t)}},pose:function(){for(let e=0,t=this.bones.length;e<t;e++){const t=this.bones[e];t&&t.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const t=this.bones[e];t&&(t.parent&&t.parent.isBone?(t.matrix.copy(t.parent.matrixWorld).invert(),t.matrix.multiply(t.matrixWorld)):t.matrix.copy(t.matrixWorld),t.matrix.decompose(t.position,t.quaternion,t.scale))}},update:function(){const e=this.bones,t=this.boneInverses,n=this.boneMatrices,i=this.boneTexture;for(let i=0,o=e.length;i<o;i++){const o=e[i]?e[i].matrixWorld:sr;ar.multiplyMatrices(o,t[i]),ar.toArray(n,16*i)}null!==i&&(i.needsUpdate=!0)},clone:function(){return new cr(this.bones,this.boneInverses)},getBoneByName:function(e){for(let t=0,n=this.bones.length;t<n;t++){const n=this.bones[t];if(n.name===e)return n}},dispose:function(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)},fromJSON:function(e,t){this.uuid=e.uuid;for(let n=0,i=e.bones.length;n<i;n++){const i=e.bones[n];let o=t[i];void 0===o&&(console.warn("THREE.Skeleton: No bone found with UUID:",i),o=new rr),this.bones.push(o),this.boneInverses.push((new Te).fromArray(e.boneInverses[n]))}return this.init(),this},toJSON:function(){const e={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,n=this.boneInverses;for(let i=0,o=t.length;i<o;i++){const o=t[i];e.bones.push(o.uuid);const r=n[i];e.boneInverses.push(r.toArray())}return e}});const lr=new Te,dr=new Te,hr=[],fr=new on;function ur(e,t,n){on.call(this,e,t),this.instanceMatrix=new Tt(new Float32Array(16*n),16),this.instanceColor=null,this.count=n,this.frustumCulled=!1}function pr(e){pt.call(this),this.type="LineBasicMaterial",this.color=new ht(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.morphTargets=!1,this.setValues(e)}ur.prototype=Object.assign(Object.create(on.prototype),{constructor:ur,isInstancedMesh:!0,copy:function(e){return on.prototype.copy.call(this,e),this.instanceMatrix.copy(e.instanceMatrix),null!==e.instanceColor&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,this},getColorAt:function(e,t){t.fromArray(this.instanceColor.array,3*e)},getMatrixAt:function(e,t){t.fromArray(this.instanceMatrix.array,16*e)},raycast:function(e,t){const n=this.matrixWorld,i=this.count;if(fr.geometry=this.geometry,fr.material=this.material,void 0!==fr.material)for(let o=0;o<i;o++){this.getMatrixAt(o,lr),dr.multiplyMatrices(n,lr),fr.matrixWorld=dr,fr.raycast(e,hr);for(let e=0,n=hr.length;e<n;e++){const n=hr[e];n.instanceId=o,n.object=this,t.push(n)}hr.length=0}},setColorAt:function(e,t){null===this.instanceColor&&(this.instanceColor=new Tt(new Float32Array(3*this.count),3)),t.toArray(this.instanceColor.array,3*e)},setMatrixAt:function(e,t){t.toArray(this.instanceMatrix.array,16*e)},updateMorphTargets:function(){},dispose:function(){this.dispatchEvent({type:"dispose"})}}),pr.prototype=Object.create(pt.prototype),pr.prototype.constructor=pr,pr.prototype.isLineBasicMaterial=!0,pr.prototype.copy=function(e){return pt.prototype.copy.call(this,e),this.color.copy(e.color),this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.morphTargets=e.morphTargets,this};const mr=new V,gr=new V,Er=new Te,Tr=new Ee,vr=new le;function Ar(e=new Bt,t=new pr){Ye.call(this),this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}Ar.prototype=Object.assign(Object.create(Ye.prototype),{constructor:Ar,isLine:!0,copy:function(e){return Ye.prototype.copy.call(this,e),this.material=e.material,this.geometry=e.geometry,this},computeLineDistances:function(){const e=this.geometry;if(e.isBufferGeometry)if(null===e.index){const t=e.attributes.position,n=[0];for(let e=1,i=t.count;e<i;e++)mr.fromBufferAttribute(t,e-1),gr.fromBufferAttribute(t,e),n[e]=n[e-1],n[e]+=mr.distanceTo(gr);e.setAttribute("lineDistance",new yt(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else e.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this},raycast:function(e,t){const n=this.geometry,i=this.matrixWorld,o=e.params.Line.threshold;if(null===n.boundingSphere&&n.computeBoundingSphere(),vr.copy(n.boundingSphere),vr.applyMatrix4(i),vr.radius+=o,!1===e.ray.intersectsSphere(vr))return;Er.copy(i).invert(),Tr.copy(e.ray).applyMatrix4(Er);const r=o/((this.scale.x+this.scale.y+this.scale.z)/3),a=r*r,s=new V,c=new V,l=new V,d=new V,h=this.isLineSegments?2:1;if(n.isBufferGeometry){const i=n.index,o=n.attributes.position;if(null!==i){const n=i.array;for(let i=0,r=n.length-1;i<r;i+=h){const r=n[i],h=n[i+1];if(s.fromBufferAttribute(o,r),c.fromBufferAttribute(o,h),Tr.distanceSqToSegment(s,c,d,l)>a)continue;d.applyMatrix4(this.matrixWorld);const f=e.ray.origin.distanceTo(d);f<e.near||f>e.far||t.push({distance:f,point:l.clone().applyMatrix4(this.matrixWorld),index:i,face:null,faceIndex:null,object:this})}}else for(let n=0,i=o.count-1;n<i;n+=h){if(s.fromBufferAttribute(o,n),c.fromBufferAttribute(o,n+1),Tr.distanceSqToSegment(s,c,d,l)>a)continue;d.applyMatrix4(this.matrixWorld);const i=e.ray.origin.distanceTo(d);i<e.near||i>e.far||t.push({distance:i,point:l.clone().applyMatrix4(this.matrixWorld),index:n,face:null,faceIndex:null,object:this})}}else n.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")},updateMorphTargets:function(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const e=t[n[0]];if(void 0!==e){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,n=e.length;t<n;t++){const n=e[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=t}}}}else{const t=e.morphTargets;void 0!==t&&t.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}});const Rr=new V,Ir=new V;function Or(e,t){Ar.call(this,e,t),this.type="LineSegments"}function Sr(e,t){Ar.call(this,e,t),this.type="LineLoop"}function Nr(e){pt.call(this),this.type="PointsMaterial",this.color=new ht(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.morphTargets=!1,this.setValues(e)}Or.prototype=Object.assign(Object.create(Ar.prototype),{constructor:Or,isLineSegments:!0,computeLineDistances:function(){const e=this.geometry;if(e.isBufferGeometry)if(null===e.index){const t=e.attributes.position,n=[];for(let e=0,i=t.count;e<i;e+=2)Rr.fromBufferAttribute(t,e),Ir.fromBufferAttribute(t,e+1),n[e]=0===e?0:n[e-1],n[e+1]=n[e]+Rr.distanceTo(Ir);e.setAttribute("lineDistance",new yt(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else e.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}),Sr.prototype=Object.assign(Object.create(Ar.prototype),{constructor:Sr,isLineLoop:!0}),Nr.prototype=Object.create(pt.prototype),Nr.prototype.constructor=Nr,Nr.prototype.isPointsMaterial=!0,Nr.prototype.copy=function(e){return pt.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.morphTargets=e.morphTargets,this};const br=new Te,yr=new Ee,xr=new le,Lr=new V;function _r(e=new Bt,t=new Nr){Ye.call(this),this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}function wr(e,t,n,i,o,r,a){const s=yr.distanceSqToPoint(e);if(s<n){const n=new V;yr.closestPointToPoint(e,n),n.applyMatrix4(i);const c=o.ray.origin.distanceTo(n);if(c<o.near||c>o.far)return;r.push({distance:c,distanceToRay:Math.sqrt(s),point:n,index:t,face:null,object:a})}}function Cr(e,t,n,i,o,r,a,c,l){B.call(this,e,t,n,i,o,r,a,c,l),this.format=void 0!==a?a:p,this.minFilter=void 0!==r?r:s,this.magFilter=void 0!==o?o:s,this.generateMipmaps=!1;const d=this;"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback((function t(){d.needsUpdate=!0,e.requestVideoFrameCallback(t)}))}function Mr(e,t,n,i,o,r,a,s,c,l,d,h){B.call(this,null,r,a,s,c,l,i,o,d,h),this.image={width:t,height:n},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}function Dr(e,t,n,i,o,r,a,s,c){B.call(this,e,t,n,i,o,r,a,s,c),this.needsUpdate=!0}function Pr(e,t,n,i,o,r,s,c,d,h){if((h=void 0!==h?h:g)!==g&&h!==E)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===n&&h===g&&(n=l),void 0===n&&h===E&&(n=u),B.call(this,null,i,o,r,s,c,h,n,d),this.image={width:e,height:t},this.magFilter=void 0!==s?s:a,this.minFilter=void 0!==c?c:a,this.flipY=!1,this.generateMipmaps=!1}_r.prototype=Object.assign(Object.create(Ye.prototype),{constructor:_r,isPoints:!0,copy:function(e){return Ye.prototype.copy.call(this,e),this.material=e.material,this.geometry=e.geometry,this},raycast:function(e,t){const n=this.geometry,i=this.matrixWorld,o=e.params.Points.threshold;if(null===n.boundingSphere&&n.computeBoundingSphere(),xr.copy(n.boundingSphere),xr.applyMatrix4(i),xr.radius+=o,!1===e.ray.intersectsSphere(xr))return;br.copy(i).invert(),yr.copy(e.ray).applyMatrix4(br);const r=o/((this.scale.x+this.scale.y+this.scale.z)/3),a=r*r;if(n.isBufferGeometry){const o=n.index,r=n.attributes.position;if(null!==o){const n=o.array;for(let o=0,s=n.length;o<s;o++){const s=n[o];Lr.fromBufferAttribute(r,s),wr(Lr,s,a,i,e,t,this)}}else for(let n=0,o=r.count;n<o;n++)Lr.fromBufferAttribute(r,n),wr(Lr,n,a,i,e,t,this)}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")},updateMorphTargets:function(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const e=t[n[0]];if(void 0!==e){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,n=e.length;t<n;t++){const n=e[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=t}}}}else{const t=e.morphTargets;void 0!==t&&t.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}),Cr.prototype=Object.assign(Object.create(B.prototype),{constructor:Cr,clone:function(){return new this.constructor(this.image).copy(this)},isVideoTexture:!0,update:function(){const e=this.image;!1=="requestVideoFrameCallback"in e&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}),Mr.prototype=Object.create(B.prototype),Mr.prototype.constructor=Mr,Mr.prototype.isCompressedTexture=!0,Dr.prototype=Object.create(B.prototype),Dr.prototype.constructor=Dr,Dr.prototype.isCanvasTexture=!0,Pr.prototype=Object.create(B.prototype),Pr.prototype.constructor=Pr,Pr.prototype.isDepthTexture=!0,new V,new V,new V,new ot;function Fr(e,t,n,i,o){let r,a;if(o===function(e,t,n,i){let o=0;for(let r=t,a=n-i;r<n;r+=i)o+=(e[a]-e[r])*(e[r+1]+e[a+1]),a=r;return o}(e,t,n,i)>0)for(r=t;r<n;r+=i)a=ia(r,e[r],e[r+1],a);else for(r=n-i;r>=t;r-=i)a=ia(r,e[r],e[r+1],a);return a&&Jr(a,a.next)&&(oa(a),a=a.next),a}function Hr(e,t){if(!e)return e;t||(t=e);let n,i=e;do{if(n=!1,i.steiner||!Jr(i,i.next)&&0!==Zr(i.prev,i,i.next))i=i.next;else{if(oa(i),i=t=i.prev,i===i.next)break;n=!0}}while(n||i!==t);return t}function Ur(e,t,n,i,o,r,a){if(!e)return;!a&&r&&function(e,t,n,i){let o=e;do{null===o.z&&(o.z=jr(o.x,o.y,t,n,i)),o.prevZ=o.prev,o.nextZ=o.next,o=o.next}while(o!==e);o.prevZ.nextZ=null,o.prevZ=null,function(e){let t,n,i,o,r,a,s,c,l=1;do{for(n=e,e=null,r=null,a=0;n;){for(a++,i=n,s=0,t=0;t<l&&(s++,i=i.nextZ,i);t++);for(c=l;s>0||c>0&&i;)0!==s&&(0===c||!i||n.z<=i.z)?(o=n,n=n.nextZ,s--):(o=i,i=i.nextZ,c--),r?r.nextZ=o:e=o,o.prevZ=r,r=o;n=i}r.nextZ=null,l*=2}while(a>1)}(o)}(e,i,o,r);let s,c,l=e;for(;e.prev!==e.next;)if(s=e.prev,c=e.next,r?zr(e,i,o,r):Br(e))t.push(s.i/n),t.push(e.i/n),t.push(c.i/n),oa(e),e=c.next,l=c.next;else if((e=c)===l){a?1===a?Ur(e=Gr(Hr(e),t,n),t,n,i,o,r,2):2===a&&Wr(e,t,n,i,o,r):Ur(Hr(e),t,n,i,o,r,1);break}}function Br(e){const t=e.prev,n=e,i=e.next;if(Zr(t,n,i)>=0)return!1;let o=e.next.next;for(;o!==e.prev;){if(qr(t.x,t.y,n.x,n.y,i.x,i.y,o.x,o.y)&&Zr(o.prev,o,o.next)>=0)return!1;o=o.next}return!0}function zr(e,t,n,i){const o=e.prev,r=e,a=e.next;if(Zr(o,r,a)>=0)return!1;const s=o.x<r.x?o.x<a.x?o.x:a.x:r.x<a.x?r.x:a.x,c=o.y<r.y?o.y<a.y?o.y:a.y:r.y<a.y?r.y:a.y,l=o.x>r.x?o.x>a.x?o.x:a.x:r.x>a.x?r.x:a.x,d=o.y>r.y?o.y>a.y?o.y:a.y:r.y>a.y?r.y:a.y,h=jr(s,c,t,n,i),f=jr(l,d,t,n,i);let u=e.prevZ,p=e.nextZ;for(;u&&u.z>=h&&p&&p.z<=f;){if(u!==e.prev&&u!==e.next&&qr(o.x,o.y,r.x,r.y,a.x,a.y,u.x,u.y)&&Zr(u.prev,u,u.next)>=0)return!1;if(u=u.prevZ,p!==e.prev&&p!==e.next&&qr(o.x,o.y,r.x,r.y,a.x,a.y,p.x,p.y)&&Zr(p.prev,p,p.next)>=0)return!1;p=p.nextZ}for(;u&&u.z>=h;){if(u!==e.prev&&u!==e.next&&qr(o.x,o.y,r.x,r.y,a.x,a.y,u.x,u.y)&&Zr(u.prev,u,u.next)>=0)return!1;u=u.prevZ}for(;p&&p.z<=f;){if(p!==e.prev&&p!==e.next&&qr(o.x,o.y,r.x,r.y,a.x,a.y,p.x,p.y)&&Zr(p.prev,p,p.next)>=0)return!1;p=p.nextZ}return!0}function Gr(e,t,n){let i=e;do{const o=i.prev,r=i.next.next;!Jr(o,r)&&Qr(o,i,i.next,r)&&ta(o,r)&&ta(r,o)&&(t.push(o.i/n),t.push(i.i/n),t.push(r.i/n),oa(i),oa(i.next),i=e=r),i=i.next}while(i!==e);return Hr(i)}function Wr(e,t,n,i,o,r){let a=e;do{let e=a.next.next;for(;e!==a.prev;){if(a.i!==e.i&&Kr(a,e)){let s=na(a,e);return a=Hr(a,a.next),s=Hr(s,s.next),Ur(a,t,n,i,o,r),void Ur(s,t,n,i,o,r)}e=e.next}a=a.next}while(a!==e)}function Yr(e,t){return e.x-t.x}function Vr(e,t){if(t=function(e,t){let n=t;const i=e.x,o=e.y;let r,a=-1/0;do{if(o<=n.y&&o>=n.next.y&&n.next.y!==n.y){const e=n.x+(o-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(e<=i&&e>a){if(a=e,e===i){if(o===n.y)return n;if(o===n.next.y)return n.next}r=n.x<n.next.x?n:n.next}}n=n.next}while(n!==t);if(!r)return null;if(i===a)return r;const s=r,c=r.x,l=r.y;let d,h=1/0;n=r;do{i>=n.x&&n.x>=c&&i!==n.x&&qr(o<l?i:a,o,c,l,o<l?a:i,o,n.x,n.y)&&(d=Math.abs(o-n.y)/(i-n.x),ta(n,e)&&(d<h||d===h&&(n.x>r.x||n.x===r.x&&kr(r,n)))&&(r=n,h=d)),n=n.next}while(n!==s);return r}(e,t)){const n=na(t,e);Hr(t,t.next),Hr(n,n.next)}}function kr(e,t){return Zr(e.prev,e,t.prev)<0&&Zr(t.next,e,e.next)<0}function jr(e,t,n,i,o){return(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-n)*o)|e<<8))|e<<4))|e<<2))|e<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-i)*o)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function Xr(e){let t=e,n=e;do{(t.x<n.x||t.x===n.x&&t.y<n.y)&&(n=t),t=t.next}while(t!==e);return n}function qr(e,t,n,i,o,r,a,s){return(o-a)*(t-s)-(e-a)*(r-s)>=0&&(e-a)*(i-s)-(n-a)*(t-s)>=0&&(n-a)*(r-s)-(o-a)*(i-s)>=0}function Kr(e,t){return e.next.i!==t.i&&e.prev.i!==t.i&&!function(e,t){let n=e;do{if(n.i!==e.i&&n.next.i!==e.i&&n.i!==t.i&&n.next.i!==t.i&&Qr(n,n.next,e,t))return!0;n=n.next}while(n!==e);return!1}(e,t)&&(ta(e,t)&&ta(t,e)&&function(e,t){let n=e,i=!1;const o=(e.x+t.x)/2,r=(e.y+t.y)/2;do{n.y>r!=n.next.y>r&&n.next.y!==n.y&&o<(n.next.x-n.x)*(r-n.y)/(n.next.y-n.y)+n.x&&(i=!i),n=n.next}while(n!==e);return i}(e,t)&&(Zr(e.prev,e,t.prev)||Zr(e,t.prev,t))||Jr(e,t)&&Zr(e.prev,e,e.next)>0&&Zr(t.prev,t,t.next)>0)}function Zr(e,t,n){return(t.y-e.y)*(n.x-t.x)-(t.x-e.x)*(n.y-t.y)}function Jr(e,t){return e.x===t.x&&e.y===t.y}function Qr(e,t,n,i){const o=ea(Zr(e,t,n)),r=ea(Zr(e,t,i)),a=ea(Zr(n,i,e)),s=ea(Zr(n,i,t));return o!==r&&a!==s||!(0!==o||!$r(e,n,t))||!(0!==r||!$r(e,i,t))||!(0!==a||!$r(n,e,i))||!(0!==s||!$r(n,t,i))}function $r(e,t,n){return t.x<=Math.max(e.x,n.x)&&t.x>=Math.min(e.x,n.x)&&t.y<=Math.max(e.y,n.y)&&t.y>=Math.min(e.y,n.y)}function ea(e){return e>0?1:e<0?-1:0}function ta(e,t){return Zr(e.prev,e,e.next)<0?Zr(e,t,e.next)>=0&&Zr(e,e.prev,t)>=0:Zr(e,t,e.prev)<0||Zr(e,e.next,t)<0}function na(e,t){const n=new ra(e.i,e.x,e.y),i=new ra(t.i,t.x,t.y),o=e.next,r=t.prev;return e.next=t,t.prev=e,n.next=o,o.prev=n,i.next=n,n.prev=i,r.next=i,i.prev=r,i}function ia(e,t,n,i){const o=new ra(e,t,n);return i?(o.next=i.next,o.prev=i,i.next.prev=o,i.next=o):(o.prev=o,o.next=o),o}function oa(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function ra(e,t,n){this.i=e,this.x=t,this.y=n,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}const aa={area:function(e){const t=e.length;let n=0;for(let i=t-1,o=0;o<t;i=o++)n+=e[i].x*e[o].y-e[o].x*e[i].y;return.5*n},isClockWise:function(e){return aa.area(e)<0},triangulateShape:function(e,t){const n=[],i=[],o=[];sa(e),ca(n,e);let r=e.length;t.forEach(sa);for(let e=0;e<t.length;e++)i.push(r),r+=t[e].length,ca(n,t[e]);const a=function(e,t,n){n=n||2;const i=t&&t.length,o=i?t[0]*n:e.length;let r=Fr(e,0,o,n,!0);const a=[];if(!r||r.next===r.prev)return a;let s,c,l,d,h,f,u;if(i&&(r=function(e,t,n,i){const o=[];let r,a,s,c,l;for(r=0,a=t.length;r<a;r++)s=t[r]*i,c=r<a-1?t[r+1]*i:e.length,l=Fr(e,s,c,i,!1),l===l.next&&(l.steiner=!0),o.push(Xr(l));for(o.sort(Yr),r=0;r<o.length;r++)Vr(o[r],n),n=Hr(n,n.next);return n}(e,t,r,n)),e.length>80*n){s=l=e[0],c=d=e[1];for(let t=n;t<o;t+=n)h=e[t],f=e[t+1],h<s&&(s=h),f<c&&(c=f),h>l&&(l=h),f>d&&(d=f);u=Math.max(l-s,d-c),u=0!==u?1/u:0}return Ur(r,a,n,s,c,u),a}(n,i);for(let e=0;e<a.length;e+=3)o.push(a.slice(e,e+3));return o}};function sa(e){const t=e.length;t>2&&e[t-1].equals(e[0])&&e.pop()}function ca(e,t){for(let n=0;n<t.length;n++)e.push(t[n].x),e.push(t[n].y)}class la extends Bt{constructor(e,t){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const n=this,i=[],o=[];for(let t=0,n=e.length;t<n;t++)r(e[t]);function r(e){const r=[],a=void 0!==t.curveSegments?t.curveSegments:12,s=void 0!==t.steps?t.steps:1;let c=void 0!==t.depth?t.depth:100,l=void 0===t.bevelEnabled||t.bevelEnabled,d=void 0!==t.bevelThickness?t.bevelThickness:6,h=void 0!==t.bevelSize?t.bevelSize:d-2,f=void 0!==t.bevelOffset?t.bevelOffset:0,u=void 0!==t.bevelSegments?t.bevelSegments:3;const p=t.extrudePath,m=void 0!==t.UVGenerator?t.UVGenerator:da;void 0!==t.amount&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),c=t.amount);let g,E,T,v,A,R=!1;p&&(g=p.getSpacedPoints(s),R=!0,l=!1,E=p.computeFrenetFrames(s,!1),T=new V,v=new V,A=new V),l||(u=0,d=0,h=0,f=0);const I=e.extractPoints(a);let O=I.shape;const S=I.holes;if(!aa.isClockWise(O)){O=O.reverse();for(let e=0,t=S.length;e<t;e++){const t=S[e];aa.isClockWise(t)&&(S[e]=t.reverse())}}const N=aa.triangulateShape(O,S),b=O;for(let e=0,t=S.length;e<t;e++){const t=S[e];O=O.concat(t)}function y(e,t,n){return t||console.error("THREE.ExtrudeGeometry: vec does not exist"),t.clone().multiplyScalar(n).add(e)}const x=O.length,L=N.length;function _(e,t,n){let i,o,r;const a=e.x-t.x,s=e.y-t.y,c=n.x-e.x,l=n.y-e.y,d=a*a+s*s,h=a*l-s*c;if(Math.abs(h)>Number.EPSILON){const h=Math.sqrt(d),f=Math.sqrt(c*c+l*l),u=t.x-s/h,p=t.y+a/h,m=((n.x-l/f-u)*l-(n.y+c/f-p)*c)/(a*l-s*c);i=u+a*m-e.x,o=p+s*m-e.y;const g=i*i+o*o;if(g<=2)return new D(i,o);r=Math.sqrt(g/2)}else{let e=!1;a>Number.EPSILON?c>Number.EPSILON&&(e=!0):a<-Number.EPSILON?c<-Number.EPSILON&&(e=!0):Math.sign(s)===Math.sign(l)&&(e=!0),e?(i=-s,o=a,r=Math.sqrt(d)):(i=a,o=s,r=Math.sqrt(d/2))}return new D(i/r,o/r)}const w=[];for(let e=0,t=b.length,n=t-1,i=e+1;e<t;e++,n++,i++)n===t&&(n=0),i===t&&(i=0),w[e]=_(b[e],b[n],b[i]);const C=[];let M,P=w.concat();for(let e=0,t=S.length;e<t;e++){const t=S[e];M=[];for(let e=0,n=t.length,i=n-1,o=e+1;e<n;e++,i++,o++)i===n&&(i=0),o===n&&(o=0),M[e]=_(t[e],t[i],t[o]);C.push(M),P=P.concat(M)}for(let e=0;e<u;e++){const t=e/u,n=d*Math.cos(t*Math.PI/2),i=h*Math.sin(t*Math.PI/2)+f;for(let e=0,t=b.length;e<t;e++){const t=y(b[e],w[e],i);U(t.x,t.y,-n)}for(let e=0,t=S.length;e<t;e++){const t=S[e];M=C[e];for(let e=0,o=t.length;e<o;e++){const o=y(t[e],M[e],i);U(o.x,o.y,-n)}}}const F=h+f;for(let e=0;e<x;e++){const t=l?y(O[e],P[e],F):O[e];R?(v.copy(E.normals[0]).multiplyScalar(t.x),T.copy(E.binormals[0]).multiplyScalar(t.y),A.copy(g[0]).add(v).add(T),U(A.x,A.y,A.z)):U(t.x,t.y,0)}for(let e=1;e<=s;e++)for(let t=0;t<x;t++){const n=l?y(O[t],P[t],F):O[t];R?(v.copy(E.normals[e]).multiplyScalar(n.x),T.copy(E.binormals[e]).multiplyScalar(n.y),A.copy(g[e]).add(v).add(T),U(A.x,A.y,A.z)):U(n.x,n.y,c/s*e)}for(let e=u-1;e>=0;e--){const t=e/u,n=d*Math.cos(t*Math.PI/2),i=h*Math.sin(t*Math.PI/2)+f;for(let e=0,t=b.length;e<t;e++){const t=y(b[e],w[e],i);U(t.x,t.y,c+n)}for(let e=0,t=S.length;e<t;e++){const t=S[e];M=C[e];for(let e=0,o=t.length;e<o;e++){const o=y(t[e],M[e],i);R?U(o.x,o.y+g[s-1].y,g[s-1].x+n):U(o.x,o.y,c+n)}}}function H(e,t){let n=e.length;for(;--n>=0;){const i=n;let o=n-1;o<0&&(o=e.length-1);for(let e=0,n=s+2*u;e<n;e++){const n=x*e,r=x*(e+1);z(t+i+n,t+o+n,t+o+r,t+i+r)}}}function U(e,t,n){r.push(e),r.push(t),r.push(n)}function B(e,t,o){G(e),G(t),G(o);const r=i.length/3,a=m.generateTopUV(n,i,r-3,r-2,r-1);W(a[0]),W(a[1]),W(a[2])}function z(e,t,o,r){G(e),G(t),G(r),G(t),G(o),G(r);const a=i.length/3,s=m.generateSideWallUV(n,i,a-6,a-3,a-2,a-1);W(s[0]),W(s[1]),W(s[3]),W(s[1]),W(s[2]),W(s[3])}function G(e){i.push(r[3*e+0]),i.push(r[3*e+1]),i.push(r[3*e+2])}function W(e){o.push(e.x),o.push(e.y)}!function(){const e=i.length/3;if(l){let e=0,t=x*e;for(let e=0;e<L;e++){const n=N[e];B(n[2]+t,n[1]+t,n[0]+t)}e=s+2*u,t=x*e;for(let e=0;e<L;e++){const n=N[e];B(n[0]+t,n[1]+t,n[2]+t)}}else{for(let e=0;e<L;e++){const t=N[e];B(t[2],t[1],t[0])}for(let e=0;e<L;e++){const t=N[e];B(t[0]+x*s,t[1]+x*s,t[2]+x*s)}}n.addGroup(e,i.length/3-e,0)}(),function(){const e=i.length/3;let t=0;H(b,t),t+=b.length;for(let e=0,n=S.length;e<n;e++){const n=S[e];H(n,t),t+=n.length}n.addGroup(e,i.length/3-e,1)}()}this.setAttribute("position",new yt(i,3)),this.setAttribute("uv",new yt(o,2)),this.computeVertexNormals()}toJSON(){const e=Bt.prototype.toJSON.call(this);return function(e,t,n){if(n.shapes=[],Array.isArray(e))for(let t=0,i=e.length;t<i;t++){const i=e[t];n.shapes.push(i.uuid)}else n.shapes.push(e.uuid);return void 0!==t.extrudePath&&(n.options.extrudePath=t.extrudePath.toJSON()),n}(this.parameters.shapes,this.parameters.options,e)}}const da={generateTopUV:function(e,t,n,i,o){const r=t[3*n],a=t[3*n+1],s=t[3*i],c=t[3*i+1],l=t[3*o],d=t[3*o+1];return[new D(r,a),new D(s,c),new D(l,d)]},generateSideWallUV:function(e,t,n,i,o,r){const a=t[3*n],s=t[3*n+1],c=t[3*n+2],l=t[3*i],d=t[3*i+1],h=t[3*i+2],f=t[3*o],u=t[3*o+1],p=t[3*o+2],m=t[3*r],g=t[3*r+1],E=t[3*r+2];return Math.abs(s-d)<.01?[new D(a,1-c),new D(l,1-h),new D(f,1-p),new D(m,1-E)]:[new D(s,1-c),new D(d,1-h),new D(u,1-p),new D(g,1-E)]}};function ha(e,t,n){Bt.call(this),this.type="ParametricGeometry",this.parameters={func:e,slices:t,stacks:n};const i=[],o=[],r=[],a=[],s=1e-5,c=new V,l=new V,d=new V,h=new V,f=new V;e.length<3&&console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");const u=t+1;for(let i=0;i<=n;i++){const u=i/n;for(let n=0;n<=t;n++){const i=n/t;e(i,u,l),o.push(l.x,l.y,l.z),i-s>=0?(e(i-s,u,d),h.subVectors(l,d)):(e(i+s,u,d),h.subVectors(d,l)),u-s>=0?(e(i,u-s,d),f.subVectors(l,d)):(e(i,u+s,d),f.subVectors(d,l)),c.crossVectors(h,f).normalize(),r.push(c.x,c.y,c.z),a.push(i,u)}}for(let e=0;e<n;e++)for(let n=0;n<t;n++){const t=e*u+n,o=e*u+n+1,r=(e+1)*u+n+1,a=(e+1)*u+n;i.push(t,o,a),i.push(o,r,a)}this.setIndex(i),this.setAttribute("position",new yt(o,3)),this.setAttribute("normal",new yt(r,3)),this.setAttribute("uv",new yt(a,2))}ha.prototype=Object.create(Bt.prototype),ha.prototype.constructor=ha;class fa extends Bt{constructor(e,t=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const n=[],i=[],o=[],r=[];let a=0,s=0;if(!1===Array.isArray(e))c(e);else for(let t=0;t<e.length;t++)c(e[t]),this.addGroup(a,s,t),a+=s,s=0;function c(e){const a=i.length/3,c=e.extractPoints(t);let l=c.shape;const d=c.holes;!1===aa.isClockWise(l)&&(l=l.reverse());for(let e=0,t=d.length;e<t;e++){const t=d[e];!0===aa.isClockWise(t)&&(d[e]=t.reverse())}const h=aa.triangulateShape(l,d);for(let e=0,t=d.length;e<t;e++){const t=d[e];l=l.concat(t)}for(let e=0,t=l.length;e<t;e++){const t=l[e];i.push(t.x,t.y,0),o.push(0,0,1),r.push(t.x,t.y)}for(let e=0,t=h.length;e<t;e++){const t=h[e],i=t[0]+a,o=t[1]+a,r=t[2]+a;n.push(i,o,r),s+=3}}this.setIndex(n),this.setAttribute("position",new yt(i,3)),this.setAttribute("normal",new yt(o,3)),this.setAttribute("uv",new yt(r,2))}toJSON(){const e=Bt.prototype.toJSON.call(this);return function(e,t){if(t.shapes=[],Array.isArray(e))for(let n=0,i=e.length;n<i;n++){const i=e[n];t.shapes.push(i.uuid)}else t.shapes.push(e.uuid);return t}(this.parameters.shapes,e)}}class ua extends la{constructor(e,t={}){const n=t.font;if(!n||!n.isFont)return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),new Bt;const i=n.generateShapes(e,t.size);t.depth=void 0!==t.height?t.height:50,void 0===t.bevelThickness&&(t.bevelThickness=10),void 0===t.bevelSize&&(t.bevelSize=8),void 0===t.bevelEnabled&&(t.bevelEnabled=!1),super(i,t),this.type="TextGeometry"}}function pa(e){pt.call(this),this.type="ShadowMaterial",this.color=new ht(0),this.transparent=!0,this.setValues(e)}function ma(e){dn.call(this,e),this.type="RawShaderMaterial"}function ga(e){pt.call(this),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new ht(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ht(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new D(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.vertexTangents=!1,this.setValues(e)}function Ea(e){ga.call(this),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoat=0,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new D(1,1),this.clearcoatNormalMap=null,this.reflectivity=.5,Object.defineProperty(this,"ior",{get:function(){return(1+.4*this.reflectivity)/(1-.4*this.reflectivity)},set:function(e){this.reflectivity=M.clamp(2.5*(e-1)/(e+1),0,1)}}),this.sheen=null,this.transmission=0,this.transmissionMap=null,this.setValues(e)}function Ta(e){pt.call(this),this.type="MeshPhongMaterial",this.color=new ht(16777215),this.specular=new ht(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ht(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new D(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}function va(e){pt.call(this),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new ht(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ht(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new D(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}function Aa(e){pt.call(this),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new D(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}function Ra(e){pt.call(this),this.type="MeshLambertMaterial",this.color=new ht(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ht(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}function Ia(e){pt.call(this),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new ht(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new D(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}function Oa(e){pr.call(this),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}pa.prototype=Object.create(pt.prototype),pa.prototype.constructor=pa,pa.prototype.isShadowMaterial=!0,pa.prototype.copy=function(e){return pt.prototype.copy.call(this,e),this.color.copy(e.color),this},ma.prototype=Object.create(dn.prototype),ma.prototype.constructor=ma,ma.prototype.isRawShaderMaterial=!0,ga.prototype=Object.create(pt.prototype),ga.prototype.constructor=ga,ga.prototype.isMeshStandardMaterial=!0,ga.prototype.copy=function(e){return pt.prototype.copy.call(this,e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.vertexTangents=e.vertexTangents,this},Ea.prototype=Object.create(ga.prototype),Ea.prototype.constructor=Ea,Ea.prototype.isMeshPhysicalMaterial=!0,Ea.prototype.copy=function(e){return ga.prototype.copy.call(this,e),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.reflectivity=e.reflectivity,e.sheen?this.sheen=(this.sheen||new ht).copy(e.sheen):this.sheen=null,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this},Ta.prototype=Object.create(pt.prototype),Ta.prototype.constructor=Ta,Ta.prototype.isMeshPhongMaterial=!0,Ta.prototype.copy=function(e){return pt.prototype.copy.call(this,e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this},va.prototype=Object.create(pt.prototype),va.prototype.constructor=va,va.prototype.isMeshToonMaterial=!0,va.prototype.copy=function(e){return pt.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this},Aa.prototype=Object.create(pt.prototype),Aa.prototype.constructor=Aa,Aa.prototype.isMeshNormalMaterial=!0,Aa.prototype.copy=function(e){return pt.prototype.copy.call(this,e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this},Ra.prototype=Object.create(pt.prototype),Ra.prototype.constructor=Ra,Ra.prototype.isMeshLambertMaterial=!0,Ra.prototype.copy=function(e){return pt.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this},Ia.prototype=Object.create(pt.prototype),Ia.prototype.constructor=Ia,Ia.prototype.isMeshMatcapMaterial=!0,Ia.prototype.copy=function(e){return pt.prototype.copy.call(this,e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this},Oa.prototype=Object.create(pr.prototype),Oa.prototype.constructor=Oa,Oa.prototype.isLineDashedMaterial=!0,Oa.prototype.copy=function(e){return pr.prototype.copy.call(this,e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this};var Sa=Object.freeze({__proto__:null,ShadowMaterial:pa,SpriteMaterial:Do,RawShaderMaterial:ma,ShaderMaterial:dn,PointsMaterial:Nr,MeshPhysicalMaterial:Ea,MeshStandardMaterial:ga,MeshPhongMaterial:Ta,MeshToonMaterial:va,MeshNormalMaterial:Aa,MeshLambertMaterial:Ra,MeshDepthMaterial:Eo,MeshDistanceMaterial:To,MeshBasicMaterial:mt,MeshMatcapMaterial:Ia,LineDashedMaterial:Oa,LineBasicMaterial:pr,Material:pt});const Na={arraySlice:function(e,t,n){return Na.isTypedArray(e)?new e.constructor(e.subarray(t,void 0!==n?n:e.length)):e.slice(t,n)},convertArray:function(e,t,n){return!e||!n&&e.constructor===t?e:"number"==typeof t.BYTES_PER_ELEMENT?new t(e):Array.prototype.slice.call(e)},isTypedArray:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)},getKeyframeOrder:function(e){const t=e.length,n=new Array(t);for(let e=0;e!==t;++e)n[e]=e;return n.sort((function(t,n){return e[t]-e[n]})),n},sortedArray:function(e,t,n){const i=e.length,o=new e.constructor(i);for(let r=0,a=0;a!==i;++r){const i=n[r]*t;for(let n=0;n!==t;++n)o[a++]=e[i+n]}return o},flattenJSON:function(e,t,n,i){let o=1,r=e[0];for(;void 0!==r&&void 0===r[i];)r=e[o++];if(void 0===r)return;let a=r[i];if(void 0!==a)if(Array.isArray(a))do{a=r[i],void 0!==a&&(t.push(r.time),n.push.apply(n,a)),r=e[o++]}while(void 0!==r);else if(void 0!==a.toArray)do{a=r[i],void 0!==a&&(t.push(r.time),a.toArray(n,n.length)),r=e[o++]}while(void 0!==r);else do{a=r[i],void 0!==a&&(t.push(r.time),n.push(a)),r=e[o++]}while(void 0!==r)},subclip:function(e,t,n,i,o=30){const r=e.clone();r.name=t;const a=[];for(let e=0;e<r.tracks.length;++e){const t=r.tracks[e],s=t.getValueSize(),c=[],l=[];for(let e=0;e<t.times.length;++e){const r=t.times[e]*o;if(!(r<n||r>=i)){c.push(t.times[e]);for(let n=0;n<s;++n)l.push(t.values[e*s+n])}}0!==c.length&&(t.times=Na.convertArray(c,t.times.constructor),t.values=Na.convertArray(l,t.values.constructor),a.push(t))}r.tracks=a;let s=1/0;for(let e=0;e<r.tracks.length;++e)s>r.tracks[e].times[0]&&(s=r.tracks[e].times[0]);for(let e=0;e<r.tracks.length;++e)r.tracks[e].shift(-1*s);return r.resetDuration(),r},makeClipAdditive:function(e,t=0,n=e,i=30){i<=0&&(i=30);const o=n.tracks.length,r=t/i;for(let t=0;t<o;++t){const i=n.tracks[t],o=i.ValueTypeName;if("bool"===o||"string"===o)continue;const a=e.tracks.find((function(e){return e.name===i.name&&e.ValueTypeName===o}));if(void 0===a)continue;let s=0;const c=i.getValueSize();i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(s=c/3);let l=0;const d=a.getValueSize();a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(l=d/3);const h=i.times.length-1;let f;if(r<=i.times[0]){const e=s,t=c-s;f=Na.arraySlice(i.values,e,t)}else if(r>=i.times[h]){const e=h*c+s,t=e+c-s;f=Na.arraySlice(i.values,e,t)}else{const e=i.createInterpolant(),t=s,n=c-s;e.evaluate(r),f=Na.arraySlice(e.resultBuffer,t,n)}"quaternion"===o&&(new Y).fromArray(f).normalize().conjugate().toArray(f);const u=a.times.length;for(let e=0;e<u;++e){const t=e*d+l;if("quaternion"===o)Y.multiplyQuaternionsFlat(a.values,t,f,0,a.values,t);else{const e=d-2*l;for(let n=0;n<e;++n)a.values[t+n]-=f[n]}}}return e.blendMode=2501,e}};function ba(e,t,n,i){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=void 0!==i?i:new t.constructor(n),this.sampleValues=t,this.valueSize=n}function ya(e,t,n,i){ba.call(this,e,t,n,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0}function xa(e,t,n,i){ba.call(this,e,t,n,i)}function La(e,t,n,i){ba.call(this,e,t,n,i)}function _a(e,t,n,i){if(void 0===e)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===t||0===t.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=Na.convertArray(t,this.TimeBufferType),this.values=Na.convertArray(n,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}function wa(e,t,n){_a.call(this,e,t,n)}function Ca(e,t,n,i){_a.call(this,e,t,n,i)}function Ma(e,t,n,i){_a.call(this,e,t,n,i)}function Da(e,t,n,i){ba.call(this,e,t,n,i)}function Pa(e,t,n,i){_a.call(this,e,t,n,i)}function Fa(e,t,n,i){_a.call(this,e,t,n,i)}function Ha(e,t,n,i){_a.call(this,e,t,n,i)}function Ua(e,t=-1,n,i=2500){this.name=e,this.tracks=n,this.duration=t,this.blendMode=i,this.uuid=M.generateUUID(),this.duration<0&&this.resetDuration()}function Ba(e){if(void 0===e.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const t=function(e){switch(e.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Ma;case"vector":case"vector2":case"vector3":case"vector4":return Ha;case"color":return Ca;case"quaternion":return Pa;case"bool":case"boolean":return wa;case"string":return Fa}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+e)}(e.type);if(void 0===e.times){const t=[],n=[];Na.flattenJSON(e.keys,t,n,"value"),e.times=t,e.values=n}return void 0!==t.parse?t.parse(e):new t(e.name,e.times,e.values,e.interpolation)}Object.assign(ba.prototype,{evaluate:function(e){const t=this.parameterPositions;let n=this._cachedIndex,i=t[n],o=t[n-1];e:{t:{let r;n:{i:if(!(e<i)){for(let r=n+2;;){if(void 0===i){if(e<o)break i;return n=t.length,this._cachedIndex=n,this.afterEnd_(n-1,e,o)}if(n===r)break;if(o=i,i=t[++n],e<i)break t}r=t.length;break n}if(e>=o)break e;{const a=t[1];e<a&&(n=2,o=a);for(let r=n-2;;){if(void 0===o)return this._cachedIndex=0,this.beforeStart_(0,e,i);if(n===r)break;if(i=o,o=t[--n-1],e>=o)break t}r=n,n=0}}for(;n<r;){const i=n+r>>>1;e<t[i]?r=i:n=i+1}if(i=t[n],o=t[n-1],void 0===o)return this._cachedIndex=0,this.beforeStart_(0,e,i);if(void 0===i)return n=t.length,this._cachedIndex=n,this.afterEnd_(n-1,o,e)}this._cachedIndex=n,this.intervalChanged_(n,o,i)}return this.interpolate_(n,o,e,i)},settings:null,DefaultSettings_:{},getSettings_:function(){return this.settings||this.DefaultSettings_},copySampleValue_:function(e){const t=this.resultBuffer,n=this.sampleValues,i=this.valueSize,o=e*i;for(let e=0;e!==i;++e)t[e]=n[o+e];return t},interpolate_:function(){throw new Error("call to abstract method")},intervalChanged_:function(){}}),Object.assign(ba.prototype,{beforeStart_:ba.prototype.copySampleValue_,afterEnd_:ba.prototype.copySampleValue_}),ya.prototype=Object.assign(Object.create(ba.prototype),{constructor:ya,DefaultSettings_:{endingStart:R,endingEnd:R},intervalChanged_:function(e,t,n){const i=this.parameterPositions;let o=e-2,r=e+1,a=i[o],s=i[r];if(void 0===a)switch(this.getSettings_().endingStart){case I:o=e,a=2*t-n;break;case O:o=i.length-2,a=t+i[o]-i[o+1];break;default:o=e,a=n}if(void 0===s)switch(this.getSettings_().endingEnd){case I:r=e,s=2*n-t;break;case O:r=1,s=n+i[1]-i[0];break;default:r=e-1,s=t}const c=.5*(n-t),l=this.valueSize;this._weightPrev=c/(t-a),this._weightNext=c/(s-n),this._offsetPrev=o*l,this._offsetNext=r*l},interpolate_:function(e,t,n,i){const o=this.resultBuffer,r=this.sampleValues,a=this.valueSize,s=e*a,c=s-a,l=this._offsetPrev,d=this._offsetNext,h=this._weightPrev,f=this._weightNext,u=(n-t)/(i-t),p=u*u,m=p*u,g=-h*m+2*h*p-h*u,E=(1+h)*m+(-1.5-2*h)*p+(-.5+h)*u+1,T=(-1-f)*m+(1.5+f)*p+.5*u,v=f*m-f*p;for(let e=0;e!==a;++e)o[e]=g*r[l+e]+E*r[c+e]+T*r[s+e]+v*r[d+e];return o}}),xa.prototype=Object.assign(Object.create(ba.prototype),{constructor:xa,interpolate_:function(e,t,n,i){const o=this.resultBuffer,r=this.sampleValues,a=this.valueSize,s=e*a,c=s-a,l=(n-t)/(i-t),d=1-l;for(let e=0;e!==a;++e)o[e]=r[c+e]*d+r[s+e]*l;return o}}),La.prototype=Object.assign(Object.create(ba.prototype),{constructor:La,interpolate_:function(e){return this.copySampleValue_(e-1)}}),Object.assign(_a,{toJSON:function(e){const t=e.constructor;let n;if(void 0!==t.toJSON)n=t.toJSON(e);else{n={name:e.name,times:Na.convertArray(e.times,Array),values:Na.convertArray(e.values,Array)};const t=e.getInterpolation();t!==e.DefaultInterpolation&&(n.interpolation=t)}return n.type=e.ValueTypeName,n}}),Object.assign(_a.prototype,{constructor:_a,TimeBufferType:Float32Array,ValueBufferType:Float32Array,DefaultInterpolation:v,InterpolantFactoryMethodDiscrete:function(e){return new La(this.times,this.values,this.getValueSize(),e)},InterpolantFactoryMethodLinear:function(e){return new xa(this.times,this.values,this.getValueSize(),e)},InterpolantFactoryMethodSmooth:function(e){return new ya(this.times,this.values,this.getValueSize(),e)},setInterpolation:function(e){let t;switch(e){case T:t=this.InterpolantFactoryMethodDiscrete;break;case v:t=this.InterpolantFactoryMethodLinear;break;case A:t=this.InterpolantFactoryMethodSmooth}if(void 0===t){const t="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(e===this.DefaultInterpolation)throw new Error(t);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",t),this}return this.createInterpolant=t,this},getInterpolation:function(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return T;case this.InterpolantFactoryMethodLinear:return v;case this.InterpolantFactoryMethodSmooth:return A}},getValueSize:function(){return this.values.length/this.times.length},shift:function(e){if(0!==e){const t=this.times;for(let n=0,i=t.length;n!==i;++n)t[n]+=e}return this},scale:function(e){if(1!==e){const t=this.times;for(let n=0,i=t.length;n!==i;++n)t[n]*=e}return this},trim:function(e,t){const n=this.times,i=n.length;let o=0,r=i-1;for(;o!==i&&n[o]<e;)++o;for(;-1!==r&&n[r]>t;)--r;if(++r,0!==o||r!==i){o>=r&&(r=Math.max(r,1),o=r-1);const e=this.getValueSize();this.times=Na.arraySlice(n,o,r),this.values=Na.arraySlice(this.values,o*e,r*e)}return this},validate:function(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const n=this.times,i=this.values,o=n.length;0===o&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let r=null;for(let t=0;t!==o;t++){const i=n[t];if("number"==typeof i&&isNaN(i)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,t,i),e=!1;break}if(null!==r&&r>i){console.error("THREE.KeyframeTrack: Out of order keys.",this,t,i,r),e=!1;break}r=i}if(void 0!==i&&Na.isTypedArray(i))for(let t=0,n=i.length;t!==n;++t){const n=i[t];if(isNaN(n)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,t,n),e=!1;break}}return e},optimize:function(){const e=Na.arraySlice(this.times),t=Na.arraySlice(this.values),n=this.getValueSize(),i=this.getInterpolation()===A,o=e.length-1;let r=1;for(let a=1;a<o;++a){let o=!1;const s=e[a];if(s!==e[a+1]&&(1!==a||s!==e[0]))if(i)o=!0;else{const e=a*n,i=e-n,r=e+n;for(let a=0;a!==n;++a){const n=t[e+a];if(n!==t[i+a]||n!==t[r+a]){o=!0;break}}}if(o){if(a!==r){e[r]=e[a];const i=a*n,o=r*n;for(let e=0;e!==n;++e)t[o+e]=t[i+e]}++r}}if(o>0){e[r]=e[o];for(let e=o*n,i=r*n,a=0;a!==n;++a)t[i+a]=t[e+a];++r}return r!==e.length?(this.times=Na.arraySlice(e,0,r),this.values=Na.arraySlice(t,0,r*n)):(this.times=e,this.values=t),this},clone:function(){const e=Na.arraySlice(this.times,0),t=Na.arraySlice(this.values,0),n=new(0,this.constructor)(this.name,e,t);return n.createInterpolant=this.createInterpolant,n}}),wa.prototype=Object.assign(Object.create(_a.prototype),{constructor:wa,ValueTypeName:"bool",ValueBufferType:Array,DefaultInterpolation:T,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0}),Ca.prototype=Object.assign(Object.create(_a.prototype),{constructor:Ca,ValueTypeName:"color"}),Ma.prototype=Object.assign(Object.create(_a.prototype),{constructor:Ma,ValueTypeName:"number"}),Da.prototype=Object.assign(Object.create(ba.prototype),{constructor:Da,interpolate_:function(e,t,n,i){const o=this.resultBuffer,r=this.sampleValues,a=this.valueSize,s=(n-t)/(i-t);let c=e*a;for(let e=c+a;c!==e;c+=4)Y.slerpFlat(o,0,r,c-a,r,c,s);return o}}),Pa.prototype=Object.assign(Object.create(_a.prototype),{constructor:Pa,ValueTypeName:"quaternion",DefaultInterpolation:v,InterpolantFactoryMethodLinear:function(e){return new Da(this.times,this.values,this.getValueSize(),e)},InterpolantFactoryMethodSmooth:void 0}),Fa.prototype=Object.assign(Object.create(_a.prototype),{constructor:Fa,ValueTypeName:"string",ValueBufferType:Array,DefaultInterpolation:T,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0}),Ha.prototype=Object.assign(Object.create(_a.prototype),{constructor:Ha,ValueTypeName:"vector"}),Object.assign(Ua,{parse:function(e){const t=[],n=e.tracks,i=1/(e.fps||1);for(let e=0,o=n.length;e!==o;++e)t.push(Ba(n[e]).scale(i));const o=new Ua(e.name,e.duration,t,e.blendMode);return o.uuid=e.uuid,o},toJSON:function(e){const t=[],n=e.tracks,i={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let e=0,i=n.length;e!==i;++e)t.push(_a.toJSON(n[e]));return i},CreateFromMorphTargetSequence:function(e,t,n,i){const o=t.length,r=[];for(let e=0;e<o;e++){let a=[],s=[];a.push((e+o-1)%o,e,(e+1)%o),s.push(0,1,0);const c=Na.getKeyframeOrder(a);a=Na.sortedArray(a,1,c),s=Na.sortedArray(s,1,c),i||0!==a[0]||(a.push(o),s.push(s[0])),r.push(new Ma(".morphTargetInfluences["+t[e].name+"]",a,s).scale(1/n))}return new Ua(e,-1,r)},findByName:function(e,t){let n=e;if(!Array.isArray(e)){const t=e;n=t.geometry&&t.geometry.animations||t.animations}for(let e=0;e<n.length;e++)if(n[e].name===t)return n[e];return null},CreateClipsFromMorphTargetSequences:function(e,t,n){const i={},o=/^([\w-]*?)([\d]+)$/;for(let t=0,n=e.length;t<n;t++){const n=e[t],r=n.name.match(o);if(r&&r.length>1){const e=r[1];let t=i[e];t||(i[e]=t=[]),t.push(n)}}const r=[];for(const e in i)r.push(Ua.CreateFromMorphTargetSequence(e,i[e],t,n));return r},parseAnimation:function(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(e,t,n,i,o){if(0!==n.length){const r=[],a=[];Na.flattenJSON(n,r,a,i),0!==r.length&&o.push(new e(t,r,a))}},i=[],o=e.name||"default",r=e.fps||30,a=e.blendMode;let s=e.length||-1;const c=e.hierarchy||[];for(let e=0;e<c.length;e++){const o=c[e].keys;if(o&&0!==o.length)if(o[0].morphTargets){const e={};let t;for(t=0;t<o.length;t++)if(o[t].morphTargets)for(let n=0;n<o[t].morphTargets.length;n++)e[o[t].morphTargets[n]]=-1;for(const n in e){const e=[],r=[];for(let i=0;i!==o[t].morphTargets.length;++i){const i=o[t];e.push(i.time),r.push(i.morphTarget===n?1:0)}i.push(new Ma(".morphTargetInfluence["+n+"]",e,r))}s=e.length*(r||1)}else{const r=".bones["+t[e].name+"]";n(Ha,r+".position",o,"pos",i),n(Pa,r+".quaternion",o,"rot",i),n(Ha,r+".scale",o,"scl",i)}}return 0===i.length?null:new Ua(o,s,i,a)}}),Object.assign(Ua.prototype,{resetDuration:function(){let e=0;for(let t=0,n=this.tracks.length;t!==n;++t){const n=this.tracks[t];e=Math.max(e,n.times[n.times.length-1])}return this.duration=e,this},trim:function(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this},validate:function(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e},optimize:function(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this},clone:function(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new Ua(this.name,this.duration,e,this.blendMode)},toJSON:function(){return Ua.toJSON(this)}});const za={enabled:!1,files:{},add:function(e,t){!1!==this.enabled&&(this.files[e]=t)},get:function(e){if(!1!==this.enabled)return this.files[e]},remove:function(e){delete this.files[e]},clear:function(){this.files={}}};const Ga=new function(e,t,n){const i=this;let o,r=!1,a=0,s=0;const c=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=n,this.itemStart=function(e){s++,!1===r&&void 0!==i.onStart&&i.onStart(e,a,s),r=!0},this.itemEnd=function(e){a++,void 0!==i.onProgress&&i.onProgress(e,a,s),a===s&&(r=!1,void 0!==i.onLoad&&i.onLoad())},this.itemError=function(e){void 0!==i.onError&&i.onError(e)},this.resolveURL=function(e){return o?o(e):e},this.setURLModifier=function(e){return o=e,this},this.addHandler=function(e,t){return c.push(e,t),this},this.removeHandler=function(e){const t=c.indexOf(e);return-1!==t&&c.splice(t,2),this},this.getHandler=function(e){for(let t=0,n=c.length;t<n;t+=2){const n=c[t],i=c[t+1];if(n.global&&(n.lastIndex=0),n.test(e))return i}return null}};function Wa(e){this.manager=void 0!==e?e:Ga,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}Object.assign(Wa.prototype,{load:function(){},loadAsync:function(e,t){const n=this;return new Promise((function(i,o){n.load(e,i,t,o)}))},parse:function(){},setCrossOrigin:function(e){return this.crossOrigin=e,this},setWithCredentials:function(e){return this.withCredentials=e,this},setPath:function(e){return this.path=e,this},setResourcePath:function(e){return this.resourcePath=e,this},setRequestHeader:function(e){return this.requestHeader=e,this}});const Ya={};function Va(e){Wa.call(this,e)}function ka(e){Wa.call(this,e)}function ja(e){Wa.call(this,e)}function Xa(e){Wa.call(this,e)}function qa(e){Wa.call(this,e)}function Ka(e){Wa.call(this,e)}function Za(e){Wa.call(this,e)}function Ja(){this.type="Curve",this.arcLengthDivisions=200}function Qa(e,t,n,i,o,r,a,s){Ja.call(this),this.type="EllipseCurve",this.aX=e||0,this.aY=t||0,this.xRadius=n||1,this.yRadius=i||1,this.aStartAngle=o||0,this.aEndAngle=r||2*Math.PI,this.aClockwise=a||!1,this.aRotation=s||0}function $a(e,t,n,i,o,r){Qa.call(this,e,t,n,n,i,o,r),this.type="ArcCurve"}function es(){let e=0,t=0,n=0,i=0;function o(o,r,a,s){e=o,t=a,n=-3*o+3*r-2*a-s,i=2*o-2*r+a+s}return{initCatmullRom:function(e,t,n,i,r){o(t,n,r*(n-e),r*(i-t))},initNonuniformCatmullRom:function(e,t,n,i,r,a,s){let c=(t-e)/r-(n-e)/(r+a)+(n-t)/a,l=(n-t)/a-(i-t)/(a+s)+(i-n)/s;c*=a,l*=a,o(t,n,c,l)},calc:function(o){const r=o*o;return e+t*o+n*r+i*(r*o)}}}Va.prototype=Object.assign(Object.create(Wa.prototype),{constructor:Va,load:function(e,t,n,i){void 0===e&&(e=""),void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);const o=this,r=za.get(e);if(void 0!==r)return o.manager.itemStart(e),setTimeout((function(){t&&t(r),o.manager.itemEnd(e)}),0),r;if(void 0!==Ya[e])return void Ya[e].push({onLoad:t,onProgress:n,onError:i});const a=e.match(/^data:(.*?)(;base64)?,(.*)$/);let s;if(a){const n=a[1],r=!!a[2];let s=a[3];s=decodeURIComponent(s),r&&(s=atob(s));try{let i;const r=(this.responseType||"").toLowerCase();switch(r){case"arraybuffer":case"blob":const e=new Uint8Array(s.length);for(let t=0;t<s.length;t++)e[t]=s.charCodeAt(t);i="blob"===r?new Blob([e.buffer],{type:n}):e.buffer;break;case"document":const t=new DOMParser;i=t.parseFromString(s,n);break;case"json":i=JSON.parse(s);break;default:i=s}setTimeout((function(){t&&t(i),o.manager.itemEnd(e)}),0)}catch(t){setTimeout((function(){i&&i(t),o.manager.itemError(e),o.manager.itemEnd(e)}),0)}}else{Ya[e]=[],Ya[e].push({onLoad:t,onProgress:n,onError:i}),s=new XMLHttpRequest,s.open("GET",e,!0),s.addEventListener("load",(function(t){const n=this.response,i=Ya[e];if(delete Ya[e],200===this.status||0===this.status){0===this.status&&console.warn("THREE.FileLoader: HTTP Status 0 received."),za.add(e,n);for(let e=0,t=i.length;e<t;e++){const t=i[e];t.onLoad&&t.onLoad(n)}o.manager.itemEnd(e)}else{for(let e=0,n=i.length;e<n;e++){const n=i[e];n.onError&&n.onError(t)}o.manager.itemError(e),o.manager.itemEnd(e)}}),!1),s.addEventListener("progress",(function(t){const n=Ya[e];for(let e=0,i=n.length;e<i;e++){const i=n[e];i.onProgress&&i.onProgress(t)}}),!1),s.addEventListener("error",(function(t){const n=Ya[e];delete Ya[e];for(let e=0,i=n.length;e<i;e++){const i=n[e];i.onError&&i.onError(t)}o.manager.itemError(e),o.manager.itemEnd(e)}),!1),s.addEventListener("abort",(function(t){const n=Ya[e];delete Ya[e];for(let e=0,i=n.length;e<i;e++){const i=n[e];i.onError&&i.onError(t)}o.manager.itemError(e),o.manager.itemEnd(e)}),!1),void 0!==this.responseType&&(s.responseType=this.responseType),void 0!==this.withCredentials&&(s.withCredentials=this.withCredentials),s.overrideMimeType&&s.overrideMimeType(void 0!==this.mimeType?this.mimeType:"text/plain");for(const e in this.requestHeader)s.setRequestHeader(e,this.requestHeader[e]);s.send(null)}return o.manager.itemStart(e),s},setResponseType:function(e){return this.responseType=e,this},setMimeType:function(e){return this.mimeType=e,this}}),ka.prototype=Object.assign(Object.create(Wa.prototype),{constructor:ka,load:function(e,t,n,i){const o=this,r=new Va(o.manager);r.setPath(o.path),r.setRequestHeader(o.requestHeader),r.setWithCredentials(o.withCredentials),r.load(e,(function(n){try{t(o.parse(JSON.parse(n)))}catch(t){i?i(t):console.error(t),o.manager.itemError(e)}}),n,i)},parse:function(e){const t=[];for(let n=0;n<e.length;n++){const i=Ua.parse(e[n]);t.push(i)}return t}}),ja.prototype=Object.assign(Object.create(Wa.prototype),{constructor:ja,load:function(e,t,n,i){const o=this,r=[],a=new Mr,c=new Va(this.manager);c.setPath(this.path),c.setResponseType("arraybuffer"),c.setRequestHeader(this.requestHeader),c.setWithCredentials(o.withCredentials);let l=0;function d(d){c.load(e[d],(function(e){const n=o.parse(e,!0);r[d]={width:n.width,height:n.height,format:n.format,mipmaps:n.mipmaps},l+=1,6===l&&(1===n.mipmapCount&&(a.minFilter=s),a.image=r,a.format=n.format,a.needsUpdate=!0,t&&t(a))}),n,i)}if(Array.isArray(e))for(let t=0,n=e.length;t<n;++t)d(t);else c.load(e,(function(e){const n=o.parse(e,!0);if(n.isCubemap){const e=n.mipmaps.length/n.mipmapCount;for(let t=0;t<e;t++){r[t]={mipmaps:[]};for(let e=0;e<n.mipmapCount;e++)r[t].mipmaps.push(n.mipmaps[t*n.mipmapCount+e]),r[t].format=n.format,r[t].width=n.width,r[t].height=n.height}a.image=r}else a.image.width=n.width,a.image.height=n.height,a.mipmaps=n.mipmaps;1===n.mipmapCount&&(a.minFilter=s),a.format=n.format,a.needsUpdate=!0,t&&t(a)}),n,i);return a}}),Xa.prototype=Object.assign(Object.create(Wa.prototype),{constructor:Xa,load:function(e,t,n,i){void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);const o=this,r=za.get(e);if(void 0!==r)return o.manager.itemStart(e),setTimeout((function(){t&&t(r),o.manager.itemEnd(e)}),0),r;const a=document.createElementNS("http://www.w3.org/1999/xhtml","img");function s(){a.removeEventListener("load",s,!1),a.removeEventListener("error",c,!1),za.add(e,this),t&&t(this),o.manager.itemEnd(e)}function c(t){a.removeEventListener("load",s,!1),a.removeEventListener("error",c,!1),i&&i(t),o.manager.itemError(e),o.manager.itemEnd(e)}return a.addEventListener("load",s,!1),a.addEventListener("error",c,!1),"data:"!==e.substr(0,5)&&void 0!==this.crossOrigin&&(a.crossOrigin=this.crossOrigin),o.manager.itemStart(e),a.src=e,a}}),qa.prototype=Object.assign(Object.create(Wa.prototype),{constructor:qa,load:function(e,t,n,i){const o=new mn,r=new Xa(this.manager);r.setCrossOrigin(this.crossOrigin),r.setPath(this.path);let a=0;function s(n){r.load(e[n],(function(e){o.images[n]=e,a++,6===a&&(o.needsUpdate=!0,t&&t(o))}),void 0,i)}for(let t=0;t<e.length;++t)s(t);return o}}),Ka.prototype=Object.assign(Object.create(Wa.prototype),{constructor:Ka,load:function(e,t,n,i){const r=this,a=new En,l=new Va(this.manager);return l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setPath(this.path),l.setWithCredentials(r.withCredentials),l.load(e,(function(e){const n=r.parse(e);n&&(void 0!==n.image?a.image=n.image:void 0!==n.data&&(a.image.width=n.width,a.image.height=n.height,a.image.data=n.data),a.wrapS=void 0!==n.wrapS?n.wrapS:o,a.wrapT=void 0!==n.wrapT?n.wrapT:o,a.magFilter=void 0!==n.magFilter?n.magFilter:s,a.minFilter=void 0!==n.minFilter?n.minFilter:s,a.anisotropy=void 0!==n.anisotropy?n.anisotropy:1,void 0!==n.encoding&&(a.encoding=n.encoding),void 0!==n.flipY&&(a.flipY=n.flipY),void 0!==n.format&&(a.format=n.format),void 0!==n.type&&(a.type=n.type),void 0!==n.mipmaps&&(a.mipmaps=n.mipmaps,a.minFilter=c),1===n.mipmapCount&&(a.minFilter=s),a.needsUpdate=!0,t&&t(a,n))}),n,i),a}}),Za.prototype=Object.assign(Object.create(Wa.prototype),{constructor:Za,load:function(e,t,n,i){const o=new B,r=new Xa(this.manager);return r.setCrossOrigin(this.crossOrigin),r.setPath(this.path),r.load(e,(function(n){o.image=n;const i=e.search(/\.jpe?g($|\?)/i)>0||0===e.search(/^data\:image\/jpeg/);o.format=i?p:m,o.needsUpdate=!0,void 0!==t&&t(o)}),n,i),o}}),Object.assign(Ja.prototype,{getPoint:function(){return console.warn("THREE.Curve: .getPoint() not implemented."),null},getPointAt:function(e,t){const n=this.getUtoTmapping(e);return this.getPoint(n,t)},getPoints:function(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return t},getSpacedPoints:function(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPointAt(n/e));return t},getLength:function(){const e=this.getLengths();return e[e.length-1]},getLengths:function(e){if(void 0===e&&(e=this.arcLengthDivisions),this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let n,i=this.getPoint(0),o=0;t.push(0);for(let r=1;r<=e;r++)n=this.getPoint(r/e),o+=n.distanceTo(i),t.push(o),i=n;return this.cacheArcLengths=t,t},updateArcLengths:function(){this.needsUpdate=!0,this.getLengths()},getUtoTmapping:function(e,t){const n=this.getLengths();let i=0;const o=n.length;let r;r=t||e*n[o-1];let a,s=0,c=o-1;for(;s<=c;)if(i=Math.floor(s+(c-s)/2),a=n[i]-r,a<0)s=i+1;else{if(!(a>0)){c=i;break}c=i-1}if(i=c,n[i]===r)return i/(o-1);const l=n[i];return(i+(r-l)/(n[i+1]-l))/(o-1)},getTangent:function(e,t){const n=1e-4;let i=e-n,o=e+n;i<0&&(i=0),o>1&&(o=1);const r=this.getPoint(i),a=this.getPoint(o),s=t||(r.isVector2?new D:new V);return s.copy(a).sub(r).normalize(),s},getTangentAt:function(e,t){const n=this.getUtoTmapping(e);return this.getTangent(n,t)},computeFrenetFrames:function(e,t){const n=new V,i=[],o=[],r=[],a=new V,s=new Te;for(let t=0;t<=e;t++){const n=t/e;i[t]=this.getTangentAt(n,new V),i[t].normalize()}o[0]=new V,r[0]=new V;let c=Number.MAX_VALUE;const l=Math.abs(i[0].x),d=Math.abs(i[0].y),h=Math.abs(i[0].z);l<=c&&(c=l,n.set(1,0,0)),d<=c&&(c=d,n.set(0,1,0)),h<=c&&n.set(0,0,1),a.crossVectors(i[0],n).normalize(),o[0].crossVectors(i[0],a),r[0].crossVectors(i[0],o[0]);for(let t=1;t<=e;t++){if(o[t]=o[t-1].clone(),r[t]=r[t-1].clone(),a.crossVectors(i[t-1],i[t]),a.length()>Number.EPSILON){a.normalize();const e=Math.acos(M.clamp(i[t-1].dot(i[t]),-1,1));o[t].applyMatrix4(s.makeRotationAxis(a,e))}r[t].crossVectors(i[t],o[t])}if(!0===t){let t=Math.acos(M.clamp(o[0].dot(o[e]),-1,1));t/=e,i[0].dot(a.crossVectors(o[0],o[e]))>0&&(t=-t);for(let n=1;n<=e;n++)o[n].applyMatrix4(s.makeRotationAxis(i[n],t*n)),r[n].crossVectors(i[n],o[n])}return{tangents:i,normals:o,binormals:r}},clone:function(){return(new this.constructor).copy(this)},copy:function(e){return this.arcLengthDivisions=e.arcLengthDivisions,this},toJSON:function(){const e={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e},fromJSON:function(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}),Qa.prototype=Object.create(Ja.prototype),Qa.prototype.constructor=Qa,Qa.prototype.isEllipseCurve=!0,Qa.prototype.getPoint=function(e,t){const n=t||new D,i=2*Math.PI;let o=this.aEndAngle-this.aStartAngle;const r=Math.abs(o)<Number.EPSILON;for(;o<0;)o+=i;for(;o>i;)o-=i;o<Number.EPSILON&&(o=r?0:i),!0!==this.aClockwise||r||(o===i?o=-i:o-=i);const a=this.aStartAngle+e*o;let s=this.aX+this.xRadius*Math.cos(a),c=this.aY+this.yRadius*Math.sin(a);if(0!==this.aRotation){const e=Math.cos(this.aRotation),t=Math.sin(this.aRotation),n=s-this.aX,i=c-this.aY;s=n*e-i*t+this.aX,c=n*t+i*e+this.aY}return n.set(s,c)},Qa.prototype.copy=function(e){return Ja.prototype.copy.call(this,e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this},Qa.prototype.toJSON=function(){const e=Ja.prototype.toJSON.call(this);return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e},Qa.prototype.fromJSON=function(e){return Ja.prototype.fromJSON.call(this,e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this},$a.prototype=Object.create(Qa.prototype),$a.prototype.constructor=$a,$a.prototype.isArcCurve=!0;const ts=new V,ns=new es,is=new es,os=new es;function rs(e=[],t=!1,n="centripetal",i=.5){Ja.call(this),this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=n,this.tension=i}function as(e,t,n,i,o){const r=.5*(i-t),a=.5*(o-n),s=e*e;return(2*n-2*i+r+a)*(e*s)+(-3*n+3*i-2*r-a)*s+r*e+n}function ss(e,t,n,i){return function(e,t){const n=1-e;return n*n*t}(e,t)+function(e,t){return 2*(1-e)*e*t}(e,n)+function(e,t){return e*e*t}(e,i)}function cs(e,t,n,i,o){return function(e,t){const n=1-e;return n*n*n*t}(e,t)+function(e,t){const n=1-e;return 3*n*n*e*t}(e,n)+function(e,t){return 3*(1-e)*e*e*t}(e,i)+function(e,t){return e*e*e*t}(e,o)}function ls(e=new D,t=new D,n=new D,i=new D){Ja.call(this),this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=n,this.v3=i}function ds(e=new V,t=new V,n=new V,i=new V){Ja.call(this),this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=n,this.v3=i}function hs(e=new D,t=new D){Ja.call(this),this.type="LineCurve",this.v1=e,this.v2=t}function fs(e=new V,t=new V){Ja.call(this),this.type="LineCurve3",this.v1=e,this.v2=t}function us(e=new D,t=new D,n=new D){Ja.call(this),this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=n}function ps(e=new V,t=new V,n=new V){Ja.call(this),this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=n}function ms(e=[]){Ja.call(this),this.type="SplineCurve",this.points=e}rs.prototype=Object.create(Ja.prototype),rs.prototype.constructor=rs,rs.prototype.isCatmullRomCurve3=!0,rs.prototype.getPoint=function(e,t=new V){const n=t,i=this.points,o=i.length,r=(o-(this.closed?0:1))*e;let a,s,c=Math.floor(r),l=r-c;this.closed?c+=c>0?0:(Math.floor(Math.abs(c)/o)+1)*o:0===l&&c===o-1&&(c=o-2,l=1),this.closed||c>0?a=i[(c-1)%o]:(ts.subVectors(i[0],i[1]).add(i[0]),a=ts);const d=i[c%o],h=i[(c+1)%o];if(this.closed||c+2<o?s=i[(c+2)%o]:(ts.subVectors(i[o-1],i[o-2]).add(i[o-1]),s=ts),"centripetal"===this.curveType||"chordal"===this.curveType){const e="chordal"===this.curveType?.5:.25;let t=Math.pow(a.distanceToSquared(d),e),n=Math.pow(d.distanceToSquared(h),e),i=Math.pow(h.distanceToSquared(s),e);n<1e-4&&(n=1),t<1e-4&&(t=n),i<1e-4&&(i=n),ns.initNonuniformCatmullRom(a.x,d.x,h.x,s.x,t,n,i),is.initNonuniformCatmullRom(a.y,d.y,h.y,s.y,t,n,i),os.initNonuniformCatmullRom(a.z,d.z,h.z,s.z,t,n,i)}else"catmullrom"===this.curveType&&(ns.initCatmullRom(a.x,d.x,h.x,s.x,this.tension),is.initCatmullRom(a.y,d.y,h.y,s.y,this.tension),os.initCatmullRom(a.z,d.z,h.z,s.z,this.tension));return n.set(ns.calc(l),is.calc(l),os.calc(l)),n},rs.prototype.copy=function(e){Ja.prototype.copy.call(this,e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const n=e.points[t];this.points.push(n.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this},rs.prototype.toJSON=function(){const e=Ja.prototype.toJSON.call(this);e.points=[];for(let t=0,n=this.points.length;t<n;t++){const n=this.points[t];e.points.push(n.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e},rs.prototype.fromJSON=function(e){Ja.prototype.fromJSON.call(this,e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const n=e.points[t];this.points.push((new V).fromArray(n))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this},ls.prototype=Object.create(Ja.prototype),ls.prototype.constructor=ls,ls.prototype.isCubicBezierCurve=!0,ls.prototype.getPoint=function(e,t=new D){const n=t,i=this.v0,o=this.v1,r=this.v2,a=this.v3;return n.set(cs(e,i.x,o.x,r.x,a.x),cs(e,i.y,o.y,r.y,a.y)),n},ls.prototype.copy=function(e){return Ja.prototype.copy.call(this,e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this},ls.prototype.toJSON=function(){const e=Ja.prototype.toJSON.call(this);return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e},ls.prototype.fromJSON=function(e){return Ja.prototype.fromJSON.call(this,e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this},ds.prototype=Object.create(Ja.prototype),ds.prototype.constructor=ds,ds.prototype.isCubicBezierCurve3=!0,ds.prototype.getPoint=function(e,t=new V){const n=t,i=this.v0,o=this.v1,r=this.v2,a=this.v3;return n.set(cs(e,i.x,o.x,r.x,a.x),cs(e,i.y,o.y,r.y,a.y),cs(e,i.z,o.z,r.z,a.z)),n},ds.prototype.copy=function(e){return Ja.prototype.copy.call(this,e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this},ds.prototype.toJSON=function(){const e=Ja.prototype.toJSON.call(this);return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e},ds.prototype.fromJSON=function(e){return Ja.prototype.fromJSON.call(this,e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this},hs.prototype=Object.create(Ja.prototype),hs.prototype.constructor=hs,hs.prototype.isLineCurve=!0,hs.prototype.getPoint=function(e,t=new D){const n=t;return 1===e?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n},hs.prototype.getPointAt=function(e,t){return this.getPoint(e,t)},hs.prototype.getTangent=function(e,t){const n=t||new D;return n.copy(this.v2).sub(this.v1).normalize(),n},hs.prototype.copy=function(e){return Ja.prototype.copy.call(this,e),this.v1.copy(e.v1),this.v2.copy(e.v2),this},hs.prototype.toJSON=function(){const e=Ja.prototype.toJSON.call(this);return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e},hs.prototype.fromJSON=function(e){return Ja.prototype.fromJSON.call(this,e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this},fs.prototype=Object.create(Ja.prototype),fs.prototype.constructor=fs,fs.prototype.isLineCurve3=!0,fs.prototype.getPoint=function(e,t=new V){const n=t;return 1===e?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n},fs.prototype.getPointAt=function(e,t){return this.getPoint(e,t)},fs.prototype.copy=function(e){return Ja.prototype.copy.call(this,e),this.v1.copy(e.v1),this.v2.copy(e.v2),this},fs.prototype.toJSON=function(){const e=Ja.prototype.toJSON.call(this);return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e},fs.prototype.fromJSON=function(e){return Ja.prototype.fromJSON.call(this,e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this},us.prototype=Object.create(Ja.prototype),us.prototype.constructor=us,us.prototype.isQuadraticBezierCurve=!0,us.prototype.getPoint=function(e,t=new D){const n=t,i=this.v0,o=this.v1,r=this.v2;return n.set(ss(e,i.x,o.x,r.x),ss(e,i.y,o.y,r.y)),n},us.prototype.copy=function(e){return Ja.prototype.copy.call(this,e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this},us.prototype.toJSON=function(){const e=Ja.prototype.toJSON.call(this);return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e},us.prototype.fromJSON=function(e){return Ja.prototype.fromJSON.call(this,e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this},ps.prototype=Object.create(Ja.prototype),ps.prototype.constructor=ps,ps.prototype.isQuadraticBezierCurve3=!0,ps.prototype.getPoint=function(e,t=new V){const n=t,i=this.v0,o=this.v1,r=this.v2;return n.set(ss(e,i.x,o.x,r.x),ss(e,i.y,o.y,r.y),ss(e,i.z,o.z,r.z)),n},ps.prototype.copy=function(e){return Ja.prototype.copy.call(this,e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this},ps.prototype.toJSON=function(){const e=Ja.prototype.toJSON.call(this);return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e},ps.prototype.fromJSON=function(e){return Ja.prototype.fromJSON.call(this,e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this},ms.prototype=Object.create(Ja.prototype),ms.prototype.constructor=ms,ms.prototype.isSplineCurve=!0,ms.prototype.getPoint=function(e,t=new D){const n=t,i=this.points,o=(i.length-1)*e,r=Math.floor(o),a=o-r,s=i[0===r?r:r-1],c=i[r],l=i[r>i.length-2?i.length-1:r+1],d=i[r>i.length-3?i.length-1:r+2];return n.set(as(a,s.x,c.x,l.x,d.x),as(a,s.y,c.y,l.y,d.y)),n},ms.prototype.copy=function(e){Ja.prototype.copy.call(this,e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const n=e.points[t];this.points.push(n.clone())}return this},ms.prototype.toJSON=function(){const e=Ja.prototype.toJSON.call(this);e.points=[];for(let t=0,n=this.points.length;t<n;t++){const n=this.points[t];e.points.push(n.toArray())}return e},ms.prototype.fromJSON=function(e){Ja.prototype.fromJSON.call(this,e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const n=e.points[t];this.points.push((new D).fromArray(n))}return this};var gs=Object.freeze({__proto__:null,ArcCurve:$a,CatmullRomCurve3:rs,CubicBezierCurve:ls,CubicBezierCurve3:ds,EllipseCurve:Qa,LineCurve:hs,LineCurve3:fs,QuadraticBezierCurve:us,QuadraticBezierCurve3:ps,SplineCurve:ms});function Es(){Ja.call(this),this.type="CurvePath",this.curves=[],this.autoClose=!1}function Ts(e){Es.call(this),this.type="Path",this.currentPoint=new D,e&&this.setFromPoints(e)}function vs(e){Ts.call(this,e),this.uuid=M.generateUUID(),this.type="Shape",this.holes=[]}function As(e,t=1){Ye.call(this),this.type="Light",this.color=new ht(e),this.intensity=t}function Rs(e,t,n){As.call(this,e,n),this.type="HemisphereLight",this.position.copy(Ye.DefaultUp),this.updateMatrix(),this.groundColor=new ht(t)}function Is(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.mapSize=new D(512,512),this.map=null,this.mapPass=null,this.matrix=new Te,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new An,this._frameExtents=new D(1,1),this._viewportCount=1,this._viewports=[new G(0,0,1,1)]}function Os(){Is.call(this,new fn(50,1,.5,500)),this.focus=1}function Ss(e,t,n,i,o,r){As.call(this,e,t),this.type="SpotLight",this.position.copy(Ye.DefaultUp),this.updateMatrix(),this.target=new Ye,Object.defineProperty(this,"power",{get:function(){return this.intensity*Math.PI},set:function(e){this.intensity=e/Math.PI}}),this.distance=void 0!==n?n:0,this.angle=void 0!==i?i:Math.PI/3,this.penumbra=void 0!==o?o:0,this.decay=void 0!==r?r:1,this.shadow=new Os}function Ns(){Is.call(this,new fn(90,1,.5,500)),this._frameExtents=new D(4,2),this._viewportCount=6,this._viewports=[new G(2,1,1,1),new G(0,1,1,1),new G(3,1,1,1),new G(1,1,1,1),new G(3,0,1,1),new G(1,0,1,1)],this._cubeDirections=[new V(1,0,0),new V(-1,0,0),new V(0,0,1),new V(0,0,-1),new V(0,1,0),new V(0,-1,0)],this._cubeUps=[new V(0,1,0),new V(0,1,0),new V(0,1,0),new V(0,1,0),new V(0,0,1),new V(0,0,-1)]}function bs(e,t,n,i){As.call(this,e,t),this.type="PointLight",Object.defineProperty(this,"power",{get:function(){return 4*this.intensity*Math.PI},set:function(e){this.intensity=e/(4*Math.PI)}}),this.distance=void 0!==n?n:0,this.decay=void 0!==i?i:1,this.shadow=new Ns}function ys(e=-1,t=1,n=1,i=-1,o=.1,r=2e3){hn.call(this),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=n,this.bottom=i,this.near=o,this.far=r,this.updateProjectionMatrix()}function xs(){Is.call(this,new ys(-5,5,5,-5,.5,500))}function Ls(e,t){As.call(this,e,t),this.type="DirectionalLight",this.position.copy(Ye.DefaultUp),this.updateMatrix(),this.target=new Ye,this.shadow=new xs}function _s(e,t){As.call(this,e,t),this.type="AmbientLight"}function ws(e,t,n,i){As.call(this,e,t),this.type="RectAreaLight",this.width=void 0!==n?n:10,this.height=void 0!==i?i:10}Es.prototype=Object.assign(Object.create(Ja.prototype),{constructor:Es,add:function(e){this.curves.push(e)},closePath:function(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);e.equals(t)||this.curves.push(new hs(t,e))},getPoint:function(e){const t=e*this.getLength(),n=this.getCurveLengths();let i=0;for(;i<n.length;){if(n[i]>=t){const e=n[i]-t,o=this.curves[i],r=o.getLength(),a=0===r?0:1-e/r;return o.getPointAt(a)}i++}return null},getLength:function(){const e=this.getCurveLengths();return e[e.length-1]},updateArcLengths:function(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()},getCurveLengths:function(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let n=0,i=this.curves.length;n<i;n++)t+=this.curves[n].getLength(),e.push(t);return this.cacheLengths=e,e},getSpacedPoints:function(e=40){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return this.autoClose&&t.push(t[0]),t},getPoints:function(e=12){const t=[];let n;for(let i=0,o=this.curves;i<o.length;i++){const r=o[i],a=r&&r.isEllipseCurve?2*e:r&&(r.isLineCurve||r.isLineCurve3)?1:r&&r.isSplineCurve?e*r.points.length:e,s=r.getPoints(a);for(let e=0;e<s.length;e++){const i=s[e];n&&n.equals(i)||(t.push(i),n=i)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t},copy:function(e){Ja.prototype.copy.call(this,e),this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const n=e.curves[t];this.curves.push(n.clone())}return this.autoClose=e.autoClose,this},toJSON:function(){const e=Ja.prototype.toJSON.call(this);e.autoClose=this.autoClose,e.curves=[];for(let t=0,n=this.curves.length;t<n;t++){const n=this.curves[t];e.curves.push(n.toJSON())}return e},fromJSON:function(e){Ja.prototype.fromJSON.call(this,e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const n=e.curves[t];this.curves.push((new gs[n.type]).fromJSON(n))}return this}}),Ts.prototype=Object.assign(Object.create(Es.prototype),{constructor:Ts,setFromPoints:function(e){this.moveTo(e[0].x,e[0].y);for(let t=1,n=e.length;t<n;t++)this.lineTo(e[t].x,e[t].y);return this},moveTo:function(e,t){return this.currentPoint.set(e,t),this},lineTo:function(e,t){const n=new hs(this.currentPoint.clone(),new D(e,t));return this.curves.push(n),this.currentPoint.set(e,t),this},quadraticCurveTo:function(e,t,n,i){const o=new us(this.currentPoint.clone(),new D(e,t),new D(n,i));return this.curves.push(o),this.currentPoint.set(n,i),this},bezierCurveTo:function(e,t,n,i,o,r){const a=new ls(this.currentPoint.clone(),new D(e,t),new D(n,i),new D(o,r));return this.curves.push(a),this.currentPoint.set(o,r),this},splineThru:function(e){const t=new ms([this.currentPoint.clone()].concat(e));return this.curves.push(t),this.currentPoint.copy(e[e.length-1]),this},arc:function(e,t,n,i,o,r){const a=this.currentPoint.x,s=this.currentPoint.y;return this.absarc(e+a,t+s,n,i,o,r),this},absarc:function(e,t,n,i,o,r){return this.absellipse(e,t,n,n,i,o,r),this},ellipse:function(e,t,n,i,o,r,a,s){const c=this.currentPoint.x,l=this.currentPoint.y;return this.absellipse(e+c,t+l,n,i,o,r,a,s),this},absellipse:function(e,t,n,i,o,r,a,s){const c=new Qa(e,t,n,i,o,r,a,s);if(this.curves.length>0){const e=c.getPoint(0);e.equals(this.currentPoint)||this.lineTo(e.x,e.y)}this.curves.push(c);const l=c.getPoint(1);return this.currentPoint.copy(l),this},copy:function(e){return Es.prototype.copy.call(this,e),this.currentPoint.copy(e.currentPoint),this},toJSON:function(){const e=Es.prototype.toJSON.call(this);return e.currentPoint=this.currentPoint.toArray(),e},fromJSON:function(e){return Es.prototype.fromJSON.call(this,e),this.currentPoint.fromArray(e.currentPoint),this}}),vs.prototype=Object.assign(Object.create(Ts.prototype),{constructor:vs,getPointsHoles:function(e){const t=[];for(let n=0,i=this.holes.length;n<i;n++)t[n]=this.holes[n].getPoints(e);return t},extractPoints:function(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}},copy:function(e){Ts.prototype.copy.call(this,e),this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const n=e.holes[t];this.holes.push(n.clone())}return this},toJSON:function(){const e=Ts.prototype.toJSON.call(this);e.uuid=this.uuid,e.holes=[];for(let t=0,n=this.holes.length;t<n;t++){const n=this.holes[t];e.holes.push(n.toJSON())}return e},fromJSON:function(e){Ts.prototype.fromJSON.call(this,e),this.uuid=e.uuid,this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const n=e.holes[t];this.holes.push((new Ts).fromJSON(n))}return this}}),As.prototype=Object.assign(Object.create(Ye.prototype),{constructor:As,isLight:!0,copy:function(e){return Ye.prototype.copy.call(this,e),this.color.copy(e.color),this.intensity=e.intensity,this},toJSON:function(e){const t=Ye.prototype.toJSON.call(this,e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,void 0!==this.groundColor&&(t.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(t.object.distance=this.distance),void 0!==this.angle&&(t.object.angle=this.angle),void 0!==this.decay&&(t.object.decay=this.decay),void 0!==this.penumbra&&(t.object.penumbra=this.penumbra),void 0!==this.shadow&&(t.object.shadow=this.shadow.toJSON()),t}}),Rs.prototype=Object.assign(Object.create(As.prototype),{constructor:Rs,isHemisphereLight:!0,copy:function(e){return As.prototype.copy.call(this,e),this.groundColor.copy(e.groundColor),this}}),Object.assign(Is.prototype,{_projScreenMatrix:new Te,_lightPositionWorld:new V,_lookTarget:new V,getViewportCount:function(){return this._viewportCount},getFrustum:function(){return this._frustum},updateMatrices:function(e){const t=this.camera,n=this.matrix,i=this._projScreenMatrix,o=this._lookTarget,r=this._lightPositionWorld;r.setFromMatrixPosition(e.matrixWorld),t.position.copy(r),o.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(o),t.updateMatrixWorld(),i.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(i),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(t.projectionMatrix),n.multiply(t.matrixWorldInverse)},getViewport:function(e){return this._viewports[e]},getFrameExtents:function(){return this._frameExtents},copy:function(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this},clone:function(){return(new this.constructor).copy(this)},toJSON:function(){const e={};return 0!==this.bias&&(e.bias=this.bias),0!==this.normalBias&&(e.normalBias=this.normalBias),1!==this.radius&&(e.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}),Os.prototype=Object.assign(Object.create(Is.prototype),{constructor:Os,isSpotLightShadow:!0,updateMatrices:function(e){const t=this.camera,n=2*M.RAD2DEG*e.angle*this.focus,i=this.mapSize.width/this.mapSize.height,o=e.distance||t.far;n===t.fov&&i===t.aspect&&o===t.far||(t.fov=n,t.aspect=i,t.far=o,t.updateProjectionMatrix()),Is.prototype.updateMatrices.call(this,e)}}),Ss.prototype=Object.assign(Object.create(As.prototype),{constructor:Ss,isSpotLight:!0,copy:function(e){return As.prototype.copy.call(this,e),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}),Ns.prototype=Object.assign(Object.create(Is.prototype),{constructor:Ns,isPointLightShadow:!0,updateMatrices:function(e,t=0){const n=this.camera,i=this.matrix,o=this._lightPositionWorld,r=this._lookTarget,a=this._projScreenMatrix;o.setFromMatrixPosition(e.matrixWorld),n.position.copy(o),r.copy(n.position),r.add(this._cubeDirections[t]),n.up.copy(this._cubeUps[t]),n.lookAt(r),n.updateMatrixWorld(),i.makeTranslation(-o.x,-o.y,-o.z),a.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(a)}}),bs.prototype=Object.assign(Object.create(As.prototype),{constructor:bs,isPointLight:!0,copy:function(e){return As.prototype.copy.call(this,e),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}),ys.prototype=Object.assign(Object.create(hn.prototype),{constructor:ys,isOrthographicCamera:!0,copy:function(e,t){return hn.prototype.copy.call(this,e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=null===e.view?null:Object.assign({},e.view),this},setViewOffset:function(e,t,n,i,o,r){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=i,this.view.width=o,this.view.height=r,this.updateProjectionMatrix()},clearViewOffset:function(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let o=n-e,r=n+e,a=i+t,s=i-t;if(null!==this.view&&this.view.enabled){const e=(this.right-this.left)/this.view.fullWidth/this.zoom,t=(this.top-this.bottom)/this.view.fullHeight/this.zoom;o+=e*this.view.offsetX,r=o+e*this.view.width,a-=t*this.view.offsetY,s=a-t*this.view.height}this.projectionMatrix.makeOrthographic(o,r,a,s,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()},toJSON:function(e){const t=Ye.prototype.toJSON.call(this,e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,null!==this.view&&(t.object.view=Object.assign({},this.view)),t}}),xs.prototype=Object.assign(Object.create(Is.prototype),{constructor:xs,isDirectionalLightShadow:!0,updateMatrices:function(e){Is.prototype.updateMatrices.call(this,e)}}),Ls.prototype=Object.assign(Object.create(As.prototype),{constructor:Ls,isDirectionalLight:!0,copy:function(e){return As.prototype.copy.call(this,e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}),_s.prototype=Object.assign(Object.create(As.prototype),{constructor:_s,isAmbientLight:!0}),ws.prototype=Object.assign(Object.create(As.prototype),{constructor:ws,isRectAreaLight:!0,copy:function(e){return As.prototype.copy.call(this,e),this.width=e.width,this.height=e.height,this},toJSON:function(e){const t=As.prototype.toJSON.call(this,e);return t.object.width=this.width,t.object.height=this.height,t}});class Cs{constructor(){Object.defineProperty(this,"isSphericalHarmonics3",{value:!0}),this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new V)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const n=e.x,i=e.y,o=e.z,r=this.coefficients;return t.copy(r[0]).multiplyScalar(.282095),t.addScaledVector(r[1],.488603*i),t.addScaledVector(r[2],.488603*o),t.addScaledVector(r[3],.488603*n),t.addScaledVector(r[4],n*i*1.092548),t.addScaledVector(r[5],i*o*1.092548),t.addScaledVector(r[6],.315392*(3*o*o-1)),t.addScaledVector(r[7],n*o*1.092548),t.addScaledVector(r[8],.546274*(n*n-i*i)),t}getIrradianceAt(e,t){const n=e.x,i=e.y,o=e.z,r=this.coefficients;return t.copy(r[0]).multiplyScalar(.886227),t.addScaledVector(r[1],1.023328*i),t.addScaledVector(r[2],1.023328*o),t.addScaledVector(r[3],1.023328*n),t.addScaledVector(r[4],.858086*n*i),t.addScaledVector(r[5],.858086*i*o),t.addScaledVector(r[6],.743125*o*o-.247708),t.addScaledVector(r[7],.858086*n*o),t.addScaledVector(r[8],.429043*(n*n-i*i)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(e.coefficients[n],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let n=0;n<9;n++)this.coefficients[n].lerp(e.coefficients[n],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return(new this.constructor).copy(this)}fromArray(e,t=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].fromArray(e,t+3*i);return this}toArray(e=[],t=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].toArray(e,t+3*i);return e}static getBasisAt(e,t){const n=e.x,i=e.y,o=e.z;t[0]=.282095,t[1]=.488603*i,t[2]=.488603*o,t[3]=.488603*n,t[4]=1.092548*n*i,t[5]=1.092548*i*o,t[6]=.315392*(3*o*o-1),t[7]=1.092548*n*o,t[8]=.546274*(n*n-i*i)}}function Ms(e,t){As.call(this,void 0,t),this.type="LightProbe",this.sh=void 0!==e?e:new Cs}function Ds(e){Wa.call(this,e),this.textures={}}Ms.prototype=Object.assign(Object.create(As.prototype),{constructor:Ms,isLightProbe:!0,copy:function(e){return As.prototype.copy.call(this,e),this.sh.copy(e.sh),this},fromJSON:function(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this},toJSON:function(e){const t=As.prototype.toJSON.call(this,e);return t.object.sh=this.sh.toArray(),t}}),Ds.prototype=Object.assign(Object.create(Wa.prototype),{constructor:Ds,load:function(e,t,n,i){const o=this,r=new Va(o.manager);r.setPath(o.path),r.setRequestHeader(o.requestHeader),r.setWithCredentials(o.withCredentials),r.load(e,(function(n){try{t(o.parse(JSON.parse(n)))}catch(t){i?i(t):console.error(t),o.manager.itemError(e)}}),n,i)},parse:function(e){const t=this.textures;function n(e){return void 0===t[e]&&console.warn("THREE.MaterialLoader: Undefined texture",e),t[e]}const i=new Sa[e.type];if(void 0!==e.uuid&&(i.uuid=e.uuid),void 0!==e.name&&(i.name=e.name),void 0!==e.color&&void 0!==i.color&&i.color.setHex(e.color),void 0!==e.roughness&&(i.roughness=e.roughness),void 0!==e.metalness&&(i.metalness=e.metalness),void 0!==e.sheen&&(i.sheen=(new ht).setHex(e.sheen)),void 0!==e.emissive&&void 0!==i.emissive&&i.emissive.setHex(e.emissive),void 0!==e.specular&&void 0!==i.specular&&i.specular.setHex(e.specular),void 0!==e.shininess&&(i.shininess=e.shininess),void 0!==e.clearcoat&&(i.clearcoat=e.clearcoat),void 0!==e.clearcoatRoughness&&(i.clearcoatRoughness=e.clearcoatRoughness),void 0!==e.fog&&(i.fog=e.fog),void 0!==e.flatShading&&(i.flatShading=e.flatShading),void 0!==e.blending&&(i.blending=e.blending),void 0!==e.combine&&(i.combine=e.combine),void 0!==e.side&&(i.side=e.side),void 0!==e.opacity&&(i.opacity=e.opacity),void 0!==e.transparent&&(i.transparent=e.transparent),void 0!==e.alphaTest&&(i.alphaTest=e.alphaTest),void 0!==e.depthTest&&(i.depthTest=e.depthTest),void 0!==e.depthWrite&&(i.depthWrite=e.depthWrite),void 0!==e.colorWrite&&(i.colorWrite=e.colorWrite),void 0!==e.stencilWrite&&(i.stencilWrite=e.stencilWrite),void 0!==e.stencilWriteMask&&(i.stencilWriteMask=e.stencilWriteMask),void 0!==e.stencilFunc&&(i.stencilFunc=e.stencilFunc),void 0!==e.stencilRef&&(i.stencilRef=e.stencilRef),void 0!==e.stencilFuncMask&&(i.stencilFuncMask=e.stencilFuncMask),void 0!==e.stencilFail&&(i.stencilFail=e.stencilFail),void 0!==e.stencilZFail&&(i.stencilZFail=e.stencilZFail),void 0!==e.stencilZPass&&(i.stencilZPass=e.stencilZPass),void 0!==e.wireframe&&(i.wireframe=e.wireframe),void 0!==e.wireframeLinewidth&&(i.wireframeLinewidth=e.wireframeLinewidth),void 0!==e.wireframeLinecap&&(i.wireframeLinecap=e.wireframeLinecap),void 0!==e.wireframeLinejoin&&(i.wireframeLinejoin=e.wireframeLinejoin),void 0!==e.rotation&&(i.rotation=e.rotation),1!==e.linewidth&&(i.linewidth=e.linewidth),void 0!==e.dashSize&&(i.dashSize=e.dashSize),void 0!==e.gapSize&&(i.gapSize=e.gapSize),void 0!==e.scale&&(i.scale=e.scale),void 0!==e.polygonOffset&&(i.polygonOffset=e.polygonOffset),void 0!==e.polygonOffsetFactor&&(i.polygonOffsetFactor=e.polygonOffsetFactor),void 0!==e.polygonOffsetUnits&&(i.polygonOffsetUnits=e.polygonOffsetUnits),void 0!==e.skinning&&(i.skinning=e.skinning),void 0!==e.morphTargets&&(i.morphTargets=e.morphTargets),void 0!==e.morphNormals&&(i.morphNormals=e.morphNormals),void 0!==e.dithering&&(i.dithering=e.dithering),void 0!==e.vertexTangents&&(i.vertexTangents=e.vertexTangents),void 0!==e.visible&&(i.visible=e.visible),void 0!==e.toneMapped&&(i.toneMapped=e.toneMapped),void 0!==e.userData&&(i.userData=e.userData),void 0!==e.vertexColors&&("number"==typeof e.vertexColors?i.vertexColors=e.vertexColors>0:i.vertexColors=e.vertexColors),void 0!==e.uniforms)for(const t in e.uniforms){const o=e.uniforms[t];switch(i.uniforms[t]={},o.type){case"t":i.uniforms[t].value=n(o.value);break;case"c":i.uniforms[t].value=(new ht).setHex(o.value);break;case"v2":i.uniforms[t].value=(new D).fromArray(o.value);break;case"v3":i.uniforms[t].value=(new V).fromArray(o.value);break;case"v4":i.uniforms[t].value=(new G).fromArray(o.value);break;case"m3":i.uniforms[t].value=(new P).fromArray(o.value);break;case"m4":i.uniforms[t].value=(new Te).fromArray(o.value);break;default:i.uniforms[t].value=o.value}}if(void 0!==e.defines&&(i.defines=e.defines),void 0!==e.vertexShader&&(i.vertexShader=e.vertexShader),void 0!==e.fragmentShader&&(i.fragmentShader=e.fragmentShader),void 0!==e.extensions)for(const t in e.extensions)i.extensions[t]=e.extensions[t];if(void 0!==e.shading&&(i.flatShading=1===e.shading),void 0!==e.size&&(i.size=e.size),void 0!==e.sizeAttenuation&&(i.sizeAttenuation=e.sizeAttenuation),void 0!==e.map&&(i.map=n(e.map)),void 0!==e.matcap&&(i.matcap=n(e.matcap)),void 0!==e.alphaMap&&(i.alphaMap=n(e.alphaMap)),void 0!==e.bumpMap&&(i.bumpMap=n(e.bumpMap)),void 0!==e.bumpScale&&(i.bumpScale=e.bumpScale),void 0!==e.normalMap&&(i.normalMap=n(e.normalMap)),void 0!==e.normalMapType&&(i.normalMapType=e.normalMapType),void 0!==e.normalScale){let t=e.normalScale;!1===Array.isArray(t)&&(t=[t,t]),i.normalScale=(new D).fromArray(t)}return void 0!==e.displacementMap&&(i.displacementMap=n(e.displacementMap)),void 0!==e.displacementScale&&(i.displacementScale=e.displacementScale),void 0!==e.displacementBias&&(i.displacementBias=e.displacementBias),void 0!==e.roughnessMap&&(i.roughnessMap=n(e.roughnessMap)),void 0!==e.metalnessMap&&(i.metalnessMap=n(e.metalnessMap)),void 0!==e.emissiveMap&&(i.emissiveMap=n(e.emissiveMap)),void 0!==e.emissiveIntensity&&(i.emissiveIntensity=e.emissiveIntensity),void 0!==e.specularMap&&(i.specularMap=n(e.specularMap)),void 0!==e.envMap&&(i.envMap=n(e.envMap)),void 0!==e.envMapIntensity&&(i.envMapIntensity=e.envMapIntensity),void 0!==e.reflectivity&&(i.reflectivity=e.reflectivity),void 0!==e.refractionRatio&&(i.refractionRatio=e.refractionRatio),void 0!==e.lightMap&&(i.lightMap=n(e.lightMap)),void 0!==e.lightMapIntensity&&(i.lightMapIntensity=e.lightMapIntensity),void 0!==e.aoMap&&(i.aoMap=n(e.aoMap)),void 0!==e.aoMapIntensity&&(i.aoMapIntensity=e.aoMapIntensity),void 0!==e.gradientMap&&(i.gradientMap=n(e.gradientMap)),void 0!==e.clearcoatMap&&(i.clearcoatMap=n(e.clearcoatMap)),void 0!==e.clearcoatRoughnessMap&&(i.clearcoatRoughnessMap=n(e.clearcoatRoughnessMap)),void 0!==e.clearcoatNormalMap&&(i.clearcoatNormalMap=n(e.clearcoatNormalMap)),void 0!==e.clearcoatNormalScale&&(i.clearcoatNormalScale=(new D).fromArray(e.clearcoatNormalScale)),void 0!==e.transmission&&(i.transmission=e.transmission),void 0!==e.transmissionMap&&(i.transmissionMap=n(e.transmissionMap)),i},setTextures:function(e){return this.textures=e,this}});function Ps(){Bt.call(this),this.type="InstancedBufferGeometry",this.instanceCount=1/0}function Fs(e,t,n,i){"number"==typeof n&&(i=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),Tt.call(this,e,t,n),this.meshPerAttribute=i||1}function Hs(e){Wa.call(this,e)}function Us(e){"undefined"==typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"==typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),Wa.call(this,e),this.options={premultiplyAlpha:"none"}}function Bs(){this.type="ShapePath",this.color=new ht,this.subPaths=[],this.currentPath=null}Ps.prototype=Object.assign(Object.create(Bt.prototype),{constructor:Ps,isInstancedBufferGeometry:!0,copy:function(e){return Bt.prototype.copy.call(this,e),this.instanceCount=e.instanceCount,this},clone:function(){return(new this.constructor).copy(this)},toJSON:function(){const e=Bt.prototype.toJSON.call(this);return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}),Fs.prototype=Object.assign(Object.create(Tt.prototype),{constructor:Fs,isInstancedBufferAttribute:!0,copy:function(e){return Tt.prototype.copy.call(this,e),this.meshPerAttribute=e.meshPerAttribute,this},toJSON:function(){const e=Tt.prototype.toJSON.call(this);return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}),Hs.prototype=Object.assign(Object.create(Wa.prototype),{constructor:Hs,load:function(e,t,n,i){const o=this,r=new Va(o.manager);r.setPath(o.path),r.setRequestHeader(o.requestHeader),r.setWithCredentials(o.withCredentials),r.load(e,(function(n){try{t(o.parse(JSON.parse(n)))}catch(t){i?i(t):console.error(t),o.manager.itemError(e)}}),n,i)},parse:function(e){const t={},n={};function i(e,i){if(void 0!==t[i])return t[i];const o=e.interleavedBuffers[i],r=function(e,t){if(void 0!==n[t])return n[t];const i=e.arrayBuffers[t],o=new Uint32Array(i).buffer;return n[t]=o,o}(e,o.buffer),a=new wo(wt(o.type,r),o.stride);return a.uuid=o.uuid,t[i]=a,a}const o=e.isInstancedBufferGeometry?new Ps:new Bt,r=e.data.index;if(void 0!==r){const e=wt(r.type,r.array);o.setIndex(new Tt(e,1))}const a=e.data.attributes;for(const t in a){const n=a[t];let r;if(n.isInterleavedBufferAttribute)r=new Mo(i(e.data,n.data),n.itemSize,n.offset,n.normalized);else{const e=wt(n.type,n.array);r=new(n.isInstancedBufferAttribute?Fs:Tt)(e,n.itemSize,n.normalized)}void 0!==n.name&&(r.name=n.name),o.setAttribute(t,r)}const s=e.data.morphAttributes;if(s)for(const t in s){const n=s[t],r=[];for(let t=0,o=n.length;t<o;t++){const o=n[t];let a;a=o.isInterleavedBufferAttribute?new Mo(i(e.data,o.data),o.itemSize,o.offset,o.normalized):new Tt(wt(o.type,o.array),o.itemSize,o.normalized),void 0!==o.name&&(a.name=o.name),r.push(a)}o.morphAttributes[t]=r}e.data.morphTargetsRelative&&(o.morphTargetsRelative=!0);const c=e.data.groups||e.data.drawcalls||e.data.offsets;if(void 0!==c)for(let e=0,t=c.length;e!==t;++e){const t=c[e];o.addGroup(t.start,t.count,t.materialIndex)}const l=e.data.boundingSphere;if(void 0!==l){const e=new V;void 0!==l.center&&e.fromArray(l.center),o.boundingSphere=new le(e,l.radius)}return e.name&&(o.name=e.name),e.userData&&(o.userData=e.userData),o}}),Us.prototype=Object.assign(Object.create(Wa.prototype),{constructor:Us,isImageBitmapLoader:!0,setOptions:function(e){return this.options=e,this},load:function(e,t,n,i){void 0===e&&(e=""),void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);const o=this,r=za.get(e);if(void 0!==r)return o.manager.itemStart(e),setTimeout((function(){t&&t(r),o.manager.itemEnd(e)}),0),r;const a={};a.credentials="anonymous"===this.crossOrigin?"same-origin":"include",fetch(e,a).then((function(e){return e.blob()})).then((function(e){return createImageBitmap(e,o.options)})).then((function(n){za.add(e,n),t&&t(n),o.manager.itemEnd(e)})).catch((function(t){i&&i(t),o.manager.itemError(e),o.manager.itemEnd(e)})),o.manager.itemStart(e)}}),Object.assign(Bs.prototype,{moveTo:function(e,t){return this.currentPath=new Ts,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,t),this},lineTo:function(e,t){return this.currentPath.lineTo(e,t),this},quadraticCurveTo:function(e,t,n,i){return this.currentPath.quadraticCurveTo(e,t,n,i),this},bezierCurveTo:function(e,t,n,i,o,r){return this.currentPath.bezierCurveTo(e,t,n,i,o,r),this},splineThru:function(e){return this.currentPath.splineThru(e),this},toShapes:function(e,t){function n(e){const t=[];for(let n=0,i=e.length;n<i;n++){const i=e[n],o=new vs;o.curves=i.curves,t.push(o)}return t}function i(e,t){const n=t.length;let i=!1;for(let o=n-1,r=0;r<n;o=r++){let n=t[o],a=t[r],s=a.x-n.x,c=a.y-n.y;if(Math.abs(c)>Number.EPSILON){if(c<0&&(n=t[r],s=-s,a=t[o],c=-c),e.y<n.y||e.y>a.y)continue;if(e.y===n.y){if(e.x===n.x)return!0}else{const t=c*(e.x-n.x)-s*(e.y-n.y);if(0===t)return!0;if(t<0)continue;i=!i}}else{if(e.y!==n.y)continue;if(a.x<=e.x&&e.x<=n.x||n.x<=e.x&&e.x<=a.x)return!0}}return i}const o=aa.isClockWise,r=this.subPaths;if(0===r.length)return[];if(!0===t)return n(r);let a,s,c;const l=[];if(1===r.length)return s=r[0],c=new vs,c.curves=s.curves,l.push(c),l;let d=!o(r[0].getPoints());d=e?!d:d;const h=[],f=[];let u,p,m=[],g=0;f[g]=void 0,m[g]=[];for(let t=0,n=r.length;t<n;t++)s=r[t],u=s.getPoints(),a=o(u),a=e?!a:a,a?(!d&&f[g]&&g++,f[g]={s:new vs,p:u},f[g].s.curves=s.curves,d&&g++,m[g]=[]):m[g].push({h:s,p:u[0]});if(!f[0])return n(r);if(f.length>1){let e=!1;const t=[];for(let e=0,t=f.length;e<t;e++)h[e]=[];for(let n=0,o=f.length;n<o;n++){const o=m[n];for(let r=0;r<o.length;r++){const a=o[r];let s=!0;for(let o=0;o<f.length;o++)i(a.p,f[o].p)&&(n!==o&&t.push({froms:n,tos:o,hole:r}),s?(s=!1,h[o].push(a)):e=!0);s&&h[n].push(a)}}t.length>0&&(e||(m=h))}for(let e=0,t=f.length;e<t;e++){c=f[e].s,l.push(c),p=m[e];for(let e=0,t=p.length;e<t;e++)c.holes.push(p[e].h)}return l}});class zs{constructor(e){Object.defineProperty(this,"isFont",{value:!0}),this.type="Font",this.data=e}generateShapes(e,t=100){const n=[],i=function(e,t,n){const i=Array.from?Array.from(e):String(e).split(""),o=t/n.resolution,r=(n.boundingBox.yMax-n.boundingBox.yMin+n.underlineThickness)*o,a=[];let s=0,c=0;for(let e=0;e<i.length;e++){const t=i[e];if("\n"===t)s=0,c-=r;else{const e=Gs(t,o,s,c,n);s+=e.offsetX,a.push(e.path)}}return a}(e,t,this.data);for(let e=0,t=i.length;e<t;e++)Array.prototype.push.apply(n,i[e].toShapes());return n}}function Gs(e,t,n,i,o){const r=o.glyphs[e]||o.glyphs["?"];if(!r)return void console.error('THREE.Font: character "'+e+'" does not exists in font family '+o.familyName+".");const a=new Bs;let s,c,l,d,h,f,u,p;if(r.o){const e=r._cachedOutline||(r._cachedOutline=r.o.split(" "));for(let o=0,r=e.length;o<r;)switch(e[o++]){case"m":s=e[o++]*t+n,c=e[o++]*t+i,a.moveTo(s,c);break;case"l":s=e[o++]*t+n,c=e[o++]*t+i,a.lineTo(s,c);break;case"q":l=e[o++]*t+n,d=e[o++]*t+i,h=e[o++]*t+n,f=e[o++]*t+i,a.quadraticCurveTo(h,f,l,d);break;case"b":l=e[o++]*t+n,d=e[o++]*t+i,h=e[o++]*t+n,f=e[o++]*t+i,u=e[o++]*t+n,p=e[o++]*t+i,a.bezierCurveTo(h,f,u,p,l,d)}}return{offsetX:r.ha*t,path:a}}function Ws(e){Wa.call(this,e)}let Ys;Ws.prototype=Object.assign(Object.create(Wa.prototype),{constructor:Ws,load:function(e,t,n,i){const o=this,r=new Va(this.manager);r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(o.withCredentials),r.load(e,(function(e){let n;try{n=JSON.parse(e)}catch(t){console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),n=JSON.parse(e.substring(65,e.length-2))}const i=o.parse(n);t&&t(i)}),n,i)},parse:function(e){return new zs(e)}});function Vs(e){Wa.call(this,e)}function ks(e,t,n){Ms.call(this,void 0,n);const i=(new ht).set(e),o=(new ht).set(t),r=new V(i.r,i.g,i.b),a=new V(o.r,o.g,o.b),s=Math.sqrt(Math.PI),c=s*Math.sqrt(.75);this.sh.coefficients[0].copy(r).add(a).multiplyScalar(s),this.sh.coefficients[1].copy(r).sub(a).multiplyScalar(c)}function js(e,t){Ms.call(this,void 0,t);const n=(new ht).set(e);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}Vs.prototype=Object.assign(Object.create(Wa.prototype),{constructor:Vs,load:function(e,t,n,i){const o=this,r=new Va(o.manager);r.setResponseType("arraybuffer"),r.setPath(o.path),r.setRequestHeader(o.requestHeader),r.setWithCredentials(o.withCredentials),r.load(e,(function(n){try{const e=n.slice(0);(void 0===Ys&&(Ys=new(window.AudioContext||window.webkitAudioContext)),Ys).decodeAudioData(e,(function(e){t(e)}))}catch(t){i?i(t):console.error(t),o.manager.itemError(e)}}),n,i)}}),ks.prototype=Object.assign(Object.create(Ms.prototype),{constructor:ks,isHemisphereLightProbe:!0,copy:function(e){return Ms.prototype.copy.call(this,e),this},toJSON:function(e){return Ms.prototype.toJSON.call(this,e)}}),js.prototype=Object.assign(Object.create(Ms.prototype),{constructor:js,isAmbientLightProbe:!0,copy:function(e){return Ms.prototype.copy.call(this,e),this},toJSON:function(e){return Ms.prototype.toJSON.call(this,e)}});const Xs=new Te,qs=new Te;Object.assign(function(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new fn,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new fn,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}.prototype,{update:function(e){const t=this._cache;if(t.focus!==e.focus||t.fov!==e.fov||t.aspect!==e.aspect*this.aspect||t.near!==e.near||t.far!==e.far||t.zoom!==e.zoom||t.eyeSep!==this.eyeSep){t.focus=e.focus,t.fov=e.fov,t.aspect=e.aspect*this.aspect,t.near=e.near,t.far=e.far,t.zoom=e.zoom,t.eyeSep=this.eyeSep;const n=e.projectionMatrix.clone(),i=t.eyeSep/2,o=i*t.near/t.focus,r=t.near*Math.tan(M.DEG2RAD*t.fov*.5)/t.zoom;let a,s;qs.elements[12]=-i,Xs.elements[12]=i,a=-r*t.aspect+o,s=r*t.aspect+o,n.elements[0]=2*t.near/(s-a),n.elements[8]=(s+a)/(s-a),this.cameraL.projectionMatrix.copy(n),a=-r*t.aspect-o,s=r*t.aspect-o,n.elements[0]=2*t.near/(s-a),n.elements[8]=(s+a)/(s-a),this.cameraR.projectionMatrix.copy(n)}this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(qs),this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Xs)}});class Ks{constructor(e){this.autoStart=void 0===e||e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=Zs(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=Zs();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}function Zs(){return("undefined"==typeof performance?Date:performance).now()}function Js(e,t,n){let i,o,r;switch(this.binding=e,this.valueSize=n,t){case"quaternion":i=this._slerp,o=this._slerpAdditive,r=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*n),this._workIndex=5;break;case"string":case"bool":i=this._select,o=this._select,r=this._setAdditiveIdentityOther,this.buffer=new Array(5*n);break;default:i=this._lerp,o=this._lerpAdditive,r=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*n)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=o,this._setIdentity=r,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}Object.assign(Js.prototype,{accumulate:function(e,t){const n=this.buffer,i=this.valueSize,o=e*i+i;let r=this.cumulativeWeight;if(0===r){for(let e=0;e!==i;++e)n[o+e]=n[e];r=t}else{r+=t;const e=t/r;this._mixBufferRegion(n,o,0,e,i)}this.cumulativeWeight=r},accumulateAdditive:function(e){const t=this.buffer,n=this.valueSize,i=n*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),this._mixBufferRegionAdditive(t,i,0,e,n),this.cumulativeWeightAdditive+=e},apply:function(e){const t=this.valueSize,n=this.buffer,i=e*t+t,o=this.cumulativeWeight,r=this.cumulativeWeightAdditive,a=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,o<1){const e=t*this._origIndex;this._mixBufferRegion(n,i,e,1-o,t)}r>0&&this._mixBufferRegionAdditive(n,i,this._addIndex*t,1,t);for(let e=t,o=t+t;e!==o;++e)if(n[e]!==n[e+t]){a.setValue(n,i);break}},saveOriginalState:function(){const e=this.binding,t=this.buffer,n=this.valueSize,i=n*this._origIndex;e.getValue(t,i);for(let e=n,o=i;e!==o;++e)t[e]=t[i+e%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0},restoreOriginalState:function(){const e=3*this.valueSize;this.binding.setValue(this.buffer,e)},_setAdditiveIdentityNumeric:function(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let n=e;n<t;n++)this.buffer[n]=0},_setAdditiveIdentityQuaternion:function(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1},_setAdditiveIdentityOther:function(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[t+n]=this.buffer[e+n]},_select:function(e,t,n,i,o){if(i>=.5)for(let i=0;i!==o;++i)e[t+i]=e[n+i]},_slerp:function(e,t,n,i){Y.slerpFlat(e,t,e,t,e,n,i)},_slerpAdditive:function(e,t,n,i,o){const r=this._workIndex*o;Y.multiplyQuaternionsFlat(e,r,e,t,e,n),Y.slerpFlat(e,t,e,t,e,r,i)},_lerp:function(e,t,n,i,o){const r=1-i;for(let a=0;a!==o;++a){const o=t+a;e[o]=e[o]*r+e[n+a]*i}},_lerpAdditive:function(e,t,n,i,o){for(let r=0;r!==o;++r){const o=t+r;e[o]=e[o]+e[n+r]*i}}});const Qs=new RegExp("[\\[\\]\\.:\\/]","g"),$s="[^\\[\\]\\.:\\/]",ec="[^"+"\\[\\]\\.:\\/".replace("\\.","")+"]",tc=/((?:WC+[\/:])*)/.source.replace("WC",$s),nc=/(WCOD+)?/.source.replace("WCOD",ec),ic=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",$s),oc=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",$s),rc=new RegExp("^"+tc+nc+ic+oc+"$"),ac=["material","materials","bones"];function sc(e,t,n){const i=n||cc.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,i)}function cc(e,t,n){this.path=t,this.parsedPath=n||cc.parseTrackName(t),this.node=cc.findNode(e,this.parsedPath.nodeName)||e,this.rootNode=e}Object.assign(sc.prototype,{getValue:function(e,t){this.bind();const n=this._targetGroup.nCachedObjects_,i=this._bindings[n];void 0!==i&&i.getValue(e,t)},setValue:function(e,t){const n=this._bindings;for(let i=this._targetGroup.nCachedObjects_,o=n.length;i!==o;++i)n[i].setValue(e,t)},bind:function(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].bind()},unbind:function(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].unbind()}}),Object.assign(cc,{Composite:sc,create:function(e,t,n){return e&&e.isAnimationObjectGroup?new cc.Composite(e,t,n):new cc(e,t,n)},sanitizeNodeName:function(e){return e.replace(/\s/g,"_").replace(Qs,"")},parseTrackName:function(e){const t=rc.exec(e);if(!t)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const n={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},i=n.nodeName&&n.nodeName.lastIndexOf(".");if(void 0!==i&&-1!==i){const e=n.nodeName.substring(i+1);-1!==ac.indexOf(e)&&(n.nodeName=n.nodeName.substring(0,i),n.objectName=e)}if(null===n.propertyName||0===n.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return n},findNode:function(e,t){if(!t||""===t||"."===t||-1===t||t===e.name||t===e.uuid)return e;if(e.skeleton){const n=e.skeleton.getBoneByName(t);if(void 0!==n)return n}if(e.children){const n=function(e){for(let i=0;i<e.length;i++){const o=e[i];if(o.name===t||o.uuid===t)return o;const r=n(o.children);if(r)return r}return null},i=n(e.children);if(i)return i}return null}}),Object.assign(cc.prototype,{_getValue_unavailable:function(){},_setValue_unavailable:function(){},BindingType:{Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Versioning:{None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},GetterByBindingType:[function(e,t){e[t]=this.node[this.propertyName]},function(e,t){const n=this.resolvedProperty;for(let i=0,o=n.length;i!==o;++i)e[t++]=n[i]},function(e,t){e[t]=this.resolvedProperty[this.propertyIndex]},function(e,t){this.resolvedProperty.toArray(e,t)}],SetterByBindingTypeAndVersioning:[[function(e,t){this.targetObject[this.propertyName]=e[t]},function(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0},function(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(e,t){const n=this.resolvedProperty;for(let i=0,o=n.length;i!==o;++i)n[i]=e[t++]},function(e,t){const n=this.resolvedProperty;for(let i=0,o=n.length;i!==o;++i)n[i]=e[t++];this.targetObject.needsUpdate=!0},function(e,t){const n=this.resolvedProperty;for(let i=0,o=n.length;i!==o;++i)n[i]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}],[function(e,t){this.resolvedProperty[this.propertyIndex]=e[t]},function(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0},function(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(e,t){this.resolvedProperty.fromArray(e,t)},function(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0},function(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}]],getValue:function(e,t){this.bind(),this.getValue(e,t)},setValue:function(e,t){this.bind(),this.setValue(e,t)},bind:function(){let e=this.node;const t=this.parsedPath,n=t.objectName,i=t.propertyName;let o=t.propertyIndex;if(e||(e=cc.findNode(this.rootNode,t.nodeName)||this.rootNode,this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e)return void console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");if(n){let i=t.objectIndex;switch(n){case"materials":if(!e.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!e.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);e=e.material.materials;break;case"bones":if(!e.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);e=e.skeleton.bones;for(let t=0;t<e.length;t++)if(e[t].name===i){i=t;break}break;default:if(void 0===e[n])return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);e=e[n]}if(void 0!==i){if(void 0===e[i])return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);e=e[i]}}const r=e[i];if(void 0===r){const n=t.nodeName;return void console.error("THREE.PropertyBinding: Trying to update property for track: "+n+"."+i+" but it wasn't found.",e)}let a=this.Versioning.None;this.targetObject=e,void 0!==e.needsUpdate?a=this.Versioning.NeedsUpdate:void 0!==e.matrixWorldNeedsUpdate&&(a=this.Versioning.MatrixWorldNeedsUpdate);let s=this.BindingType.Direct;if(void 0!==o){if("morphTargetInfluences"===i){if(!e.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!e.geometry.isBufferGeometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);if(!e.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==e.morphTargetDictionary[o]&&(o=e.morphTargetDictionary[o])}s=this.BindingType.ArrayElement,this.resolvedProperty=r,this.propertyIndex=o}else void 0!==r.fromArray&&void 0!==r.toArray?(s=this.BindingType.HasFromToArray,this.resolvedProperty=r):Array.isArray(r)?(s=this.BindingType.EntireArray,this.resolvedProperty=r):this.propertyName=i;this.getValue=this.GetterByBindingType[s],this.setValue=this.SetterByBindingTypeAndVersioning[s][a]},unbind:function(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}),Object.assign(cc.prototype,{_getValue_unbound:cc.prototype.getValue,_setValue_unbound:cc.prototype.setValue}),Object.assign(function(){this.uuid=M.generateUUID(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const e={};this._indicesByUUID=e;for(let t=0,n=arguments.length;t!==n;++t)e[arguments[t].uuid]=t;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const t=this;this.stats={objects:{get total(){return t._objects.length},get inUse(){return this.total-t.nCachedObjects_}},get bindingsPerObject(){return t._bindings.length}}}.prototype,{isAnimationObjectGroup:!0,add:function(){const e=this._objects,t=this._indicesByUUID,n=this._paths,i=this._parsedPaths,o=this._bindings,r=o.length;let a,s=e.length,c=this.nCachedObjects_;for(let l=0,d=arguments.length;l!==d;++l){const d=arguments[l],h=d.uuid;let f=t[h];if(void 0===f){f=s++,t[h]=f,e.push(d);for(let e=0,t=r;e!==t;++e)o[e].push(new cc(d,n[e],i[e]))}else if(f<c){a=e[f];const s=--c,l=e[s];t[l.uuid]=f,e[f]=l,t[h]=s,e[s]=d;for(let e=0,t=r;e!==t;++e){const t=o[e],r=t[s];let a=t[f];t[f]=r,void 0===a&&(a=new cc(d,n[e],i[e])),t[s]=a}}else e[f]!==a&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=c},remove:function(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,i=n.length;let o=this.nCachedObjects_;for(let r=0,a=arguments.length;r!==a;++r){const a=arguments[r],s=a.uuid,c=t[s];if(void 0!==c&&c>=o){const r=o++,l=e[r];t[l.uuid]=c,e[c]=l,t[s]=r,e[r]=a;for(let e=0,t=i;e!==t;++e){const t=n[e],i=t[r],o=t[c];t[c]=i,t[r]=o}}}this.nCachedObjects_=o},uncache:function(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,i=n.length;let o=this.nCachedObjects_,r=e.length;for(let a=0,s=arguments.length;a!==s;++a){const s=arguments[a].uuid,c=t[s];if(void 0!==c)if(delete t[s],c<o){const a=--o,s=e[a],l=--r,d=e[l];t[s.uuid]=c,e[c]=s,t[d.uuid]=a,e[a]=d,e.pop();for(let e=0,t=i;e!==t;++e){const t=n[e],i=t[a],o=t[l];t[c]=i,t[a]=o,t.pop()}}else{const o=--r,a=e[o];o>0&&(t[a.uuid]=c),e[c]=a,e.pop();for(let e=0,t=i;e!==t;++e){const t=n[e];t[c]=t[o],t.pop()}}}this.nCachedObjects_=o},subscribe_:function(e,t){const n=this._bindingsIndicesByPath;let i=n[e];const o=this._bindings;if(void 0!==i)return o[i];const r=this._paths,a=this._parsedPaths,s=this._objects,c=s.length,l=this.nCachedObjects_,d=new Array(c);i=o.length,n[e]=i,r.push(e),a.push(t),o.push(d);for(let n=l,i=s.length;n!==i;++n){const i=s[n];d[n]=new cc(i,e,t)}return d},unsubscribe_:function(e){const t=this._bindingsIndicesByPath,n=t[e];if(void 0!==n){const i=this._paths,o=this._parsedPaths,r=this._bindings,a=r.length-1,s=r[a];t[e[a]]=n,r[n]=s,r.pop(),o[n]=o[a],o.pop(),i[n]=i[a],i.pop()}}});class lc{constructor(e,t,n=null,i=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=n,this.blendMode=i;const o=t.tracks,r=o.length,a=new Array(r),s={endingStart:R,endingEnd:R};for(let e=0;e!==r;++e){const t=o[e].createInterpolant(null);a[e]=t,t.settings=s}this._interpolantSettings=s,this._interpolants=a,this._propertyBindings=new Array(r),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=2201,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,n){if(e.fadeOut(t),this.fadeIn(t),n){const n=this._clip.duration,i=e._clip.duration,o=i/n,r=n/i;e.warp(1,o,t),this.warp(r,1,t)}return this}crossFadeTo(e,t,n){return e.crossFadeFrom(this,t,n)}stopFading(){const e=this._weightInterpolant;return null!==e&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,n){const i=this._mixer,o=i.time,r=this.timeScale;let a=this._timeScaleInterpolant;null===a&&(a=i._lendControlInterpolant(),this._timeScaleInterpolant=a);const s=a.parameterPositions,c=a.sampleValues;return s[0]=o,s[1]=o+n,c[0]=e/r,c[1]=t/r,this}stopWarping(){const e=this._timeScaleInterpolant;return null!==e&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,n,i){if(!this.enabled)return void this._updateWeight(e);const o=this._startTime;if(null!==o){const i=(e-o)*n;if(i<0||0===n)return;this._startTime=null,t=n*i}t*=this._updateTimeScale(e);const r=this._updateTime(t),a=this._updateWeight(e);if(a>0){const e=this._interpolants,t=this._propertyBindings;switch(this.blendMode){case 2501:for(let n=0,i=e.length;n!==i;++n)e[n].evaluate(r),t[n].accumulateAdditive(a);break;case 2500:default:for(let n=0,o=e.length;n!==o;++n)e[n].evaluate(r),t[n].accumulate(i,a)}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const n=this._weightInterpolant;if(null!==n){const i=n.evaluate(e)[0];t*=i,e>n.parameterPositions[1]&&(this.stopFading(),0===i&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const n=this._timeScaleInterpolant;null!==n&&(t*=n.evaluate(e)[0],e>n.parameterPositions[1]&&(this.stopWarping(),0===t?this.paused=!0:this.timeScale=t))}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,n=this.loop;let i=this.time+e,o=this._loopCount;const r=2202===n;if(0===e)return-1===o?i:r&&1==(1&o)?t-i:i;if(2200===n){-1===o&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(i>=t)i=t;else{if(!(i<0)){this.time=i;break e}i=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(-1===o&&(e>=0?(o=0,this._setEndings(!0,0===this.repetitions,r)):this._setEndings(0===this.repetitions,!0,r)),i>=t||i<0){const n=Math.floor(i/t);i-=t*n,o+=Math.abs(n);const a=this.repetitions-o;if(a<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=e>0?t:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(1===a){const t=e<0;this._setEndings(t,!t,r)}else this._setEndings(!1,!1,r);this._loopCount=o,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:n})}}else this.time=i;if(r&&1==(1&o))return t-i}return i}_setEndings(e,t,n){const i=this._interpolantSettings;n?(i.endingStart=I,i.endingEnd=I):(i.endingStart=e?this.zeroSlopeAtStart?I:R:O,i.endingEnd=t?this.zeroSlopeAtEnd?I:R:O)}_scheduleFading(e,t,n){const i=this._mixer,o=i.time;let r=this._weightInterpolant;null===r&&(r=i._lendControlInterpolant(),this._weightInterpolant=r);const a=r.parameterPositions,s=r.sampleValues;return a[0]=o,s[0]=t,a[1]=o+e,s[1]=n,this}}function dc(e){this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}dc.prototype=Object.assign(Object.create(_.prototype),{constructor:dc,_bindAction:function(e,t){const n=e._localRoot||this._root,i=e._clip.tracks,o=i.length,r=e._propertyBindings,a=e._interpolants,s=n.uuid,c=this._bindingsByRootAndName;let l=c[s];void 0===l&&(l={},c[s]=l);for(let e=0;e!==o;++e){const o=i[e],c=o.name;let d=l[c];if(void 0!==d)r[e]=d;else{if(d=r[e],void 0!==d){null===d._cacheIndex&&(++d.referenceCount,this._addInactiveBinding(d,s,c));continue}const i=t&&t._propertyBindings[e].binding.parsedPath;d=new Js(cc.create(n,c,i),o.ValueTypeName,o.getValueSize()),++d.referenceCount,this._addInactiveBinding(d,s,c),r[e]=d}a[e].resultBuffer=d.buffer}},_activateAction:function(e){if(!this._isActiveAction(e)){if(null===e._cacheIndex){const t=(e._localRoot||this._root).uuid,n=e._clip.uuid,i=this._actionsByClip[n];this._bindAction(e,i&&i.knownActions[0]),this._addInactiveAction(e,n,t)}const t=e._propertyBindings;for(let e=0,n=t.length;e!==n;++e){const n=t[e];0==n.useCount++&&(this._lendBinding(n),n.saveOriginalState())}this._lendAction(e)}},_deactivateAction:function(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let e=0,n=t.length;e!==n;++e){const n=t[e];0==--n.useCount&&(n.restoreOriginalState(),this._takeBackBinding(n))}this._takeBackAction(e)}},_initMemoryManager:function(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}},_isActiveAction:function(e){const t=e._cacheIndex;return null!==t&&t<this._nActiveActions},_addInactiveAction:function(e,t,n){const i=this._actions,o=this._actionsByClip;let r=o[t];if(void 0===r)r={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,o[t]=r;else{const t=r.knownActions;e._byClipCacheIndex=t.length,t.push(e)}e._cacheIndex=i.length,i.push(e),r.actionByRoot[n]=e},_removeInactiveAction:function(e){const t=this._actions,n=t[t.length-1],i=e._cacheIndex;n._cacheIndex=i,t[i]=n,t.pop(),e._cacheIndex=null;const o=e._clip.uuid,r=this._actionsByClip,a=r[o],s=a.knownActions,c=s[s.length-1],l=e._byClipCacheIndex;c._byClipCacheIndex=l,s[l]=c,s.pop(),e._byClipCacheIndex=null,delete a.actionByRoot[(e._localRoot||this._root).uuid],0===s.length&&delete r[o],this._removeInactiveBindingsForAction(e)},_removeInactiveBindingsForAction:function(e){const t=e._propertyBindings;for(let e=0,n=t.length;e!==n;++e){const n=t[e];0==--n.referenceCount&&this._removeInactiveBinding(n)}},_lendAction:function(e){const t=this._actions,n=e._cacheIndex,i=this._nActiveActions++,o=t[i];e._cacheIndex=i,t[i]=e,o._cacheIndex=n,t[n]=o},_takeBackAction:function(e){const t=this._actions,n=e._cacheIndex,i=--this._nActiveActions,o=t[i];e._cacheIndex=i,t[i]=e,o._cacheIndex=n,t[n]=o},_addInactiveBinding:function(e,t,n){const i=this._bindingsByRootAndName,o=this._bindings;let r=i[t];void 0===r&&(r={},i[t]=r),r[n]=e,e._cacheIndex=o.length,o.push(e)},_removeInactiveBinding:function(e){const t=this._bindings,n=e.binding,i=n.rootNode.uuid,o=n.path,r=this._bindingsByRootAndName,a=r[i],s=t[t.length-1],c=e._cacheIndex;s._cacheIndex=c,t[c]=s,t.pop(),delete a[o],0===Object.keys(a).length&&delete r[i]},_lendBinding:function(e){const t=this._bindings,n=e._cacheIndex,i=this._nActiveBindings++,o=t[i];e._cacheIndex=i,t[i]=e,o._cacheIndex=n,t[n]=o},_takeBackBinding:function(e){const t=this._bindings,n=e._cacheIndex,i=--this._nActiveBindings,o=t[i];e._cacheIndex=i,t[i]=e,o._cacheIndex=n,t[n]=o},_lendControlInterpolant:function(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let n=e[t];return void 0===n&&(n=new xa(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),n.__cacheIndex=t,e[t]=n),n},_takeBackControlInterpolant:function(e){const t=this._controlInterpolants,n=e.__cacheIndex,i=--this._nActiveControlInterpolants,o=t[i];e.__cacheIndex=i,t[i]=e,o.__cacheIndex=n,t[n]=o},_controlInterpolantsResultBuffer:new Float32Array(1),clipAction:function(e,t,n){const i=t||this._root,o=i.uuid;let r="string"==typeof e?Ua.findByName(i,e):e;const a=null!==r?r.uuid:e,s=this._actionsByClip[a];let c=null;if(void 0===n&&(n=null!==r?r.blendMode:2500),void 0!==s){const e=s.actionByRoot[o];if(void 0!==e&&e.blendMode===n)return e;c=s.knownActions[0],null===r&&(r=c._clip)}if(null===r)return null;const l=new lc(this,r,t,n);return this._bindAction(l,c),this._addInactiveAction(l,a,o),l},existingAction:function(e,t){const n=t||this._root,i=n.uuid,o="string"==typeof e?Ua.findByName(n,e):e,r=o?o.uuid:e,a=this._actionsByClip[r];return void 0!==a&&a.actionByRoot[i]||null},stopAllAction:function(){const e=this._actions;for(let t=this._nActiveActions-1;t>=0;--t)e[t].stop();return this},update:function(e){e*=this.timeScale;const t=this._actions,n=this._nActiveActions,i=this.time+=e,o=Math.sign(e),r=this._accuIndex^=1;for(let a=0;a!==n;++a)t[a]._update(i,e,o,r);const a=this._bindings,s=this._nActiveBindings;for(let e=0;e!==s;++e)a[e].apply(r);return this},setTime:function(e){this.time=0;for(let e=0;e<this._actions.length;e++)this._actions[e].time=0;return this.update(e)},getRoot:function(){return this._root},uncacheClip:function(e){const t=this._actions,n=e.uuid,i=this._actionsByClip,o=i[n];if(void 0!==o){const e=o.knownActions;for(let n=0,i=e.length;n!==i;++n){const i=e[n];this._deactivateAction(i);const o=i._cacheIndex,r=t[t.length-1];i._cacheIndex=null,i._byClipCacheIndex=null,r._cacheIndex=o,t[o]=r,t.pop(),this._removeInactiveBindingsForAction(i)}delete i[n]}},uncacheRoot:function(e){const t=e.uuid,n=this._actionsByClip;for(const e in n){const i=n[e].actionByRoot[t];void 0!==i&&(this._deactivateAction(i),this._removeInactiveAction(i))}const i=this._bindingsByRootAndName[t];if(void 0!==i)for(const e in i){const t=i[e];t.restoreOriginalState(),this._removeInactiveBinding(t)}},uncacheAction:function(e,t){const n=this.existingAction(e,t);null!==n&&(this._deactivateAction(n),this._removeInactiveAction(n))}});class hc{constructor(e){"string"==typeof e&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),e=arguments[1]),this.value=e}clone(){return new hc(void 0===this.value.clone?this.value:this.value.clone())}}function fc(e,t,n){wo.call(this,e,t),this.meshPerAttribute=n||1}function uc(e,t,n,i,o){this.buffer=e,this.type=t,this.itemSize=n,this.elementSize=i,this.count=o,this.version=0}function pc(e,t,n,i){this.ray=new Ee(e,t),this.near=n||0,this.far=i||1/0,this.camera=null,this.layers=new Le,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}},Object.defineProperties(this.params,{PointCloud:{get:function(){return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),this.Points}}})}function mc(e,t){return e.distance-t.distance}function gc(e,t,n,i){if(e.layers.test(t.layers)&&e.raycast(t,n),!0===i){const i=e.children;for(let e=0,o=i.length;e<o;e++)gc(i[e],t,n,!0)}}fc.prototype=Object.assign(Object.create(wo.prototype),{constructor:fc,isInstancedInterleavedBuffer:!0,copy:function(e){return wo.prototype.copy.call(this,e),this.meshPerAttribute=e.meshPerAttribute,this},clone:function(e){const t=wo.prototype.clone.call(this,e);return t.meshPerAttribute=this.meshPerAttribute,t},toJSON:function(e){const t=wo.prototype.toJSON.call(this,e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}),Object.defineProperty(uc.prototype,"needsUpdate",{set:function(e){!0===e&&this.version++}}),Object.assign(uc.prototype,{isGLBufferAttribute:!0,setBuffer:function(e){return this.buffer=e,this},setType:function(e,t){return this.type=e,this.elementSize=t,this},setItemSize:function(e){return this.itemSize=e,this},setCount:function(e){return this.count=e,this}}),Object.assign(pc.prototype,{set:function(e,t){this.ray.set(e,t)},setFromCamera:function(e,t){t&&t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t&&t.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("THREE.Raycaster: Unsupported camera type: "+t.type)},intersectObject:function(e,t,n){const i=n||[];return gc(e,this,i,t),i.sort(mc),i},intersectObjects:function(e,t,n){const i=n||[];if(!1===Array.isArray(e))return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),i;for(let n=0,o=e.length;n<o;n++)gc(e[n],this,i,t);return i.sort(mc),i}});class Ec{constructor(e=1,t=0,n=0){return this.radius=e,this.phi=t,this.theta=n,this}set(e,t,n){return this.radius=e,this.phi=t,this.theta=n,this}clone(){return(new this.constructor).copy(this)}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){const e=1e-6;return this.phi=Math.max(e,Math.min(Math.PI-e,this.phi)),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,n){return this.radius=Math.sqrt(e*e+t*t+n*n),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,n),this.phi=Math.acos(M.clamp(t/this.radius,-1,1))),this}}const Tc=new D,vc=new V,Ac=new V;function Rc(e){Ye.call(this),this.material=e,this.render=function(){},this.hasPositions=!1,this.hasNormals=!1,this.hasColors=!1,this.hasUvs=!1,this.positionArray=null,this.normalArray=null,this.colorArray=null,this.uvArray=null,this.count=0}Rc.prototype=Object.create(Ye.prototype),Rc.prototype.constructor=Rc,Rc.prototype.isImmediateRenderObject=!0;const Ic=new V,Oc=new Te,Sc=new Te;function Nc(e){const t=[];e&&e.isBone&&t.push(e);for(let n=0;n<e.children.length;n++)t.push.apply(t,Nc(e.children[n]));return t}const bc=new Float32Array(1),yc=(new Int32Array(bc.buffer),Math.pow(2,8),[.125,.215,.35,.446,.526,.582]),xc=5+yc.length,Lc=new mt({side:1,depthWrite:!1,depthTest:!1}),{_lodPlanes:_c,_sizeLods:wc,_sigmas:Cc}=(new on(new an,Lc),Mc());function Mc(){const e=[],t=[],n=[];let i=8;for(let o=0;o<xc;o++){const r=Math.pow(2,i);t.push(r);let a=1/r;o>4?a=yc[o-8+4-1]:0==o&&(a=0),n.push(a);const s=1/(r-1),c=-s/2,l=1+s/2,d=[c,c,l,c,l,l,c,c,l,l,c,l],h=6,f=6,u=3,p=2,m=1,g=new Float32Array(u*f*h),E=new Float32Array(p*f*h),T=new Float32Array(m*f*h);for(let e=0;e<h;e++){const t=e%3*2/3-1,n=e>2?0:-1,i=[t,n,0,t+2/3,n,0,t+2/3,n+1,0,t,n,0,t+2/3,n+1,0,t,n+1,0];g.set(i,u*f*e),E.set(d,p*f*e);const o=[e,e,e,e,e,e];T.set(o,m*f*e)}const v=new Bt;v.setAttribute("position",new Tt(g,u)),v.setAttribute("uv",new Tt(E,p)),v.setAttribute("faceIndex",new Tt(T,m)),e.push(v),i>4&&i--}return{_lodPlanes:e,_sizeLods:t,_sigmas:n}}function Dc(e){console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."),rs.call(this,e),this.type="catmullrom"}Math.sqrt(5),Ja.create=function(e,t){return console.log("THREE.Curve.create() has been deprecated"),e.prototype=Object.create(Ja.prototype),e.prototype.constructor=e,e.prototype.getPoint=t,e},Object.assign(Ts.prototype,{fromPoints:function(e){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(e)}}),Object.create(rs.prototype),Object.create(rs.prototype),Dc.prototype=Object.create(rs.prototype),Object.assign(Dc.prototype,{initFromArray:function(){console.error("THREE.Spline: .initFromArray() has been removed.")},getControlPointsArray:function(){console.error("THREE.Spline: .getControlPointsArray() has been removed.")},reparametrizeByArcLength:function(){console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")}}),class extends Or{constructor(e=10,t=10,n=4473924,i=8947848){n=new ht(n),i=new ht(i);const o=t/2,r=e/t,a=e/2,s=[],c=[];for(let e=0,l=0,d=-a;e<=t;e++,d+=r){s.push(-a,0,d,a,0,d),s.push(d,0,-a,d,0,a);const t=e===o?n:i;t.toArray(c,l),l+=3,t.toArray(c,l),l+=3,t.toArray(c,l),l+=3,t.toArray(c,l),l+=3}const l=new Bt;l.setAttribute("position",new yt(s,3)),l.setAttribute("color",new yt(c,3)),super(l,new pr({vertexColors:!0,toneMapped:!1})),this.type="GridHelper"}}.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")},class extends Or{constructor(e){const t=Nc(e),n=new Bt,i=[],o=[],r=new ht(0,0,1),a=new ht(0,1,0);for(let e=0;e<t.length;e++){const n=t[e];n.parent&&n.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),o.push(r.r,r.g,r.b),o.push(a.r,a.g,a.b))}n.setAttribute("position",new yt(i,3)),n.setAttribute("color",new yt(o,3)),super(n,new pr({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0})),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const t=this.bones,n=this.geometry,i=n.getAttribute("position");Sc.copy(this.root.matrixWorld).invert();for(let e=0,n=0;e<t.length;e++){const o=t[e];o.parent&&o.parent.isBone&&(Oc.multiplyMatrices(Sc,o.matrixWorld),Ic.setFromMatrixPosition(Oc),i.setXYZ(n,Ic.x,Ic.y,Ic.z),Oc.multiplyMatrices(Sc,o.parent.matrixWorld),Ic.setFromMatrixPosition(Oc),i.setXYZ(n+1,Ic.x,Ic.y,Ic.z),n+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}}.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")},Object.assign(Wa.prototype,{extractUrlBase:function(e){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),function(e){const t=e.lastIndexOf("/");return-1===t?"./":e.substr(0,t+1)}(e)}}),Wa.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}},Object.assign(class{constructor(e,t){Object.defineProperty(this,"isBox2",{value:!0}),this.min=void 0!==e?e:new D(1/0,1/0),this.max=void 0!==t?t:new D(-1/0,-1/0)}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=Tc.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}clone(){return(new this.constructor).copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return void 0===e&&(console.warn("THREE.Box2: .getCenter() target is now required"),e=new D),this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return void 0===e&&(console.warn("THREE.Box2: .getSize() target is now required"),e=new D),this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,t){return void 0===t&&(console.warn("THREE.Box2: .getParameter() target is now required"),t=new D),t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y)}clampPoint(e,t){return void 0===t&&(console.warn("THREE.Box2: .clampPoint() target is now required"),t=new D),t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return Tc.copy(e).clamp(this.min,this.max).sub(e).length()}intersect(e){return this.min.max(e.min),this.max.min(e.max),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}.prototype,{center:function(e){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(e)},empty:function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(e){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(e)},size:function(e){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(e)}}),Object.assign(X.prototype,{center:function(e){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(e)},empty:function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(e){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(e)},isIntersectionSphere:function(e){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(e)},size:function(e){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(e)}}),Object.assign(le.prototype,{empty:function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()}}),An.prototype.setFromMatrix=function(e){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(e)},class{constructor(e,t){this.start=void 0!==e?e:new V,this.end=void 0!==t?t:new V}set(e,t){return this.start.copy(e),this.end.copy(t),this}clone(){return(new this.constructor).copy(this)}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return void 0===e&&(console.warn("THREE.Line3: .getCenter() target is now required"),e=new V),e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return void 0===e&&(console.warn("THREE.Line3: .delta() target is now required"),e=new V),e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return void 0===t&&(console.warn("THREE.Line3: .at() target is now required"),t=new V),this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){vc.subVectors(e,this.start),Ac.subVectors(this.end,this.start);const n=Ac.dot(Ac);let i=Ac.dot(vc)/n;return t&&(i=M.clamp(i,0,1)),i}closestPointToPoint(e,t,n){const i=this.closestPointToPointParameter(e,t);return void 0===n&&(console.warn("THREE.Line3: .closestPointToPoint() target is now required"),n=new V),this.delta(n).multiplyScalar(i).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}}.prototype.center=function(e){return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),this.getCenter(e)},Object.assign(M,{random16:function(){return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."),Math.random()},nearestPowerOfTwo:function(e){return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),M.floorPowerOfTwo(e)},nextPowerOfTwo:function(e){return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),M.ceilPowerOfTwo(e)}}),Object.assign(P.prototype,{flattenToArrayOffset:function(e,t){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(e,t)},multiplyVector3:function(e){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),e.applyMatrix3(this)},multiplyVector3Array:function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},applyToBufferAttribute:function(e){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),e.applyMatrix3(this)},applyToVector3Array:function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")},getInverse:function(e){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(e).invert()}}),Object.assign(Te.prototype,{extractPosition:function(e){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(e)},flattenToArrayOffset:function(e,t){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(e,t)},getPosition:function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),(new V).setFromMatrixColumn(this,3)},setRotationFromQuaternion:function(e){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(e)},multiplyToArray:function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},multiplyVector3:function(e){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},multiplyVector4:function(e){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},multiplyVector3Array:function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},rotateAxis:function(e){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),e.transformDirection(this)},crossVector:function(e){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},translate:function(){console.error("THREE.Matrix4: .translate() has been removed.")},rotateX:function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},rotateY:function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},rotateZ:function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},rotateByAxis:function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},applyToBufferAttribute:function(e){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},applyToVector3Array:function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},makeFrustum:function(e,t,n,i,o,r){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(e,t,i,n,o,r)},getInverse:function(e){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(e).invert()}}),Xe.prototype.isIntersectionLine=function(e){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(e)},Object.assign(Y.prototype,{multiplyVector3:function(e){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),e.applyQuaternion(this)},inverse:function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()}}),Object.assign(Ee.prototype,{isIntersectionBox:function(e){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(e)},isIntersectionPlane:function(e){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(e)},isIntersectionSphere:function(e){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(e)}}),Object.assign(ot.prototype,{area:function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},barycoordFromPoint:function(e,t){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(e,t)},midpoint:function(e){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(e)},normal:function(e){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(e)},plane:function(e){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(e)}}),Object.assign(ot,{barycoordFromPoint:function(e,t,n,i,o){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),ot.getBarycoord(e,t,n,i,o)},normal:function(e,t,n,i){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),ot.getNormal(e,t,n,i)}}),Object.assign(vs.prototype,{extractAllPoints:function(e){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(e)},extrude:function(e){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new la(this,e)},makeGeometry:function(e){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new fa(this,e)}}),Object.assign(D.prototype,{fromAttribute:function(e,t,n){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(e,t,n)},distanceToManhattan:function(e){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(e)},lengthManhattan:function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(V.prototype,{setEulerFromRotationMatrix:function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},setEulerFromQuaternion:function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},getPositionFromMatrix:function(e){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(e)},getScaleFromMatrix:function(e){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(e)},getColumnFromMatrix:function(e,t){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(t,e)},applyProjection:function(e){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(e)},fromAttribute:function(e,t,n){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(e,t,n)},distanceToManhattan:function(e){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(e)},lengthManhattan:function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(G.prototype,{fromAttribute:function(e,t,n){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(e,t,n)},lengthManhattan:function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(Ye.prototype,{getChildByName:function(e){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(e)},renderDepth:function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},translate:function(e,t){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(t,e)},getWorldRotation:function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},applyMatrix:function(e){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)}}),Object.defineProperties(Ye.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(e){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=e}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}}),Object.assign(on.prototype,{setDrawMode:function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}),Object.defineProperties(on.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),0},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}}),Object.defineProperties(Qo.prototype,{objects:{get:function(){return console.warn("THREE.LOD: .objects has been renamed to .levels."),this.levels}}}),Object.defineProperty(cr.prototype,"useVertexTexture",{get:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")},set:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")}}),or.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")},Object.defineProperty(Ja.prototype,"__arcLengthDivisions",{get:function(){return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions},set:function(e){console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions=e}}),fn.prototype.setLens=function(e,t){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),void 0!==t&&(this.filmGauge=t),this.setFocalLength(e)},Object.defineProperties(As.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(e){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=e}},shadowCameraLeft:{set:function(e){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=e}},shadowCameraRight:{set:function(e){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=e}},shadowCameraTop:{set:function(e){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=e}},shadowCameraBottom:{set:function(e){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=e}},shadowCameraNear:{set:function(e){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=e}},shadowCameraFar:{set:function(e){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=e}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(e){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=e}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(e){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=e}},shadowMapHeight:{set:function(e){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=e}}}),Object.defineProperties(Tt.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===x},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(x)}}}),Object.assign(Tt.prototype,{setDynamic:function(e){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===e?x:y),this},copyIndicesArray:function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},setArray:function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}}),Object.assign(Bt.prototype,{addIndex:function(e){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(e)},addAttribute:function(e,t){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),t&&t.isBufferAttribute||t&&t.isInterleavedBufferAttribute?"index"===e?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(t),this):this.setAttribute(e,t):(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(e,new Tt(arguments[1],arguments[2])))},addDrawCall:function(e,t,n){void 0!==n&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(e,t)},clearDrawCalls:function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},computeOffsets:function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},removeAttribute:function(e){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(e)},applyMatrix:function(e){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)}}),Object.defineProperties(Bt.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}}),Object.defineProperties(Ps.prototype,{maxInstancedCount:{get:function(){return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount},set:function(e){console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount=e}}}),Object.defineProperties(pc.prototype,{linePrecision:{get:function(){return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold},set:function(e){console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold=e}}}),Object.defineProperties(wo.prototype,{dynamic:{get:function(){return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.usage===x},set:function(e){console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.setUsage(e)}}}),Object.assign(wo.prototype,{setDynamic:function(e){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===e?x:y),this},setArray:function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}}),Object.assign(la.prototype,{getArrays:function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")},addShapeList:function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")},addShape:function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")}}),Object.assign(_o.prototype,{dispose:function(){console.error("THREE.Scene: .dispose() has been removed.")}}),Object.defineProperties(hc.prototype,{dynamic:{set:function(){console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")}},onUpdate:{value:function(){return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),this}}}),Object.defineProperties(pt.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new ht}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(e){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===e}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(e){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=e}}}),Object.defineProperties(Ta.prototype,{metal:{get:function(){return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),!1},set:function(){console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")}}}),Object.defineProperties(Ea.prototype,{transparency:{get:function(){return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission},set:function(e){console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission=e}}}),Object.defineProperties(dn.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(e){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=e}}}),Object.assign(xo.prototype,{clearTarget:function(e,t,n,i){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(e),this.clear(t,n,i)},animate:function(e){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(e)},getCurrentRenderTarget:function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},getMaxAnisotropy:function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},getPrecision:function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},resetGLState:function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},supportsFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},supportsHalfFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},supportsStandardDerivatives:function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},supportsCompressedTextureS3TC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},supportsCompressedTexturePVRTC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},supportsBlendMinMax:function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},supportsVertexTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},supportsInstancedArrays:function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},enableScissorTest:function(e){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(e)},initMaterial:function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},addPrePlugin:function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},addPostPlugin:function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},updateShadowMap:function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},setFaceCulling:function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},allocTextureUnit:function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},setTexture:function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},setTexture2D:function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},setTextureCube:function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},getActiveMipMapLevel:function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()}}),Object.defineProperties(xo.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(e){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=e}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(e){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=e}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(e){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=!0===e?N:S}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}}),Object.defineProperties(vo.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}}),Object.defineProperties(W.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(e){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=e}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(e){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=e}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(e){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=e}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(e){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=e}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(e){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=e}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(e){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=e}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(e){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=e}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(e){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=e}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(e){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=e}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(e){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=e}}}),Object.defineProperties(class extends Ye{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(!0===this.isPlaying)return void console.warn("THREE.Audio: Audio is already playing.");if(!1===this.hasPlaybackControl)return void console.warn("THREE.Audio: this Audio has no playback control.");this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(!1!==this.hasPlaybackControl)return!0===this.isPlaying&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;console.warn("THREE.Audio: this Audio has no playback control.")}stop(){if(!1!==this.hasPlaybackControl)return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this;console.warn("THREE.Audio: this Audio has no playback control.")}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(e){return e||(e=[]),!0===this._connected?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){if(this.detune=e,void 0!==this.source.detune)return!0===this.isPlaying&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(!1!==this.hasPlaybackControl)return this.playbackRate=e,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;console.warn("THREE.Audio: this Audio has no playback control.")}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(!1!==this.hasPlaybackControl)return this.loop=e,!0===this.isPlaying&&(this.source.loop=this.loop),this;console.warn("THREE.Audio: this Audio has no playback control.")}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}.prototype,{load:{value:function(e){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const t=this;return(new Vs).load(e,(function(e){t.setBuffer(e)})),this}},startTime:{set:function(){console.warn("THREE.Audio: .startTime is now .play( delay ).")}}}),class{constructor(e,t=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=t,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0;const t=this.getFrequencyData();for(let n=0;n<t.length;n++)e+=t[n];return e/t.length}}.prototype.getData=function(){return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),this.getFrequencyData()},pn.prototype.updateCubeMap=function(e,t){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(e,t)},pn.prototype.clear=function(e,t,n,i){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(e,t,n,i)},H.crossOrigin=void 0,H.loadTexture=function(e,t,n,i){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const o=new Za;o.setCrossOrigin(this.crossOrigin);const r=o.load(e,n,void 0,i);return t&&(r.mapping=t),r},H.loadTextureCube=function(e,t,n,i){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const o=new qa;o.setCrossOrigin(this.crossOrigin);const r=o.load(e,n,void 0,i);return t&&(r.mapping=t),r},H.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")},H.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:"125"}})),"undefined"!=typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__="125");var Pc=function(e,t){var n,i,o,r,a,s;void 0===t&&console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),t===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.object=e,this.domElement=t,this.enabled=!0,this.target=new V,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:37,UP:38,RIGHT:39,BOTTOM:40},this.mouseButtons={LEFT:0,MIDDLE:1,RIGHT:2},this.touches={ONE:0,TWO:2},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return m.phi},this.getAzimuthalAngle=function(){return m.theta},this.listenToKeyEvents=function(e){e.addEventListener("keydown",$),this._domElementKeyEvents=e},this.saveState=function(){c.target0.copy(c.target),c.position0.copy(c.object.position),c.zoom0=c.object.zoom},this.reset=function(){c.target.copy(c.target0),c.object.position.copy(c.position0),c.object.zoom=c.zoom0,c.object.updateProjectionMatrix(),c.dispatchEvent(l),c.update(),u=f.NONE},this.update=(n=new V,i=(new Y).setFromUnitVectors(e.up,new V(0,1,0)),o=i.clone().invert(),r=new V,a=new Y,s=2*Math.PI,function(){var e=c.object.position;n.copy(e).sub(c.target),n.applyQuaternion(i),m.setFromVector3(n),c.autoRotate&&u===f.NONE&&_(2*Math.PI/60/60*c.autoRotateSpeed),c.enableDamping?(m.theta+=g.theta*c.dampingFactor,m.phi+=g.phi*c.dampingFactor):(m.theta+=g.theta,m.phi+=g.phi);var t=c.minAzimuthAngle,d=c.maxAzimuthAngle;return isFinite(t)&&isFinite(d)&&(t<-Math.PI?t+=s:t>Math.PI&&(t-=s),d<-Math.PI?d+=s:d>Math.PI&&(d-=s),m.theta=t<=d?Math.max(t,Math.min(d,m.theta)):m.theta>(t+d)/2?Math.max(t,m.theta):Math.min(d,m.theta)),m.phi=Math.max(c.minPolarAngle,Math.min(c.maxPolarAngle,m.phi)),m.makeSafe(),m.radius*=E,m.radius=Math.max(c.minDistance,Math.min(c.maxDistance,m.radius)),!0===c.enableDamping?c.target.addScaledVector(T,c.dampingFactor):c.target.add(T),n.setFromSpherical(m),n.applyQuaternion(o),e.copy(c.target).add(n),c.object.lookAt(c.target),!0===c.enableDamping?(g.theta*=1-c.dampingFactor,g.phi*=1-c.dampingFactor,T.multiplyScalar(1-c.dampingFactor)):(g.set(0,0,0),T.set(0,0,0)),E=1,!!(v||r.distanceToSquared(c.object.position)>p||8*(1-a.dot(c.object.quaternion))>p)&&(c.dispatchEvent(l),r.copy(c.object.position),a.copy(c.object.quaternion),v=!1,!0)}),this.dispose=function(){c.domElement.removeEventListener("contextmenu",ie),c.domElement.removeEventListener("pointerdown",K),c.domElement.removeEventListener("wheel",Q),c.domElement.removeEventListener("touchstart",ee),c.domElement.removeEventListener("touchend",ne),c.domElement.removeEventListener("touchmove",te),c.domElement.ownerDocument.removeEventListener("pointermove",Z),c.domElement.ownerDocument.removeEventListener("pointerup",J),null!==c._domElementKeyEvents&&c._domElementKeyEvents.removeEventListener("keydown",$)};var c=this,l={type:"change"},d={type:"start"},h={type:"end"},f={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6},u=f.NONE,p=1e-6,m=new Ec,g=new Ec,E=1,T=new V,v=!1,A=new D,R=new D,I=new D,O=new D,S=new D,N=new D,b=new D,y=new D,x=new D;function L(){return Math.pow(.95,c.zoomSpeed)}function _(e){g.theta-=e}function w(e){g.phi-=e}var C,M=(C=new V,function(e,t){C.setFromMatrixColumn(t,0),C.multiplyScalar(-e),T.add(C)}),P=function(){var e=new V;return function(t,n){!0===c.screenSpacePanning?e.setFromMatrixColumn(n,1):(e.setFromMatrixColumn(n,0),e.crossVectors(c.object.up,e)),e.multiplyScalar(t),T.add(e)}}(),F=function(){var e=new V;return function(t,n){var i=c.domElement;if(c.object.isPerspectiveCamera){var o=c.object.position;e.copy(o).sub(c.target);var r=e.length();r*=Math.tan(c.object.fov/2*Math.PI/180),M(2*t*r/i.clientHeight,c.object.matrix),P(2*n*r/i.clientHeight,c.object.matrix)}else c.object.isOrthographicCamera?(M(t*(c.object.right-c.object.left)/c.object.zoom/i.clientWidth,c.object.matrix),P(n*(c.object.top-c.object.bottom)/c.object.zoom/i.clientHeight,c.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),c.enablePan=!1)}}();function H(e){c.object.isPerspectiveCamera?E/=e:c.object.isOrthographicCamera?(c.object.zoom=Math.max(c.minZoom,Math.min(c.maxZoom,c.object.zoom*e)),c.object.updateProjectionMatrix(),v=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),c.enableZoom=!1)}function U(e){c.object.isPerspectiveCamera?E*=e:c.object.isOrthographicCamera?(c.object.zoom=Math.max(c.minZoom,Math.min(c.maxZoom,c.object.zoom/e)),c.object.updateProjectionMatrix(),v=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),c.enableZoom=!1)}function B(e){A.set(e.clientX,e.clientY)}function z(e){O.set(e.clientX,e.clientY)}function G(e){if(1==e.touches.length)A.set(e.touches[0].pageX,e.touches[0].pageY);else{var t=.5*(e.touches[0].pageX+e.touches[1].pageX),n=.5*(e.touches[0].pageY+e.touches[1].pageY);A.set(t,n)}}function W(e){if(1==e.touches.length)O.set(e.touches[0].pageX,e.touches[0].pageY);else{var t=.5*(e.touches[0].pageX+e.touches[1].pageX),n=.5*(e.touches[0].pageY+e.touches[1].pageY);O.set(t,n)}}function k(e){var t=e.touches[0].pageX-e.touches[1].pageX,n=e.touches[0].pageY-e.touches[1].pageY,i=Math.sqrt(t*t+n*n);b.set(0,i)}function j(e){if(1==e.touches.length)R.set(e.touches[0].pageX,e.touches[0].pageY);else{var t=.5*(e.touches[0].pageX+e.touches[1].pageX),n=.5*(e.touches[0].pageY+e.touches[1].pageY);R.set(t,n)}I.subVectors(R,A).multiplyScalar(c.rotateSpeed);var i=c.domElement;_(2*Math.PI*I.x/i.clientHeight),w(2*Math.PI*I.y/i.clientHeight),A.copy(R)}function X(e){if(1==e.touches.length)S.set(e.touches[0].pageX,e.touches[0].pageY);else{var t=.5*(e.touches[0].pageX+e.touches[1].pageX),n=.5*(e.touches[0].pageY+e.touches[1].pageY);S.set(t,n)}N.subVectors(S,O).multiplyScalar(c.panSpeed),F(N.x,N.y),O.copy(S)}function q(e){var t=e.touches[0].pageX-e.touches[1].pageX,n=e.touches[0].pageY-e.touches[1].pageY,i=Math.sqrt(t*t+n*n);y.set(0,i),x.set(0,Math.pow(y.y/b.y,c.zoomSpeed)),H(x.y),b.copy(y)}function K(e){if(!1!==c.enabled)switch(e.pointerType){case"mouse":case"pen":!function(e){var t;switch(e.preventDefault(),c.domElement.focus?c.domElement.focus():window.focus(),e.button){case 0:t=c.mouseButtons.LEFT;break;case 1:t=c.mouseButtons.MIDDLE;break;case 2:t=c.mouseButtons.RIGHT;break;default:t=-1}switch(t){case 1:if(!1===c.enableZoom)return;!function(e){b.set(e.clientX,e.clientY)}(e),u=f.DOLLY;break;case 0:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===c.enablePan)return;z(e),u=f.PAN}else{if(!1===c.enableRotate)return;B(e),u=f.ROTATE}break;case 2:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===c.enableRotate)return;B(e),u=f.ROTATE}else{if(!1===c.enablePan)return;z(e),u=f.PAN}break;default:u=f.NONE}u!==f.NONE&&(c.domElement.ownerDocument.addEventListener("pointermove",Z),c.domElement.ownerDocument.addEventListener("pointerup",J),c.dispatchEvent(d))}(e)}}function Z(e){if(!1!==c.enabled)switch(e.pointerType){case"mouse":case"pen":!function(e){if(!1!==c.enabled)switch(e.preventDefault(),u){case f.ROTATE:if(!1===c.enableRotate)return;!function(e){R.set(e.clientX,e.clientY),I.subVectors(R,A).multiplyScalar(c.rotateSpeed);var t=c.domElement;_(2*Math.PI*I.x/t.clientHeight),w(2*Math.PI*I.y/t.clientHeight),A.copy(R),c.update()}(e);break;case f.DOLLY:if(!1===c.enableZoom)return;!function(e){y.set(e.clientX,e.clientY),x.subVectors(y,b),x.y>0?H(L()):x.y<0&&U(L()),b.copy(y),c.update()}(e);break;case f.PAN:if(!1===c.enablePan)return;!function(e){S.set(e.clientX,e.clientY),N.subVectors(S,O).multiplyScalar(c.panSpeed),F(N.x,N.y),O.copy(S),c.update()}(e)}}(e)}}function J(e){switch(e.pointerType){case"mouse":case"pen":c.domElement.ownerDocument.removeEventListener("pointermove",Z),c.domElement.ownerDocument.removeEventListener("pointerup",J),!1!==c.enabled&&(c.dispatchEvent(h),u=f.NONE)}}function Q(e){!1===c.enabled||!1===c.enableZoom||u!==f.NONE&&u!==f.ROTATE||(e.preventDefault(),e.stopPropagation(),c.dispatchEvent(d),function(e){e.deltaY<0?U(L()):e.deltaY>0&&H(L()),c.update()}(e),c.dispatchEvent(h))}function $(e){!1!==c.enabled&&!1!==c.enablePan&&function(e){var t=!1;switch(e.keyCode){case c.keys.UP:F(0,c.keyPanSpeed),t=!0;break;case c.keys.BOTTOM:F(0,-c.keyPanSpeed),t=!0;break;case c.keys.LEFT:F(c.keyPanSpeed,0),t=!0;break;case c.keys.RIGHT:F(-c.keyPanSpeed,0),t=!0}t&&(e.preventDefault(),c.update())}(e)}function ee(e){if(!1!==c.enabled){switch(e.preventDefault(),e.touches.length){case 1:switch(c.touches.ONE){case 0:if(!1===c.enableRotate)return;G(e),u=f.TOUCH_ROTATE;break;case 1:if(!1===c.enablePan)return;W(e),u=f.TOUCH_PAN;break;default:u=f.NONE}break;case 2:switch(c.touches.TWO){case 2:if(!1===c.enableZoom&&!1===c.enablePan)return;!function(e){c.enableZoom&&k(e),c.enablePan&&W(e)}(e),u=f.TOUCH_DOLLY_PAN;break;case 3:if(!1===c.enableZoom&&!1===c.enableRotate)return;!function(e){c.enableZoom&&k(e),c.enableRotate&&G(e)}(e),u=f.TOUCH_DOLLY_ROTATE;break;default:u=f.NONE}break;default:u=f.NONE}u!==f.NONE&&c.dispatchEvent(d)}}function te(e){if(!1!==c.enabled)switch(e.preventDefault(),e.stopPropagation(),u){case f.TOUCH_ROTATE:if(!1===c.enableRotate)return;j(e),c.update();break;case f.TOUCH_PAN:if(!1===c.enablePan)return;X(e),c.update();break;case f.TOUCH_DOLLY_PAN:if(!1===c.enableZoom&&!1===c.enablePan)return;!function(e){c.enableZoom&&q(e),c.enablePan&&X(e)}(e),c.update();break;case f.TOUCH_DOLLY_ROTATE:if(!1===c.enableZoom&&!1===c.enableRotate)return;!function(e){c.enableZoom&&q(e),c.enableRotate&&j(e)}(e),c.update();break;default:u=f.NONE}}function ne(e){!1!==c.enabled&&(c.dispatchEvent(h),u=f.NONE)}function ie(e){!1!==c.enabled&&e.preventDefault()}c.domElement.addEventListener("contextmenu",ie),c.domElement.addEventListener("pointerdown",K),c.domElement.addEventListener("wheel",Q),c.domElement.addEventListener("touchstart",ee),c.domElement.addEventListener("touchend",ne),c.domElement.addEventListener("touchmove",te),this.update()};(Pc.prototype=Object.create(_.prototype)).constructor=Pc;var Fc=function(e,t){Pc.call(this,e,t),this.screenSpacePanning=!1,this.mouseButtons.LEFT=2,this.mouseButtons.RIGHT=0,this.touches.ONE=1,this.touches.TWO=3};(Fc.prototype=Object.create(_.prototype)).constructor=Fc;const Hc='varying vec2 vUv;\r\n#define PI 3.14159265359\r\n#define TWO_PI 6.28318530718\r\nuniform float u_time;\r\nuniform vec2 u_resolution;\r\n\r\n//#include "lygia/draw/bridge.glsl"\r\n\r\nfloat rect( vec2 vUv, float height, float width)\r\n{\r\n    float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\r\n    float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\r\n    float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\r\n    float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\r\n    return left * right * top * bottom;\r\n}\r\n\r\nfloat rectOutline(vec2 vUv, float height, float width)\r\n{\r\n    float y = rect(vUv, height, width);\r\n    float x = rect(vUv, height + 0.01, width + 0.01);\r\n    return x - y;\r\n}\r\n\r\nfloat circle(vec2 vUv, float radius)\r\n{\r\n    vec2 dist = vUv - vec2(0.5, 0.5);\r\n    return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\r\n}\r\n\r\nfloat cirOutline(vec2 vUv, float r)\r\n{\r\n    vec2 dist = vUv - vec2(0.5);\r\n    float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\r\n    float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\r\n    return b - a;\r\n}\r\n\r\n\r\nvec2 Rot(vec2 vUv, float a){\r\n    vUv -= 0.5;\r\n    vUv = mat2(cos(a), -sin(a),\r\n               sin(a), cos(a)) * vUv;\r\n    vUv += 0.5;\r\n    return vUv;\r\n}\r\n\r\nfloat flower(vec2 vUv, float n, float zoom)\r\n{\r\n    vec2 pos = vec2(0.5) - vUv;\r\n    float r = length(pos) * zoom;\r\n    float a = atan(pos.y, pos.x);\r\n    float f = cos(a * n );\r\n    return smoothstep(f, f + 0.25, r );\r\n}\r\n\r\nfloat polygon(vec2 vUv, int N, float size)\r\n{\r\n    vUv = vUv * 2. - 1.;\r\n    float a = atan(vUv.x, vUv.y) + PI;\r\n    float r = TWO_PI/float(N);\r\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\r\n    return 1. - smoothstep(size, size + 0.01, d);\r\n}\r\n\r\nfloat polygonOutline(vec2 vUv, int N, float size)\r\n{\r\n    vUv = vUv * 2. - 1.;\r\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\r\n    float a = atan(vUv.x, vUv.y) + PI;\r\n    float r = TWO_PI/float(N);\r\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\r\n   float x = 1. - smoothstep(size, size + 0.01, d);\r\n   float y = 1. - smoothstep(size + 0.04, size + 0.65, d);\r\n   return y - x;\r\n}\r\n\r\nfloat blob(vec2 vUv, float x, float y){\r\n    vec2 pos = vec2(0.5) - vUv;\r\n    float r = length(pos) * 2.0;\r\n    float a = atan(pos.y, pos.x);\r\n    float f = abs(cos(a * 13.) * cos(r * (x + sin(u_time) + 0.5))) * .05+ .1;\r\n    return 1. - smoothstep(f, f+0.01, r);\r\n}\r\n\r\nfloat blobOutline(vec2 vUv, float x, float y){\r\n    vec2 pos = vec2(0.5) - vUv;\r\n    float r = length(pos) * 2.0;\r\n    float a = atan(pos.y, pos.x);\r\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 1.5))) * .1+ .3;\r\n    float m = 1. - smoothstep(f, f+0.01, r);\r\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\r\n    return n - m;\r\n}\r\n\r\nfloat spike(vec2 vUv, int N, float size)\r\n{\r\n    vUv = vUv * 2. - 1.;\r\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\r\n    float a = atan(vUv.x, vUv.y) * PI;\r\n    float r = TWO_PI/float(N);\r\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\r\n   float x = 1. - smoothstep(size, size + 0.01, d);\r\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\r\n   return y - x;\r\n}\r\n\r\nfloat crossSDF(vec2 vUv, float size)\r\n{\r\n    float r1 = rect(vUv, size, size/(3.));\r\n    float r2 = rect(vUv, size/3., size);\r\n    return r1 + r2;\r\n}\r\n\r\nfloat crossSDFOutline(vec2 vUv, float size)\r\n{\r\n    float r1 = crossSDF(vUv, size);\r\n    float r2 = crossSDF(vUv, size + (size * 0.1));\r\n    return r2 - r1;\r\n}\r\n\r\nvec2 scale(vec2 vUv, float time){\r\n    vUv -= vec2(0.5);\r\n    vUv = vec2(time + 1.5) * vUv;\r\n    vUv += vec2(0.5);\r\n    return vUv;\r\n}\r\n\r\nvec2 tile(vec2 vUv, float zoom)\r\n{\r\n    vUv *= zoom;\r\n    float time = 0.075 * u_time;\r\n    if(fract(time) >  0.5)\r\n    {\r\n        if(fract(vUv.y * 0.5) > 0.5)\r\n        {\r\n            vUv.x += fract(time) * 2.0;\r\n        } \r\n        else \r\n        {\r\n            vUv.x -= fract(time) * 2.0;\r\n        }\r\n    } else {\r\n        if(fract(vUv.x * 0.5) > 0.5)\r\n        {\r\n            vUv.y += fract(time) * 2.0;\r\n        }\r\n        else \r\n        {\r\n            vUv.y -= fract(time) * 2.0;\r\n        }\r\n    }\r\n    return fract(vUv);\r\n}\r\n\r\nvec2 rotatedTilepattern(vec2 st)\r\n{\r\n    st *= 2.0;\r\n    float index = 0.0;\r\n    index += step(1., mod(st.x, 2.0));\r\n    index += step(1., mod(st.y, 2.0)) * 2.0;\r\n    st = fract(st);\r\n    if(index == 1.0){\r\n        st = Rot(st, PI * 0.5);\r\n    } else if (index == 2.0){\r\n        st = Rot(st, PI * -0.5);\r\n    } else if (index == 3.0){\r\n        st = Rot(st, PI);\r\n    }\r\n    return st;\r\n}\r\n\r\nfloat randFloat(float x){\r\n    return fract(sin(x) * 4748393.7585);\r\n}\r\n\r\nfloat randVec2(vec2 vUv){\r\n    return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\r\n}\r\n\r\nvec3 matrix(vec2 vUv, float s){\r\n    float rows = 15.0;\r\n    vec2 a = floor(vUv * rows) + vec2(0.9, 0.4);\r\n    a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\r\n    vec2 b = fract(vUv * rows);\r\n    vec2 newUv = 0.5 - b;\r\n    float str = randVec2(a);\r\n    float shape = smoothstep(0.01, 0.1, (1. - dot(newUv, newUv) * 5.) * 1.);\r\n    float s1 = s * shape;\r\n    return vec3(str * s1 );\r\n}\r\n\r\nfloat sdRoundedBox(vec2 p, vec2 b, vec4 r)\r\n{\r\n    //p - point\r\n    //b - size of box\r\n    //r - round box - top right, bottom right, top left, bottom left\r\n    r.xy = (p.x > 0.0) ? r.xy : r.zw;\r\n    r.x = (p.y > 0.0) ? r.x : r.y;\r\n    vec2 q = abs(p)-b+r.x;\r\n    float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\r\n    return 1. - smoothstep(0.01, 0.02, v);\r\n}\r\n\r\nvoid main()\r\n{\r\n    vec2 vUv = vec2(vUv.x, vUv.y);\r\n    vec3 color = vec3(0.);\r\n\r\n    vUv = tile(vUv, 3.);\r\n\r\n    vUv = rotatedTilepattern(vUv * 1.);\r\n\r\n    vUv = Rot(vUv, PI * u_time * 0.25);\r\n\r\n    float x = smoothstep(vUv.x, vUv.y, 0.01);\r\n    x = smoothstep(0.01, 0.04, x);\r\n\r\n    color = vec3(x);\r\n\r\n\r\n    gl_FragColor = vec4(color, 1.);\r\n}',Uc="varying vec2 vUv;\r\n\r\nvoid main()\r\n{\r\n    vUv = uv;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\r\n}";var Bc={5682:(e,t,n)=>{n.d(t,{Z:()=>r});var i=n(4912);const o={back:n(1198),circular:n(4477),elastic:n(4621),linear:n(406),quartic:n(7549),sine:n(3241),bounce:n(6788),cubic:n(134),exponential:n(3814),quadratic:n(6463),quintic:n(173)},r={easing:Object.assign(i,o)}},9859:(e,t,n)=>{n.d(t,{Z:()=>M});var i=n(976);const o={add:n(4440),colorDodge:n(6444),exclusion:n(9220),hardMix:n(2078),linearDodge:n(2527),negation:n(823),pinLight:n(8186),softLight:n(9556),average:n(613),darken:n(9976),glow:n(2542),lighten:n(9378),linearLight:n(2021),overlay:n(4681),reflect:n(8622),subtract:n(5232),colorBurn:n(1135),difference:n(313),hardLight:n(4951),linearBurn:n(1221),multiply:n(4925),phoenix:n(2435),screen:n(9600),vividLight:n(971)};var r=n(1663),a=n(7427),s=n(4141),c=n(6405),l=n(8980),d=n(2743),h=n(8131),f=n(2799),u=n(177),p=n(3346),m=n(8063),g=n(82),E=n(9872),T=n(3701),v=n(9001),A=n(6084),R=n(3713),I=n(7885),O=n(9323),S=n(338),N=n(9446),b=n(9339),y=n(1725),x=n(304),L=n(157),_=n(5484);const w={YCbCr2rgb:E,gamma2linear:T,linear2gamma:v,rgb2YPbPr:A,rgb2luma:R,rgb2yuv:I,yuv2rgb:O,YPbPr2rgb:S,hsv2rgb:N,rgb2YCbCr:b,rgb2hsv:y,rgb2yiq:x,yiq2rgb:L,rgb2lms:n(5722),lms2rgb:_},C={fire:n(8755),heatmap:n(5335),spectrum:n(8867)},M={blend:Object.assign(i,o),contrastMatrix:r,brightnessContrast:h,hueShift:a,lut:s,saturationMatrix:l,brightnessMatrix:d,desaturate:f,daltonize:p,luma:u,vibrance:c,palette:Object.assign(m,C),space:Object.assign(g,w)}},6764:(e,t,n)=>{n.d(t,{Z:()=>i});const i={barrel:n(4249),chromaAB:n(3886),grain:n(4775),stretch:n(8249)}},2821:(e,t,n)=>{n.d(t,{Z:()=>i});const i={aastep:n(1595),bridge:n(9797),circle:n(4525),cross:n(2788),digits:n(2823),fill:n(5991),flip:n(6141),hex:n(5651),rect:n(672),stroke:n(7328),tri:n(5080)}},1996:(e,t,n)=>{n.d(t,{Z:()=>i});const i={bilateralBlur:n(1995),boxBlur:n(4207),gaussianBlur:n(548),mean:n(7030),median:n(6815),radialBlur:n(6827),kuwahara:n(5551),noiseBlur:n(6105),laplacian:n(3018)}},4899:(e,t,n)=>{n.d(t,{Z:()=>i});const i={snoise:n(6998),cnoise:n(678),fbm:n(4686),noised:n(4401),random:n(6518),pnoise:n(3700)}},5923:(e,t,n)=>{n.d(t,{Z:()=>x});var i=n(8236),o=n(1056),r=n(7802),a=n(2257),s=n(2109),c=n(6951),l=n(1578),d=n(1),h=n(6398),f=n(3538),u=n(7877),p=n(4688),m=n(5661),g=n(2471),E=n(3553),T=n(1496),v=n(254),A=n(1759),R=n(5085),I=n(4782),O=n(2381),S=n(5824),N=n(8029),b=n(3448),y=n(608);const x={adaptiveThreshold:i,lengthSq:o,mod289:r,pow7:a,rotate4dX:s,consts:c,map:l,absi:n(2640),permute:d,powFast:h,rotate4dY:f,decimation:u,max:p,pow2:m,rotate2d:g,rotate4dZ:E,fade:T,min:v,pow3:A,rotate3d:R,saturate:I,grad4:O,mix:S,pow5:N,rotate4d:b,taylorInvSqrt:y}},4912:e=>{e.exports='/*\ndescription: Include all available easing animations\n*/\n\n#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef ONE_OVER_PI\n#define ONE_OVER_PI 0.31830988618\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n#ifndef GOLDEN_RATIO\n#define GOLDEN_RATIO 1.6180339887\n#endif\n#ifndef GOLDEN_RATIO_CONJUGATE \n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#endif\n#ifndef GOLDEN_ANGLE // (3.-sqrt(5.0))*PI radians\n#define GOLDEN_ANGLE 2.39996323\n#endif\n\n\n/*\nauthor: Hugh Kennedy (https://github.com/hughsk)\ndescription: Back easing. From https://github.com/stackgl/glsl-easings\nuse: back<In|Out|InOut>(<float> x)\nlicense: |\n  This software is released under the MIT license:\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_BACKIN\n#define FNC_BACKIN\nfloat backIn(in float t) {\n    return pow(t, 3.) - t * sin(t * PI);\n}\n#endif\n\n#ifndef FNC_BACKOUT\n#define FNC_BACKOUT\nfloat backOut(in float t) {\n    return 1. - backIn(1. - t);\n}\n#endif\n\n#ifndef FNC_BACKINOUT\n#define FNC_BACKINOUT\nfloat backInOut(in float t) {\n    float f = t < .5\n        ? 2.0 * t\n        : 1.0 - (2.0 * t - 1.0);\n\n    float g = backIn(f);\n\n    return t < 0.5\n        ? 0.5 * g\n        : 0.5 * (1.0 - g) + 0.5;\n}\n#endif\n\n#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef ONE_OVER_PI\n#define ONE_OVER_PI 0.31830988618\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n#ifndef GOLDEN_RATIO\n#define GOLDEN_RATIO 1.6180339887\n#endif\n#ifndef GOLDEN_RATIO_CONJUGATE \n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#endif\n#ifndef GOLDEN_ANGLE // (3.-sqrt(5.0))*PI radians\n#define GOLDEN_ANGLE 2.39996323\n#endif\n\n\n/*\nauthor: Hugh Kennedy (https://github.com/hughsk)\ndescription: bounce easing. From https://github.com/stackgl/glsl-easings\nuse: bounce<In|Out|InOut>(<float> x)\nlicense: |\n  This software is released under the MIT license:\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_BOUNCEOUT\n#define FNC_BOUNCEOUT\nfloat bounceOut(in float t) {\n    const float a = 4.0 / 11.0;\n    const float b = 8.0 / 11.0;\n    const float c = 9.0 / 10.0;\n\n    const float ca = 4356.0 / 361.0;\n    const float cb = 35442.0 / 1805.0;\n    const float cc = 16061.0 / 1805.0;\n\n    float t2 = t * t;\n\n    return t < a\n        ? 7.5625 * t2\n        : t < b\n            ? 9.075 * t2 - 9.9 * t + 3.4\n            : t < c\n                ? ca * t2 - cb * t + cc\n                : 10.8 * t * t - 20.52 * t + 10.72;\n}\n#endif\n\n#ifndef FNC_BOUNCEIN\n#define FNC_BOUNCEIN\nfloat bounceIn(in float t) {\n    return 1.0 - bounceOut(1.0 - t);\n}\n#endif\n\n#ifndef FNC_BOUNCEINOUT\n#define FNC_BOUNCEINOUT\nfloat bounceInOut(in float t) {\n    return t < 0.5\n        ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0))\n        : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;\n}\n#endif\n\n/*\nauthor: Hugh Kennedy (https://github.com/hughsk)\ndescription: circular easing. From https://github.com/stackgl/glsl-easings\nuse: circular<In|Out|InOut>(<float> x)\nlicense: |\n  This software is released under the MIT license:\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_CIRCULARIN\n#define FNC_CIRCULARIN\nfloat circularIn(in float t) {\n    return 1.0 - sqrt(1.0 - t * t);\n}\n#endif\n\n#ifndef FNC_CIRCULAROUT\n#define FNC_CIRCULAROUT\nfloat circularOut(in float t) {\n    return sqrt((2.0 - t) * t);\n}\n#endif\n\n#ifndef FNC_CIRCULARINOUT\n#define FNC_CIRCULARINOUT\nfloat circularInOut(in float t) {\n    return t < 0.5\n        ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n        : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n#endif\n\n/*\nauthor: Hugh Kennedy (https://github.com/hughsk)\ndescription: cubic easing. From https://github.com/stackgl/glsl-easings\nuse: cubic<In|Out|InOut>(<float> x)\nlicense: |\n  This software is released under the MIT license:\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_CUBICIN\n#define FNC_CUBICIN\nfloat cubicIn(in float t) {\n  return t * t * t;\n}\n#endif\n\n#ifndef FNC_CUBICOUT\n#define FNC_CUBICOUT\nfloat cubicOut(in float t) {\n  float f = t - 1.0;\n  return f * f * f + 1.0;\n}\n#endif\n\n#ifndef FNC_CUBICINOUT\n#define FNC_CUBICINOUT\nfloat cubicInOut(in float t) {\n  return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n#endif\n\n#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef ONE_OVER_PI\n#define ONE_OVER_PI 0.31830988618\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n#ifndef GOLDEN_RATIO\n#define GOLDEN_RATIO 1.6180339887\n#endif\n#ifndef GOLDEN_RATIO_CONJUGATE \n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#endif\n#ifndef GOLDEN_ANGLE // (3.-sqrt(5.0))*PI radians\n#define GOLDEN_ANGLE 2.39996323\n#endif\n\n\n/*\nauthor: Hugh Kennedy (https://github.com/hughsk)\ndescription: elastic easing. From https://github.com/stackgl/glsl-easings\nuse: elastic<In|Out|InOut>(<float> x)\nlicense: |\n  This software is released under the MIT license:\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_ELASTICIN\n#define FNC_ELASTICIN\nfloat elasticIn(in float t) {\n    return sin(13.0 * t * HALF_PI) * pow(2.0, 10.0 * (t - 1.0));\n}\n#endif \n\n#ifndef FNC_ELASTICOUT\n#define FNC_ELASTICOUT\nfloat elasticOut(in float t) {\n    return sin(-13.0 * (t + 1.0) * HALF_PI) * pow(2.0, -10.0 * t) + 1.0;\n}\n#endif\n\n#ifndef FNC_ELASTICINOUT\n#define FNC_ELASTICINOUT\nfloat elasticInOut(in float t) {\n    return t < 0.5\n        ? 0.5 * sin(+13.0 * HALF_PI * 2.0 * t) * pow(2.0, 10.0 * (2.0 * t - 1.0))\n        : 0.5 * sin(-13.0 * HALF_PI * ((2.0 * t - 1.0) + 1.0)) * pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;\n}\n#endif\n\n/*\nauthor: Hugh Kennedy (https://github.com/hughsk)\ndescription: exponential easing. From https://github.com/stackgl/glsl-easings\nuse: exponential<In|Out|InOut>(<float> x)\nlicense: |\n  This software is released under the MIT license:\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_EXPONENTIALIN\n#define FNC_EXPONENTIALIN\nfloat exponentialIn(in float t) {\n    return t == 0.0 ? t : pow(2.0, 10.0 * (t - 1.0));\n}\n#endif\n\n#ifndef FNC_EXPONENTIALOUT\n#define FNC_EXPONENTIALOUT\nfloat exponentialOut(in float t) {\n    return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n#endif\n\n#ifndef FNC_EXPONENTIALINOUT\n#define FNC_EXPONENTIALINOUT\nfloat exponentialInOut(in float t) {\n    return t == 0.0 || t == 1.0\n        ? t\n        : t < 0.5\n            ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n            : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n#endif\n/*\nauthor: Hugh Kennedy (https://github.com/hughsk)\ndescription: Linear easing. From https://github.com/stackgl/glsl-easings\nuse: linear(<float> x)\nlicense: |\n  This software is released under the MIT license:\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_LINEAR\n#define FNC_LINEAR\nfloat linear(in float t) {\n    return t;\n}\n#endif\n\n/*\nauthor: Hugh Kennedy (https://github.com/hughsk)\ndescription: quadrtic easing. From https://github.com/stackgl/glsl-easings\nuse: quadratic<In|Out|InOut>(<float> x)\nlicense: |\n  This software is released under the MIT license:\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_QUADRATICIN\n#define FNC_QUADRATICIN\nfloat quadraticIn(in float t) {\n    return t * t;\n}\n#endif\n\n#ifndef FNC_QUADRATICOUT\n#define FNC_QUADRATICOUT\nfloat quadraticOut(in float t) {\n    return -t * (t - 2.0);\n}\n#endif\n\n#ifndef FNC_QUADRATICINOUT\n#define FNC_QUADRATICINOUT\nfloat quadraticInOut(in float t) {\n    float p = 2.0 * t * t;\n    return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\n#endif\n\n/*\nauthor: Hugh Kennedy (https://github.com/hughsk)\ndescription: quintic easing. From https://github.com/stackgl/glsl-easings\nuse: quintic<In|Out|InOut>(<float> x)\nlicense: |\n  This software is released under the MIT license:\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_QUINTICIN\n#define FNC_QUINTICIN\nfloat quinticIn(in float t) {\n    return pow(t, 5.0);\n}\n#endif\n\n#ifndef FNC_QUINTICOUT\n#define FNC_QUINTICOUT\nfloat quinticOut(in float t) {\n    return 1.0 - (pow(t - 1.0, 5.0));\n}\n#endif\n\n#ifndef FNC_QUINTICINOUT\n#define FNC_QUINTICINOUT\nfloat quinticInOut(in float t) {\n    return t < 0.5\n        ? +16.0 * pow(t, 5.0)\n        : -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;\n}\n#endif\n\n#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef ONE_OVER_PI\n#define ONE_OVER_PI 0.31830988618\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n#ifndef GOLDEN_RATIO\n#define GOLDEN_RATIO 1.6180339887\n#endif\n#ifndef GOLDEN_RATIO_CONJUGATE \n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#endif\n#ifndef GOLDEN_ANGLE // (3.-sqrt(5.0))*PI radians\n#define GOLDEN_ANGLE 2.39996323\n#endif\n\n\n/*\nauthor: Hugh Kennedy (https://github.com/hughsk)\ndescription: sine easing. From https://github.com/stackgl/glsl-easings\nuse: sine<In|Out|InOut>(<float> x)\nlicense: |\n  This software is released under the MIT license:\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_SINEIN\n#define FNC_SINEIN\nfloat sineIn(in float t) {\n    return sin((t - 1.0) * HALF_PI) + 1.0;\n}\n#endif\n\n#ifndef FNC_SINEOUT\n#define FNC_SINEOUT\nfloat sineOut(in float t) {\n    return sin(t * HALF_PI);\n}\n#endif\n\n#ifndef FNC_SINEINOUT\n#define FNC_SINEINOUT\nfloat sineInOut(in float t) {\n    return -0.5 * (cos(PI * t) - 1.0);\n}\n#endif\n\n'},1198:e=>{e.exports='#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef ONE_OVER_PI\n#define ONE_OVER_PI 0.31830988618\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n#ifndef GOLDEN_RATIO\n#define GOLDEN_RATIO 1.6180339887\n#endif\n#ifndef GOLDEN_RATIO_CONJUGATE \n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#endif\n#ifndef GOLDEN_ANGLE // (3.-sqrt(5.0))*PI radians\n#define GOLDEN_ANGLE 2.39996323\n#endif\n\n\n/*\nauthor: Hugh Kennedy (https://github.com/hughsk)\ndescription: Back easing. From https://github.com/stackgl/glsl-easings\nuse: back<In|Out|InOut>(<float> x)\nlicense: |\n  This software is released under the MIT license:\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_BACKIN\n#define FNC_BACKIN\nfloat backIn(in float t) {\n    return pow(t, 3.) - t * sin(t * PI);\n}\n#endif\n\n#ifndef FNC_BACKOUT\n#define FNC_BACKOUT\nfloat backOut(in float t) {\n    return 1. - backIn(1. - t);\n}\n#endif\n\n#ifndef FNC_BACKINOUT\n#define FNC_BACKINOUT\nfloat backInOut(in float t) {\n    float f = t < .5\n        ? 2.0 * t\n        : 1.0 - (2.0 * t - 1.0);\n\n    float g = backIn(f);\n\n    return t < 0.5\n        ? 0.5 * g\n        : 0.5 * (1.0 - g) + 0.5;\n}\n#endif\n'},6788:e=>{e.exports='#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef ONE_OVER_PI\n#define ONE_OVER_PI 0.31830988618\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n#ifndef GOLDEN_RATIO\n#define GOLDEN_RATIO 1.6180339887\n#endif\n#ifndef GOLDEN_RATIO_CONJUGATE \n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#endif\n#ifndef GOLDEN_ANGLE // (3.-sqrt(5.0))*PI radians\n#define GOLDEN_ANGLE 2.39996323\n#endif\n\n\n/*\nauthor: Hugh Kennedy (https://github.com/hughsk)\ndescription: bounce easing. From https://github.com/stackgl/glsl-easings\nuse: bounce<In|Out|InOut>(<float> x)\nlicense: |\n  This software is released under the MIT license:\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_BOUNCEOUT\n#define FNC_BOUNCEOUT\nfloat bounceOut(in float t) {\n    const float a = 4.0 / 11.0;\n    const float b = 8.0 / 11.0;\n    const float c = 9.0 / 10.0;\n\n    const float ca = 4356.0 / 361.0;\n    const float cb = 35442.0 / 1805.0;\n    const float cc = 16061.0 / 1805.0;\n\n    float t2 = t * t;\n\n    return t < a\n        ? 7.5625 * t2\n        : t < b\n            ? 9.075 * t2 - 9.9 * t + 3.4\n            : t < c\n                ? ca * t2 - cb * t + cc\n                : 10.8 * t * t - 20.52 * t + 10.72;\n}\n#endif\n\n#ifndef FNC_BOUNCEIN\n#define FNC_BOUNCEIN\nfloat bounceIn(in float t) {\n    return 1.0 - bounceOut(1.0 - t);\n}\n#endif\n\n#ifndef FNC_BOUNCEINOUT\n#define FNC_BOUNCEINOUT\nfloat bounceInOut(in float t) {\n    return t < 0.5\n        ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0))\n        : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;\n}\n#endif\n'},4477:e=>{e.exports='/*\nauthor: Hugh Kennedy (https://github.com/hughsk)\ndescription: circular easing. From https://github.com/stackgl/glsl-easings\nuse: circular<In|Out|InOut>(<float> x)\nlicense: |\n  This software is released under the MIT license:\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_CIRCULARIN\n#define FNC_CIRCULARIN\nfloat circularIn(in float t) {\n    return 1.0 - sqrt(1.0 - t * t);\n}\n#endif\n\n#ifndef FNC_CIRCULAROUT\n#define FNC_CIRCULAROUT\nfloat circularOut(in float t) {\n    return sqrt((2.0 - t) * t);\n}\n#endif\n\n#ifndef FNC_CIRCULARINOUT\n#define FNC_CIRCULARINOUT\nfloat circularInOut(in float t) {\n    return t < 0.5\n        ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n        : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n#endif\n'},134:e=>{e.exports='/*\nauthor: Hugh Kennedy (https://github.com/hughsk)\ndescription: cubic easing. From https://github.com/stackgl/glsl-easings\nuse: cubic<In|Out|InOut>(<float> x)\nlicense: |\n  This software is released under the MIT license:\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_CUBICIN\n#define FNC_CUBICIN\nfloat cubicIn(in float t) {\n  return t * t * t;\n}\n#endif\n\n#ifndef FNC_CUBICOUT\n#define FNC_CUBICOUT\nfloat cubicOut(in float t) {\n  float f = t - 1.0;\n  return f * f * f + 1.0;\n}\n#endif\n\n#ifndef FNC_CUBICINOUT\n#define FNC_CUBICINOUT\nfloat cubicInOut(in float t) {\n  return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n#endif\n'},4621:e=>{e.exports='#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef ONE_OVER_PI\n#define ONE_OVER_PI 0.31830988618\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n#ifndef GOLDEN_RATIO\n#define GOLDEN_RATIO 1.6180339887\n#endif\n#ifndef GOLDEN_RATIO_CONJUGATE \n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#endif\n#ifndef GOLDEN_ANGLE // (3.-sqrt(5.0))*PI radians\n#define GOLDEN_ANGLE 2.39996323\n#endif\n\n\n/*\nauthor: Hugh Kennedy (https://github.com/hughsk)\ndescription: elastic easing. From https://github.com/stackgl/glsl-easings\nuse: elastic<In|Out|InOut>(<float> x)\nlicense: |\n  This software is released under the MIT license:\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_ELASTICIN\n#define FNC_ELASTICIN\nfloat elasticIn(in float t) {\n    return sin(13.0 * t * HALF_PI) * pow(2.0, 10.0 * (t - 1.0));\n}\n#endif \n\n#ifndef FNC_ELASTICOUT\n#define FNC_ELASTICOUT\nfloat elasticOut(in float t) {\n    return sin(-13.0 * (t + 1.0) * HALF_PI) * pow(2.0, -10.0 * t) + 1.0;\n}\n#endif\n\n#ifndef FNC_ELASTICINOUT\n#define FNC_ELASTICINOUT\nfloat elasticInOut(in float t) {\n    return t < 0.5\n        ? 0.5 * sin(+13.0 * HALF_PI * 2.0 * t) * pow(2.0, 10.0 * (2.0 * t - 1.0))\n        : 0.5 * sin(-13.0 * HALF_PI * ((2.0 * t - 1.0) + 1.0)) * pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;\n}\n#endif\n'},3814:e=>{e.exports='/*\nauthor: Hugh Kennedy (https://github.com/hughsk)\ndescription: exponential easing. From https://github.com/stackgl/glsl-easings\nuse: exponential<In|Out|InOut>(<float> x)\nlicense: |\n  This software is released under the MIT license:\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_EXPONENTIALIN\n#define FNC_EXPONENTIALIN\nfloat exponentialIn(in float t) {\n    return t == 0.0 ? t : pow(2.0, 10.0 * (t - 1.0));\n}\n#endif\n\n#ifndef FNC_EXPONENTIALOUT\n#define FNC_EXPONENTIALOUT\nfloat exponentialOut(in float t) {\n    return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n#endif\n\n#ifndef FNC_EXPONENTIALINOUT\n#define FNC_EXPONENTIALINOUT\nfloat exponentialInOut(in float t) {\n    return t == 0.0 || t == 1.0\n        ? t\n        : t < 0.5\n            ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n            : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n#endif'},406:e=>{e.exports='/*\nauthor: Hugh Kennedy (https://github.com/hughsk)\ndescription: Linear easing. From https://github.com/stackgl/glsl-easings\nuse: linear(<float> x)\nlicense: |\n  This software is released under the MIT license:\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_LINEAR\n#define FNC_LINEAR\nfloat linear(in float t) {\n    return t;\n}\n#endif\n'},6463:e=>{e.exports='/*\nauthor: Hugh Kennedy (https://github.com/hughsk)\ndescription: quadrtic easing. From https://github.com/stackgl/glsl-easings\nuse: quadratic<In|Out|InOut>(<float> x)\nlicense: |\n  This software is released under the MIT license:\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_QUADRATICIN\n#define FNC_QUADRATICIN\nfloat quadraticIn(in float t) {\n    return t * t;\n}\n#endif\n\n#ifndef FNC_QUADRATICOUT\n#define FNC_QUADRATICOUT\nfloat quadraticOut(in float t) {\n    return -t * (t - 2.0);\n}\n#endif\n\n#ifndef FNC_QUADRATICINOUT\n#define FNC_QUADRATICINOUT\nfloat quadraticInOut(in float t) {\n    float p = 2.0 * t * t;\n    return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\n#endif\n'},7549:e=>{e.exports='/*\nauthor: Hugh Kennedy (https://github.com/hughsk)\ndescription: quartic easing. From https://github.com/stackgl/glsl-easings\nuse: quartic<In|Out|InOut>(<float> x)\nlicense: |\n  This software is released under the MIT license:\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_QUARTICIN\n#define FNC_QUARTICIN\nfloat quarticIn(in float t) {\n  return pow(t, 4.0);\n}\n#endif\n\n#ifndef FNC_QUARTICOUT\n#define FNC_QUARTICOUT\nfloat quarticOut(in float t) {\n  return pow(t - 1.0, 3.0) * (1.0 - t) + 1.0;\n}\n#endif\n\n#ifndef FNC_QUARTICINOUT\n#define FNC_QUARTICINOUT\nfloat quarticInOut(in float t) {\n  return t < 0.5\n    ? +8.0 * pow(t, 4.0)\n    : -8.0 * pow(t - 1.0, 4.0) + 1.0;\n}\n#endif\n'},173:e=>{e.exports='/*\nauthor: Hugh Kennedy (https://github.com/hughsk)\ndescription: quintic easing. From https://github.com/stackgl/glsl-easings\nuse: quintic<In|Out|InOut>(<float> x)\nlicense: |\n  This software is released under the MIT license:\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_QUINTICIN\n#define FNC_QUINTICIN\nfloat quinticIn(in float t) {\n    return pow(t, 5.0);\n}\n#endif\n\n#ifndef FNC_QUINTICOUT\n#define FNC_QUINTICOUT\nfloat quinticOut(in float t) {\n    return 1.0 - (pow(t - 1.0, 5.0));\n}\n#endif\n\n#ifndef FNC_QUINTICINOUT\n#define FNC_QUINTICINOUT\nfloat quinticInOut(in float t) {\n    return t < 0.5\n        ? +16.0 * pow(t, 5.0)\n        : -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;\n}\n#endif\n'},3241:e=>{e.exports='#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef ONE_OVER_PI\n#define ONE_OVER_PI 0.31830988618\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n#ifndef GOLDEN_RATIO\n#define GOLDEN_RATIO 1.6180339887\n#endif\n#ifndef GOLDEN_RATIO_CONJUGATE \n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#endif\n#ifndef GOLDEN_ANGLE // (3.-sqrt(5.0))*PI radians\n#define GOLDEN_ANGLE 2.39996323\n#endif\n\n\n/*\nauthor: Hugh Kennedy (https://github.com/hughsk)\ndescription: sine easing. From https://github.com/stackgl/glsl-easings\nuse: sine<In|Out|InOut>(<float> x)\nlicense: |\n  This software is released under the MIT license:\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_SINEIN\n#define FNC_SINEIN\nfloat sineIn(in float t) {\n    return sin((t - 1.0) * HALF_PI) + 1.0;\n}\n#endif\n\n#ifndef FNC_SINEOUT\n#define FNC_SINEOUT\nfloat sineOut(in float t) {\n    return sin(t * HALF_PI);\n}\n#endif\n\n#ifndef FNC_SINEINOUT\n#define FNC_SINEINOUT\nfloat sineInOut(in float t) {\n    return -0.5 * (cos(PI * t) - 1.0);\n}\n#endif\n'},976:e=>{e.exports="/*\nauthor: Jamie Owen\ndescription: Photoshop Add blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendAdd(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDADD\n#define FNC_BLENDADD\nfloat blendAdd(in float base, in float blend) {\n    return min(base + blend, 1.);\n}\n\nvec3 blendAdd(in vec3 base, in vec3 blend) {\n    return min(base + blend, vec3(1.));\n}\n\nvec3 blendAdd(in vec3 base, in vec3 blend, float opacity) {\n    return (blendAdd(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Average blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendAverage(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDAVERAGE\n#define FNC_BLENDAVERAGE\nfloat blendAverage(in float base, in float blend) {\n    return (base + blend) * .5;\n}\n\nvec3 blendAverage(in vec3 base, in vec3 blend) {\n    return (base + blend) * .5;\n}\n\nvec3 blendAverage(in vec3 base, in vec3 blend, float opacity) {\n    return (blendAverage(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Color Dodge blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendColorDodge(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDCOLORDODGE\n#define FNC_BLENDCOLORDODGE\nfloat blendColorDodge(in float base, in float blend) {\n    return (blend == 1.)? blend: min( base / (1. - blend), 1.);\n}\n\nvec3 blendColorDodge(in vec3 base, in vec3 blend) {\n    return vec3(blendColorDodge(base.r, blend.r),\n                blendColorDodge(base.g, blend.g),\n                blendColorDodge(base.b, blend.b));\n}\n\nvec3 blendColorDodge(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendColorDodge(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Difference blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendDifference(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDDIFFERENCE\n#define FNC_BLENDDIFFERENCE\nfloat blendDifference(in float base, in float blend) {\n    return abs(base-blend);\n}\n\nvec3 blendDifference(in vec3 base, in vec3 blend) {\n    return abs(base-blend);\n}\n\nvec3 blendDifference(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendDifference(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Reflect blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendReflect(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDREFLECT\n#define FNC_BLENDREFLECT\nfloat blendReflect(in float base, in float blend) {\n    return (blend == 1.)? blend : min(base * base / (1. - blend), 1.);\n}\n\nvec3 blendReflect(in vec3 base, in vec3 blend) {\n    return vec3(blendReflect(base.r, blend.r),\n                blendReflect(base.g, blend.g),\n                blendReflect(base.b, blend.b));\n}\n\nvec3 blendReflect(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendReflect(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Glow blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendGlow(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDGLOW\n#define FNC_BLENDGLOW\nfloat blendGlow(in float base, in float blend) {\n    return blendReflect(blend, base);\n}\n\nvec3 blendGlow(in vec3 base, in vec3 blend) {\n    return blendReflect(blend, base);\n}\n\nvec3 blendGlow(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendGlow(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Color Burn blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendColorBurn(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDCOLORBURN\n#define FNC_BLENDCOLORBURN\nfloat blendColorBurn(in float base, in float blend) {\n    return (blend == 0.)? blend: max((1. - ((1. - base ) / blend)), 0.);\n}\n\nvec3 blendColorBurn(in vec3 base, in vec3 blend) {\n    return vec3(blendColorBurn(base.r, blend.r),\n                blendColorBurn(base.g, blend.g),\n                blendColorBurn(base.b, blend.b));\n}\n\nvec3 blendColorBurn(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendColorBurn(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Color Dodge blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendColorDodge(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDCOLORDODGE\n#define FNC_BLENDCOLORDODGE\nfloat blendColorDodge(in float base, in float blend) {\n    return (blend == 1.)? blend: min( base / (1. - blend), 1.);\n}\n\nvec3 blendColorDodge(in vec3 base, in vec3 blend) {\n    return vec3(blendColorDodge(base.r, blend.r),\n                blendColorDodge(base.g, blend.g),\n                blendColorDodge(base.b, blend.b));\n}\n\nvec3 blendColorDodge(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendColorDodge(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Vivid Light blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendVividLight(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDVIVIDLIGHT\n#define FNC_BLENDVIVIDLIGHT\nfloat blendVividLight(in float base, in float blend) {\n    return (blend < .5)? blendColorBurn(base, (2.*blend)): blendColorDodge(base, (2. * (blend - .5)));\n}\n\nvec3 blendVividLight(in vec3 base, in vec3 blend) {\n    return vec3(blendVividLight(base.r, blend.r),\n                            blendVividLight(base.g, blend.g),\n                            blendVividLight(base.b, blend.b));\n}\n\nvec3 blendVividLight(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendVividLight(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Hard Mix blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendHardMix(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDHARDMIX\n#define FNC_BLENDHARDMIX\nfloat blendHardMix(in float base, in float blend) {\n    return (blendVividLight(base, blend) < .5)? 0.: 1.;\n}\n\nvec3 blendHardMix(in vec3 base, in vec3 blend) {\n    return vec3(blendHardMix(base.r, blend.r),\n                blendHardMix(base.g, blend.g),\n                blendHardMix(base.b, blend.b));\n}\n\nvec3 blendHardMix(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendHardMix(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Linear Burn blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendLinearBurn(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDLINEARBURN\n#define FNC_BLENDLINEARBURN\nfloat blendLinearBurn(in float base, in float blend) {\n  // Note : Same implementation as BlendSubtractf\n    return max(base + blend - 1., 0.);\n}\n\nvec3 blendLinearBurn(in vec3 base, in vec3 blend) {\n  // Note : Same implementation as BlendSubtract\n    return max(base + blend - vec3(1.), vec3(0.));\n}\n\nvec3 blendLinearBurn(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendLinearBurn(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Linear Dodge blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendLinearDodge(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDLINEARDODGE\n#define FNC_BLENDLINEARDODGE\nfloat blendLinearDodge(in float base, in float blend) {\n  // Note : Same implementation as BlendAddf\n    return min(base + blend, 1.);\n}\n\nvec3 blendLinearDodge(in vec3 base, in vec3 blend) {\n  // Note : Same implementation as BlendAdd\n    return min(base + blend, vec3(1.));\n}\n\nvec3 blendLinearDodge(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendLinearDodge(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Linear Burn blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendLinearBurn(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDLINEARBURN\n#define FNC_BLENDLINEARBURN\nfloat blendLinearBurn(in float base, in float blend) {\n  // Note : Same implementation as BlendSubtractf\n    return max(base + blend - 1., 0.);\n}\n\nvec3 blendLinearBurn(in vec3 base, in vec3 blend) {\n  // Note : Same implementation as BlendSubtract\n    return max(base + blend - vec3(1.), vec3(0.));\n}\n\nvec3 blendLinearBurn(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendLinearBurn(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Linear Light blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendLinearLigth(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDLINEARLIGHT\n#define FNC_BLENDLINEARLIGHT\nfloat blendLinearLigth(in float base, in float blend) {\n  return blend < .5? blendLinearBurn(base, (2. * blend)): blendLinearDodge(base, (2. * (blend- .5)));\n}\n\nvec3 blendLinearLigth(in vec3 base, in vec3 blend) {\n  return vec3(blendLinearLigth(base.r, blend.r),\n              blendLinearLigth(base.g, blend.g),\n              blendLinearLigth(base.b, blend.b));\n}\n\nvec3 blendLinearLigth(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendLinearLigth(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Negation blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendNegation(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDNEGATION\n#define FNC_BLENDNEGATION\nfloat blendNegation(in float base, in float blend) {\n    return 1. - abs(1. - base - blend);\n}\n\nvec3 blendNegation(in vec3 base, in vec3 blend) {\n    return vec3(1.) - abs(vec3(1.) - base - blend);\n}\n\nvec3 blendNegation(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendNegation(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Phoenix blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendPhoenix(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDPHOENIX\n#define FNC_BLENDPHOENIX\nfloat blendPhoenix(in float base, in float blend) {\n    return min(base, blend) - max(base, blend) + 1.;\n}\n\nvec3 blendPhoenix(in vec3 base, in vec3 blend) {\n    return min(base, blend) - max(base, blend) + vec3(1.);\n}\n\nvec3 blendPhoenix(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendPhoenix(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Reflect blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendReflect(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDREFLECT\n#define FNC_BLENDREFLECT\nfloat blendReflect(in float base, in float blend) {\n    return (blend == 1.)? blend : min(base * base / (1. - blend), 1.);\n}\n\nvec3 blendReflect(in vec3 base, in vec3 blend) {\n    return vec3(blendReflect(base.r, blend.r),\n                blendReflect(base.g, blend.g),\n                blendReflect(base.b, blend.b));\n}\n\nvec3 blendReflect(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendReflect(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Soft Light blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendSoftLight(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDSOFTLIGHT\n#define FNC_BLENDSOFTLIGHT\nfloat blendSoftLight(in float base, in float blend) {\n    return (blend < .5)? (2. * base * blend + base * base * (1. - 2.*blend)): (sqrt(base) * (2. * blend - 1.) + 2. * base * (1. - blend));\n}\n\nvec3 blendSoftLight(in vec3 base, in vec3 blend) {\n    return vec3(blendSoftLight(base.r, blend.r),\n                blendSoftLight(base.g, blend.g),\n                blendSoftLight(base.b, blend.b));\n}\n\nvec4 blendSoftLight(in vec4 base, in vec4 blend) {\n    return vec4(blendSoftLight( base.r, blend.r ),\n                blendSoftLight( base.g, blend.g ),\n                blendSoftLight( base.b, blend.b ),\n                blendSoftLight( base.a, blend.a )\n    );\n}\n\nvec3 blendSoftLight(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendSoftLight(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Color Burn blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendColorBurn(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDCOLORBURN\n#define FNC_BLENDCOLORBURN\nfloat blendColorBurn(in float base, in float blend) {\n    return (blend == 0.)? blend: max((1. - ((1. - base ) / blend)), 0.);\n}\n\nvec3 blendColorBurn(in vec3 base, in vec3 blend) {\n    return vec3(blendColorBurn(base.r, blend.r),\n                blendColorBurn(base.g, blend.g),\n                blendColorBurn(base.b, blend.b));\n}\n\nvec3 blendColorBurn(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendColorBurn(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Color Dodge blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendColorDodge(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDCOLORDODGE\n#define FNC_BLENDCOLORDODGE\nfloat blendColorDodge(in float base, in float blend) {\n    return (blend == 1.)? blend: min( base / (1. - blend), 1.);\n}\n\nvec3 blendColorDodge(in vec3 base, in vec3 blend) {\n    return vec3(blendColorDodge(base.r, blend.r),\n                blendColorDodge(base.g, blend.g),\n                blendColorDodge(base.b, blend.b));\n}\n\nvec3 blendColorDodge(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendColorDodge(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Vivid Light blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendVividLight(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDVIVIDLIGHT\n#define FNC_BLENDVIVIDLIGHT\nfloat blendVividLight(in float base, in float blend) {\n    return (blend < .5)? blendColorBurn(base, (2.*blend)): blendColorDodge(base, (2. * (blend - .5)));\n}\n\nvec3 blendVividLight(in vec3 base, in vec3 blend) {\n    return vec3(blendVividLight(base.r, blend.r),\n                            blendVividLight(base.g, blend.g),\n                            blendVividLight(base.b, blend.b));\n}\n\nvec3 blendVividLight(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendVividLight(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Color Burn blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendColorBurn(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDCOLORBURN\n#define FNC_BLENDCOLORBURN\nfloat blendColorBurn(in float base, in float blend) {\n    return (blend == 0.)? blend: max((1. - ((1. - base ) / blend)), 0.);\n}\n\nvec3 blendColorBurn(in vec3 base, in vec3 blend) {\n    return vec3(blendColorBurn(base.r, blend.r),\n                blendColorBurn(base.g, blend.g),\n                blendColorBurn(base.b, blend.b));\n}\n\nvec3 blendColorBurn(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendColorBurn(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Darken blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendDarken(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDDARKEN\n#define FNC_BLENDDARKEN\nfloat blendDarken(in float base, in float blend) {\n    return min(blend,base);\n}\n\nvec3 blendDarken(in vec3 base, in vec3 blend) {\n    return vec3(blendDarken(base.r, blend.r),\n                blendDarken(base.g, blend.g),\n                blendDarken(base.b, blend.b));\n}\n\nvec3 blendDarken(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendDarken(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Exclusion blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendExclusion(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDEXCLUSION\n#define FNC_BLENDEXCLUSION\nfloat blendExclusion(in float base, in float blend) {\n    return base + blend - 2. * base * blend;\n}\n\nvec3 blendExclusion(in vec3 base, in vec3 blend) {\n    return base + blend - 2. * base * blend;\n}\n\nvec3 blendExclusion(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendExclusion(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Overlay blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendOverlay(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDOVERLAY\n#define FNC_BLENDOVERLAY\nfloat blendOverlay(in float base, in float blend) {\n    return (base < .5)? (2.*base*blend): (1. - 2. * (1. - base) * (1. - blend));\n}\n\nvec3 blendOverlay(in vec3 base, in vec3 blend) {\n    return vec3(blendOverlay(base.r, blend.r),\n                blendOverlay(base.g, blend.g),\n                blendOverlay(base.b, blend.b));\n}\n\nvec3 blendOverlay(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendOverlay(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop HardLight blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendHardLight(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDHARDLIGHT\n#define FNC_BLENDHARDLIGHT\nfloat blendHardLight(in float base, in float blend) {\n    return blendOverlay(blend, base);\n}\n\nvec3 blendHardLight(in vec3 base, in vec3 blend) {\n    return blendOverlay(blend, base);\n}\n\nvec3 blendHardLight(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendHardLight(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Lighten blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendLighten(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDLIGHTEN\n#define FNC_BLENDLIGHTEN\nfloat blendLighten(in float base, in float blend) {\n    return max(blend, base);\n}\n\nvec3 blendLighten(in vec3 base, in vec3 blend) {\n    return vec3(blendLighten(base.r, blend.r),\n                blendLighten(base.g, blend.g),\n                blendLighten(base.b, blend.b));\n}\n\nvec3 blendLighten(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendLighten(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Linear Dodge blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendLinearDodge(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDLINEARDODGE\n#define FNC_BLENDLINEARDODGE\nfloat blendLinearDodge(in float base, in float blend) {\n  // Note : Same implementation as BlendAddf\n    return min(base + blend, 1.);\n}\n\nvec3 blendLinearDodge(in vec3 base, in vec3 blend) {\n  // Note : Same implementation as BlendAdd\n    return min(base + blend, vec3(1.));\n}\n\nvec3 blendLinearDodge(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendLinearDodge(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Multiply blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendMultiply(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDMULTIPLY\n#define FNC_BLENDMULTIPLY\nfloat blendMultiply(in float base, in float blend) {\n    return base * blend;\n}\n\nvec3 blendMultiply(in vec3 base, in vec3 blend) {\n    return base * blend;\n}\n\nvec3 blendMultiply(in vec3 base, in vec3 blend, float opacity) {\n    return (blendMultiply(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Overlay blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendOverlay(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDOVERLAY\n#define FNC_BLENDOVERLAY\nfloat blendOverlay(in float base, in float blend) {\n    return (base < .5)? (2.*base*blend): (1. - 2. * (1. - base) * (1. - blend));\n}\n\nvec3 blendOverlay(in vec3 base, in vec3 blend) {\n    return vec3(blendOverlay(base.r, blend.r),\n                blendOverlay(base.g, blend.g),\n                blendOverlay(base.b, blend.b));\n}\n\nvec3 blendOverlay(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendOverlay(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Lighten blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendLighten(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDLIGHTEN\n#define FNC_BLENDLIGHTEN\nfloat blendLighten(in float base, in float blend) {\n    return max(blend, base);\n}\n\nvec3 blendLighten(in vec3 base, in vec3 blend) {\n    return vec3(blendLighten(base.r, blend.r),\n                blendLighten(base.g, blend.g),\n                blendLighten(base.b, blend.b));\n}\n\nvec3 blendLighten(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendLighten(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Darken blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendDarken(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDDARKEN\n#define FNC_BLENDDARKEN\nfloat blendDarken(in float base, in float blend) {\n    return min(blend,base);\n}\n\nvec3 blendDarken(in vec3 base, in vec3 blend) {\n    return vec3(blendDarken(base.r, blend.r),\n                blendDarken(base.g, blend.g),\n                blendDarken(base.b, blend.b));\n}\n\nvec3 blendDarken(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendDarken(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Pin Light blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendPinLight(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDPINLIGHT\n#define FNC_BLENDPINLIGHT\nfloat blendPinLight(in float base, in float blend) {\n    return (blend < .5)? blendDarken(base, (2.*blend)): blendLighten(base, (2. * (blend - .5)));\n}\n\nvec3 blendPinLight(in vec3 base, in vec3 blend) {\n    return vec3(blendPinLight(base.r, blend.r),\n                blendPinLight(base.g, blend.g),\n                blendPinLight(base.b, blend.b));\n}\n\nvec3 blendPinLight(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendPinLight(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Screen blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendScreen(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDSCREEN\n#define FNC_BLENDSCREEN\nfloat blendScreen(in float base, in float blend) {\n    return 1. - ((1. - base) * (1. - blend));\n}\n\nvec3 blendScreen(in vec3 base, in vec3 blend) {\n    return vec3(blendScreen(base.r, blend.r),\n                blendScreen(base.g, blend.g),\n                blendScreen(base.b, blend.b));\n}\n\nvec3 blendScreen(in vec3 base, in vec3 blend, float opacity) {\n    return (blendScreen(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Soft Light blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendSubtract(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDSUBTRACT\n#define FNC_BLENDSUBTRACT\nfloat blendSubtract(in float base, in float blend) {\n    return max(base + blend - 1., 0.);\n}\n\nvec3 blendSubtract(in vec3 base, in vec3 blend) {\n    return max(base + blend - vec3(1.), vec3(0.));\n}\n\nvec3 blendSubtract(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendSubtract(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n"},4440:e=>{e.exports="/*\nauthor: Jamie Owen\ndescription: Photoshop Add blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendAdd(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDADD\n#define FNC_BLENDADD\nfloat blendAdd(in float base, in float blend) {\n    return min(base + blend, 1.);\n}\n\nvec3 blendAdd(in vec3 base, in vec3 blend) {\n    return min(base + blend, vec3(1.));\n}\n\nvec3 blendAdd(in vec3 base, in vec3 blend, float opacity) {\n    return (blendAdd(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n"},613:e=>{e.exports="/*\nauthor: Jamie Owen\ndescription: Photoshop Average blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendAverage(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDAVERAGE\n#define FNC_BLENDAVERAGE\nfloat blendAverage(in float base, in float blend) {\n    return (base + blend) * .5;\n}\n\nvec3 blendAverage(in vec3 base, in vec3 blend) {\n    return (base + blend) * .5;\n}\n\nvec3 blendAverage(in vec3 base, in vec3 blend, float opacity) {\n    return (blendAverage(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n"},1135:e=>{e.exports="/*\nauthor: Jamie Owen\ndescription: Photoshop Color Burn blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendColorBurn(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDCOLORBURN\n#define FNC_BLENDCOLORBURN\nfloat blendColorBurn(in float base, in float blend) {\n    return (blend == 0.)? blend: max((1. - ((1. - base ) / blend)), 0.);\n}\n\nvec3 blendColorBurn(in vec3 base, in vec3 blend) {\n    return vec3(blendColorBurn(base.r, blend.r),\n                blendColorBurn(base.g, blend.g),\n                blendColorBurn(base.b, blend.b));\n}\n\nvec3 blendColorBurn(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendColorBurn(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n"},6444:e=>{e.exports="/*\nauthor: Jamie Owen\ndescription: Photoshop Color Dodge blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendColorDodge(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDCOLORDODGE\n#define FNC_BLENDCOLORDODGE\nfloat blendColorDodge(in float base, in float blend) {\n    return (blend == 1.)? blend: min( base / (1. - blend), 1.);\n}\n\nvec3 blendColorDodge(in vec3 base, in vec3 blend) {\n    return vec3(blendColorDodge(base.r, blend.r),\n                blendColorDodge(base.g, blend.g),\n                blendColorDodge(base.b, blend.b));\n}\n\nvec3 blendColorDodge(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendColorDodge(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n"},9976:e=>{e.exports="/*\nauthor: Jamie Owen\ndescription: Photoshop Darken blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendDarken(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDDARKEN\n#define FNC_BLENDDARKEN\nfloat blendDarken(in float base, in float blend) {\n    return min(blend,base);\n}\n\nvec3 blendDarken(in vec3 base, in vec3 blend) {\n    return vec3(blendDarken(base.r, blend.r),\n                blendDarken(base.g, blend.g),\n                blendDarken(base.b, blend.b));\n}\n\nvec3 blendDarken(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendDarken(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n"},313:e=>{e.exports="/*\nauthor: Jamie Owen\ndescription: Photoshop Difference blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendDifference(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDDIFFERENCE\n#define FNC_BLENDDIFFERENCE\nfloat blendDifference(in float base, in float blend) {\n    return abs(base-blend);\n}\n\nvec3 blendDifference(in vec3 base, in vec3 blend) {\n    return abs(base-blend);\n}\n\nvec3 blendDifference(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendDifference(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n"},9220:e=>{e.exports="/*\nauthor: Jamie Owen\ndescription: Photoshop Exclusion blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendExclusion(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDEXCLUSION\n#define FNC_BLENDEXCLUSION\nfloat blendExclusion(in float base, in float blend) {\n    return base + blend - 2. * base * blend;\n}\n\nvec3 blendExclusion(in vec3 base, in vec3 blend) {\n    return base + blend - 2. * base * blend;\n}\n\nvec3 blendExclusion(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendExclusion(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n"},2542:e=>{e.exports="/*\nauthor: Jamie Owen\ndescription: Photoshop Reflect blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendReflect(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDREFLECT\n#define FNC_BLENDREFLECT\nfloat blendReflect(in float base, in float blend) {\n    return (blend == 1.)? blend : min(base * base / (1. - blend), 1.);\n}\n\nvec3 blendReflect(in vec3 base, in vec3 blend) {\n    return vec3(blendReflect(base.r, blend.r),\n                blendReflect(base.g, blend.g),\n                blendReflect(base.b, blend.b));\n}\n\nvec3 blendReflect(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendReflect(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Glow blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendGlow(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDGLOW\n#define FNC_BLENDGLOW\nfloat blendGlow(in float base, in float blend) {\n    return blendReflect(blend, base);\n}\n\nvec3 blendGlow(in vec3 base, in vec3 blend) {\n    return blendReflect(blend, base);\n}\n\nvec3 blendGlow(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendGlow(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n"},4951:e=>{e.exports="/*\nauthor: Jamie Owen\ndescription: Photoshop Overlay blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendOverlay(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDOVERLAY\n#define FNC_BLENDOVERLAY\nfloat blendOverlay(in float base, in float blend) {\n    return (base < .5)? (2.*base*blend): (1. - 2. * (1. - base) * (1. - blend));\n}\n\nvec3 blendOverlay(in vec3 base, in vec3 blend) {\n    return vec3(blendOverlay(base.r, blend.r),\n                blendOverlay(base.g, blend.g),\n                blendOverlay(base.b, blend.b));\n}\n\nvec3 blendOverlay(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendOverlay(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop HardLight blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendHardLight(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDHARDLIGHT\n#define FNC_BLENDHARDLIGHT\nfloat blendHardLight(in float base, in float blend) {\n    return blendOverlay(blend, base);\n}\n\nvec3 blendHardLight(in vec3 base, in vec3 blend) {\n    return blendOverlay(blend, base);\n}\n\nvec3 blendHardLight(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendHardLight(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n"},2078:e=>{e.exports="/*\nauthor: Jamie Owen\ndescription: Photoshop Color Burn blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendColorBurn(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDCOLORBURN\n#define FNC_BLENDCOLORBURN\nfloat blendColorBurn(in float base, in float blend) {\n    return (blend == 0.)? blend: max((1. - ((1. - base ) / blend)), 0.);\n}\n\nvec3 blendColorBurn(in vec3 base, in vec3 blend) {\n    return vec3(blendColorBurn(base.r, blend.r),\n                blendColorBurn(base.g, blend.g),\n                blendColorBurn(base.b, blend.b));\n}\n\nvec3 blendColorBurn(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendColorBurn(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Color Dodge blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendColorDodge(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDCOLORDODGE\n#define FNC_BLENDCOLORDODGE\nfloat blendColorDodge(in float base, in float blend) {\n    return (blend == 1.)? blend: min( base / (1. - blend), 1.);\n}\n\nvec3 blendColorDodge(in vec3 base, in vec3 blend) {\n    return vec3(blendColorDodge(base.r, blend.r),\n                blendColorDodge(base.g, blend.g),\n                blendColorDodge(base.b, blend.b));\n}\n\nvec3 blendColorDodge(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendColorDodge(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Vivid Light blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendVividLight(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDVIVIDLIGHT\n#define FNC_BLENDVIVIDLIGHT\nfloat blendVividLight(in float base, in float blend) {\n    return (blend < .5)? blendColorBurn(base, (2.*blend)): blendColorDodge(base, (2. * (blend - .5)));\n}\n\nvec3 blendVividLight(in vec3 base, in vec3 blend) {\n    return vec3(blendVividLight(base.r, blend.r),\n                            blendVividLight(base.g, blend.g),\n                            blendVividLight(base.b, blend.b));\n}\n\nvec3 blendVividLight(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendVividLight(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Hard Mix blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendHardMix(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDHARDMIX\n#define FNC_BLENDHARDMIX\nfloat blendHardMix(in float base, in float blend) {\n    return (blendVividLight(base, blend) < .5)? 0.: 1.;\n}\n\nvec3 blendHardMix(in vec3 base, in vec3 blend) {\n    return vec3(blendHardMix(base.r, blend.r),\n                blendHardMix(base.g, blend.g),\n                blendHardMix(base.b, blend.b));\n}\n\nvec3 blendHardMix(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendHardMix(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n"},9378:e=>{e.exports="/*\nauthor: Jamie Owen\ndescription: Photoshop Lighten blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendLighten(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDLIGHTEN\n#define FNC_BLENDLIGHTEN\nfloat blendLighten(in float base, in float blend) {\n    return max(blend, base);\n}\n\nvec3 blendLighten(in vec3 base, in vec3 blend) {\n    return vec3(blendLighten(base.r, blend.r),\n                blendLighten(base.g, blend.g),\n                blendLighten(base.b, blend.b));\n}\n\nvec3 blendLighten(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendLighten(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n"},1221:e=>{e.exports="/*\nauthor: Jamie Owen\ndescription: Photoshop Linear Burn blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendLinearBurn(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDLINEARBURN\n#define FNC_BLENDLINEARBURN\nfloat blendLinearBurn(in float base, in float blend) {\n  // Note : Same implementation as BlendSubtractf\n    return max(base + blend - 1., 0.);\n}\n\nvec3 blendLinearBurn(in vec3 base, in vec3 blend) {\n  // Note : Same implementation as BlendSubtract\n    return max(base + blend - vec3(1.), vec3(0.));\n}\n\nvec3 blendLinearBurn(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendLinearBurn(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n"},2527:e=>{e.exports="/*\nauthor: Jamie Owen\ndescription: Photoshop Linear Dodge blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendLinearDodge(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDLINEARDODGE\n#define FNC_BLENDLINEARDODGE\nfloat blendLinearDodge(in float base, in float blend) {\n  // Note : Same implementation as BlendAddf\n    return min(base + blend, 1.);\n}\n\nvec3 blendLinearDodge(in vec3 base, in vec3 blend) {\n  // Note : Same implementation as BlendAdd\n    return min(base + blend, vec3(1.));\n}\n\nvec3 blendLinearDodge(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendLinearDodge(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n"},2021:e=>{e.exports="/*\nauthor: Jamie Owen\ndescription: Photoshop Linear Dodge blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendLinearDodge(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDLINEARDODGE\n#define FNC_BLENDLINEARDODGE\nfloat blendLinearDodge(in float base, in float blend) {\n  // Note : Same implementation as BlendAddf\n    return min(base + blend, 1.);\n}\n\nvec3 blendLinearDodge(in vec3 base, in vec3 blend) {\n  // Note : Same implementation as BlendAdd\n    return min(base + blend, vec3(1.));\n}\n\nvec3 blendLinearDodge(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendLinearDodge(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Linear Burn blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendLinearBurn(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDLINEARBURN\n#define FNC_BLENDLINEARBURN\nfloat blendLinearBurn(in float base, in float blend) {\n  // Note : Same implementation as BlendSubtractf\n    return max(base + blend - 1., 0.);\n}\n\nvec3 blendLinearBurn(in vec3 base, in vec3 blend) {\n  // Note : Same implementation as BlendSubtract\n    return max(base + blend - vec3(1.), vec3(0.));\n}\n\nvec3 blendLinearBurn(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendLinearBurn(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Linear Light blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendLinearLigth(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDLINEARLIGHT\n#define FNC_BLENDLINEARLIGHT\nfloat blendLinearLigth(in float base, in float blend) {\n  return blend < .5? blendLinearBurn(base, (2. * blend)): blendLinearDodge(base, (2. * (blend- .5)));\n}\n\nvec3 blendLinearLigth(in vec3 base, in vec3 blend) {\n  return vec3(blendLinearLigth(base.r, blend.r),\n              blendLinearLigth(base.g, blend.g),\n              blendLinearLigth(base.b, blend.b));\n}\n\nvec3 blendLinearLigth(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendLinearLigth(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n"},4925:e=>{e.exports="/*\nauthor: Jamie Owen\ndescription: Photoshop Multiply blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendMultiply(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDMULTIPLY\n#define FNC_BLENDMULTIPLY\nfloat blendMultiply(in float base, in float blend) {\n    return base * blend;\n}\n\nvec3 blendMultiply(in vec3 base, in vec3 blend) {\n    return base * blend;\n}\n\nvec3 blendMultiply(in vec3 base, in vec3 blend, float opacity) {\n    return (blendMultiply(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n"},823:e=>{e.exports="/*\nauthor: Jamie Owen\ndescription: Photoshop Negation blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendNegation(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDNEGATION\n#define FNC_BLENDNEGATION\nfloat blendNegation(in float base, in float blend) {\n    return 1. - abs(1. - base - blend);\n}\n\nvec3 blendNegation(in vec3 base, in vec3 blend) {\n    return vec3(1.) - abs(vec3(1.) - base - blend);\n}\n\nvec3 blendNegation(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendNegation(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n"},4681:e=>{e.exports="/*\nauthor: Jamie Owen\ndescription: Photoshop Overlay blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendOverlay(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDOVERLAY\n#define FNC_BLENDOVERLAY\nfloat blendOverlay(in float base, in float blend) {\n    return (base < .5)? (2.*base*blend): (1. - 2. * (1. - base) * (1. - blend));\n}\n\nvec3 blendOverlay(in vec3 base, in vec3 blend) {\n    return vec3(blendOverlay(base.r, blend.r),\n                blendOverlay(base.g, blend.g),\n                blendOverlay(base.b, blend.b));\n}\n\nvec3 blendOverlay(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendOverlay(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n"},2435:e=>{e.exports="/*\nauthor: Jamie Owen\ndescription: Photoshop Phoenix blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendPhoenix(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDPHOENIX\n#define FNC_BLENDPHOENIX\nfloat blendPhoenix(in float base, in float blend) {\n    return min(base, blend) - max(base, blend) + 1.;\n}\n\nvec3 blendPhoenix(in vec3 base, in vec3 blend) {\n    return min(base, blend) - max(base, blend) + vec3(1.);\n}\n\nvec3 blendPhoenix(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendPhoenix(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n"},8186:e=>{e.exports="/*\nauthor: Jamie Owen\ndescription: Photoshop Lighten blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendLighten(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDLIGHTEN\n#define FNC_BLENDLIGHTEN\nfloat blendLighten(in float base, in float blend) {\n    return max(blend, base);\n}\n\nvec3 blendLighten(in vec3 base, in vec3 blend) {\n    return vec3(blendLighten(base.r, blend.r),\n                blendLighten(base.g, blend.g),\n                blendLighten(base.b, blend.b));\n}\n\nvec3 blendLighten(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendLighten(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Darken blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendDarken(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDDARKEN\n#define FNC_BLENDDARKEN\nfloat blendDarken(in float base, in float blend) {\n    return min(blend,base);\n}\n\nvec3 blendDarken(in vec3 base, in vec3 blend) {\n    return vec3(blendDarken(base.r, blend.r),\n                blendDarken(base.g, blend.g),\n                blendDarken(base.b, blend.b));\n}\n\nvec3 blendDarken(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendDarken(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Pin Light blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendPinLight(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDPINLIGHT\n#define FNC_BLENDPINLIGHT\nfloat blendPinLight(in float base, in float blend) {\n    return (blend < .5)? blendDarken(base, (2.*blend)): blendLighten(base, (2. * (blend - .5)));\n}\n\nvec3 blendPinLight(in vec3 base, in vec3 blend) {\n    return vec3(blendPinLight(base.r, blend.r),\n                blendPinLight(base.g, blend.g),\n                blendPinLight(base.b, blend.b));\n}\n\nvec3 blendPinLight(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendPinLight(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n"},8622:e=>{e.exports="/*\nauthor: Jamie Owen\ndescription: Photoshop Reflect blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendReflect(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDREFLECT\n#define FNC_BLENDREFLECT\nfloat blendReflect(in float base, in float blend) {\n    return (blend == 1.)? blend : min(base * base / (1. - blend), 1.);\n}\n\nvec3 blendReflect(in vec3 base, in vec3 blend) {\n    return vec3(blendReflect(base.r, blend.r),\n                blendReflect(base.g, blend.g),\n                blendReflect(base.b, blend.b));\n}\n\nvec3 blendReflect(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendReflect(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n"},9600:e=>{e.exports="/*\nauthor: Jamie Owen\ndescription: Photoshop Screen blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendScreen(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDSCREEN\n#define FNC_BLENDSCREEN\nfloat blendScreen(in float base, in float blend) {\n    return 1. - ((1. - base) * (1. - blend));\n}\n\nvec3 blendScreen(in vec3 base, in vec3 blend) {\n    return vec3(blendScreen(base.r, blend.r),\n                blendScreen(base.g, blend.g),\n                blendScreen(base.b, blend.b));\n}\n\nvec3 blendScreen(in vec3 base, in vec3 blend, float opacity) {\n    return (blendScreen(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n"},9556:e=>{e.exports="/*\nauthor: Jamie Owen\ndescription: Photoshop Soft Light blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendSoftLight(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDSOFTLIGHT\n#define FNC_BLENDSOFTLIGHT\nfloat blendSoftLight(in float base, in float blend) {\n    return (blend < .5)? (2. * base * blend + base * base * (1. - 2.*blend)): (sqrt(base) * (2. * blend - 1.) + 2. * base * (1. - blend));\n}\n\nvec3 blendSoftLight(in vec3 base, in vec3 blend) {\n    return vec3(blendSoftLight(base.r, blend.r),\n                blendSoftLight(base.g, blend.g),\n                blendSoftLight(base.b, blend.b));\n}\n\nvec4 blendSoftLight(in vec4 base, in vec4 blend) {\n    return vec4(blendSoftLight( base.r, blend.r ),\n                blendSoftLight( base.g, blend.g ),\n                blendSoftLight( base.b, blend.b ),\n                blendSoftLight( base.a, blend.a )\n    );\n}\n\nvec3 blendSoftLight(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendSoftLight(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n"},5232:e=>{e.exports="/*\nauthor: Jamie Owen\ndescription: Photoshop Soft Light blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendSubtract(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDSUBTRACT\n#define FNC_BLENDSUBTRACT\nfloat blendSubtract(in float base, in float blend) {\n    return max(base + blend - 1., 0.);\n}\n\nvec3 blendSubtract(in vec3 base, in vec3 blend) {\n    return max(base + blend - vec3(1.), vec3(0.));\n}\n\nvec3 blendSubtract(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendSubtract(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n"},971:e=>{e.exports="/*\nauthor: Jamie Owen\ndescription: Photoshop Color Burn blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendColorBurn(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDCOLORBURN\n#define FNC_BLENDCOLORBURN\nfloat blendColorBurn(in float base, in float blend) {\n    return (blend == 0.)? blend: max((1. - ((1. - base ) / blend)), 0.);\n}\n\nvec3 blendColorBurn(in vec3 base, in vec3 blend) {\n    return vec3(blendColorBurn(base.r, blend.r),\n                blendColorBurn(base.g, blend.g),\n                blendColorBurn(base.b, blend.b));\n}\n\nvec3 blendColorBurn(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendColorBurn(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Color Dodge blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendColorDodge(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDCOLORDODGE\n#define FNC_BLENDCOLORDODGE\nfloat blendColorDodge(in float base, in float blend) {\n    return (blend == 1.)? blend: min( base / (1. - blend), 1.);\n}\n\nvec3 blendColorDodge(in vec3 base, in vec3 blend) {\n    return vec3(blendColorDodge(base.r, blend.r),\n                blendColorDodge(base.g, blend.g),\n                blendColorDodge(base.b, blend.b));\n}\n\nvec3 blendColorDodge(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendColorDodge(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Vivid Light blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendVividLight(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDVIVIDLIGHT\n#define FNC_BLENDVIVIDLIGHT\nfloat blendVividLight(in float base, in float blend) {\n    return (blend < .5)? blendColorBurn(base, (2.*blend)): blendColorDodge(base, (2. * (blend - .5)));\n}\n\nvec3 blendVividLight(in vec3 base, in vec3 blend) {\n    return vec3(blendVividLight(base.r, blend.r),\n                            blendVividLight(base.g, blend.g),\n                            blendVividLight(base.b, blend.b));\n}\n\nvec3 blendVividLight(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendVividLight(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n"},8131:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: modify brightness and contrast\nuse: brightnessContrast(<float|vec3|vec4> color, <float> brightness, <float> amcontrastount)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_BRIGHTNESSCONTRAST\n#define FNC_BRIGHTNESSCONTRAST\nfloat brightnessContrast( float value, float brightness, float contrast ) {\n    return ( value - 0.5 ) * contrast + 0.5 + brightness;\n}\n\nvec3 brightnessContrast( vec3 color, float brightness, float contrast ) {\n    return ( color - 0.5 ) * contrast + 0.5 + brightness;\n}\n\nvec4 brightnessContrast( vec4 color, float brightness, float contrast ) {\n    return vec4(brightnessContrast(color.rgb, brightness, contrast), color.a);\n}\n#endif'},2743:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: generate a matrix to change a the brightness of any color\nuse: brightnessMatrix(<float> amount)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_BRIGHTNESSMATRIX\n#define FNC_BRIGHTNESSMATRIX\nmat4 brightnessMatrix(in float amount) {\n    return mat4(  1., 0., 0., 0.,\n                  0., 1., 0., 0.,\n                  0., 0., 1., 0.,\n                  amount, amount, amount, 1. );\n}\n#endif\n'},1663:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: generate a matrix to change a the contrast of any color\nuse: contrastMatrix(<float> amount)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_CONTRASTMATRIX\n#define FNC_CONTRASTMATRIX\nmat4 contrastMatrix(in float amount) {\n    float t = ( 1. - amount ) * .5;\n    return mat4( amount, .0, .0, .0,\n                .0, amount, .0, .0,\n                .0, .0, amount, .0,\n                t,   t,      t, 1. );\n}\n#endif\n'},3346:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo  \ndescription: convert rgb to LMS. LMS (long, medium, short), is a color space which represents the response of the three types of cones of the human eye, named for their responsivity (sensitivity) peaks at long, medium, and short wavelengths. https://en.wikipedia.org/wiki/LMS_color_space\nuse: rgb2lms(<vec3|vec4> rgb)\nlicense: |\n  Copyright (c) 2021 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n\n#ifndef FNC_RGB2LMS\n#define FNC_RGB2LMS\nvec3 rgb2lms(vec3 rgb) {\n    return vec3(\n        (17.8824 * rgb.r) + (43.5161 * rgb.g) + (4.11935 * rgb.b),\n        (3.45565 * rgb.r) + (27.1554 * rgb.g) + (3.86714 * rgb.b),\n        (0.0299566 * rgb.r) + (0.184309 * rgb.g) + (1.46709 * rgb.b)\n    );\n}\n#endif\n/*\nauthor: Patricio Gonzalez Vivo  \ndescription: convert LST to RGB. LMS (long, medium, short), is a color space which represents the response of the three types of cones of the human eye, named for their responsivity (sensitivity) peaks at long, medium, and short wavelengths. https://en.wikipedia.org/wiki/LMS_color_space\nuse: lms2rgb(<vec3|vec4> rgb)\nlicense: |\n  Copyright (c) 2021 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n\n#ifndef FNC_LMS2RGB\n#define FNC_LMS2RGB\nvec3 lms2rgb(vec3 lms) {\n    return vec3( \n        (0.0809444479 * lms.x) + (-0.130504409 * lms.y) + (0.116721066 * lms.z),\n        (-0.0102485335 * lms.x) + (0.0540193266 * lms.y) + (-0.113614708 * lms.z),\n        (-0.000365296938 * lms.x) + (-0.00412161469 * lms.y) + (0.693511405 * lms.z)\n    );\n}\n#endif\n\n/*\nauthor: Patricio Gonzalez Vivo  \ndescription: daltonize functions based on https://web.archive.org/web/20081014161121/http://www.colorjack.com/labs/colormatrix/ http://www.daltonize.org/search/label/Daltonize\nuse: daltonize(<vec3|vec4> rgb)\noptions:\n    DALTONIZE_FNC: daltonizeProtanope, daltonizeProtanopia, daltonizeProtanomaly, daltonizeDeuteranope, daltonizeDeuteranopia, daltonizeDeuteranomaly, daltonizeTritanope, daltonizeTritanopia, daltonizeTritanomaly, daltonizeAchromatopsia and daltonizeAchromatomaly\nlicense: |\n  Copyright (c) 2021 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef DALTONIZE_FNC\n#define DALTONIZE_FNC daltonizeProtanope\n#endif \n\n#ifndef FNC_DALTONIZE\n#define FNC_DALTONIZE\n\n// Protanope - reds are greatly reduced (1% men)\nvec3 daltonizeProtanope(vec3 rgb) {\n    vec3 lms = rgb2lms(rgb);\n\n    lms.x = 0.0 * lms.x + 2.02344 * lms.y + -2.52581 * lms.z;\n    lms.y = 0.0 * lms.x + 1.0 * lms.y + 0.0 * lms.z;\n    lms.z = 0.0 * lms.x + 0.0 * lms.y + 1.0 * lms.z;\n\n    return lms2rgb(lms);\n}\n\nvec4 daltonizeProtanope(vec4 rgba) {\n    return vec4(daltonizeProtanope(rgba.rgb), rgba.a);\n}\n\nvec3 daltonizeProtanopia(vec3 rgb) {\n    return vec3(rgb.r * 0.56667 + rgb.g * 0.43333 + rgb.b * 0.00000,\n                rgb.r * 0.55833 + rgb.g * 0.44267 + rgb.b * 0.00000,\n                rgb.r * 0.00000 + rgb.g * 0.24167 + rgb.b * 0.75833);\n}\n\nvec4 daltonizeProtanopia(vec4 rgba) {\n    return vec4(daltonizeProtanopia(rgba.rgb), rgba.a);\n}\n\nvec3 daltonizeProtanomaly(vec3 rgb) {\n    return vec3(rgb.r * 0.81667 + rgb.g * 0.18333 + rgb.b * 0.00000,\n                rgb.r * 0.33333 + rgb.g * 0.66667 + rgb.b * 0.00000,\n                rgb.r * 0.00000 + rgb.g * 0.12500 + rgb.b * 0.87500);\n}\n\nvec4 daltonizeProtanomaly(vec4 rgba) {\n    return vec4(daltonizeProtanomaly(rgba.rgb), rgba.a);\n}\n\n// Deuteranope - greens are greatly reduced (1% men)\nvec3 daltonizeDeuteranope(vec3 rgb) {\n    vec3 lms = rgb2lms(rgb);\n\n    lms.x = 1.0 * lms.x + 0.0 * lms.y + 0.0 * lms.z;\n    lms.y = 0.494207 * lms.x + 0.0 * lms.y + 1.24827 * lms.z;\n    lms.z = 0.0 * lms.x + 0.0 * lms.y + 1.0 * lms.z;\n\n    return lms2rgb(lms);\n}\n\nvec4 daltonizeDeuteranope(vec4 rgba) {\n    return vec4(daltonizeDeuteranope(rgba.rgb), rgba.a);\n}\n\nvec3 daltonizeDeuteranopia(vec3 rgb) {\n    return vec3(rgb.r * 0.62500 + rgb.g * 0.37500 + rgb.b * 0.00000,\n                rgb.r * 0.70000 + rgb.g * 0.30000 + rgb.b * 0.00000,\n                rgb.r * 0.00000 + rgb.g * 0.30000 + rgb.b * 0.70000);\n}\n\nvec4 daltonizeDeuteranopia(vec4 rgba) {\n    return vec4(daltonizeDeuteranopia(rgba.rgb), rgba.a);\n}\n\nvec3 daltonizeDeuteranomaly(vec3 rgb) {\n    return vec3(rgb.r * 0.80000 + rgb.g * 0.20000 + rgb.b * 0.00000,\n                rgb.r * 0.00000 + rgb.g * 0.25833 + rgb.b * 0.74167,\n                rgb.r * 0.00000 + rgb.g * 0.14167 + rgb.b * 0.85833);\n}\n\nvec4 daltonizeDeuteranomaly(vec4 rgba) {\n    return vec4(daltonizeDeuteranomaly(rgba.rgb), rgba.a);\n}\n\n\n// Tritanope - blues are greatly reduced (0.003% population)\nvec3 daltonizeTritanope(vec3 rgb) {\n    vec3 lms = rgb2lms(rgb);\n    \n    // Simulate rgb blindness\n    lms.x = 1.0 * lms.x + 0.0 * lms.y + 0.0 * lms.z;\n    lms.y = 0.0 * lms.x + 1.0 * lms.y + 0.0 * lms.z;\n    lms.z = -0.395913 * lms.x + 0.801109 * lms.y + 0.0 * lms.z;\n    \n    return lms2rgb(lms);\n}\n\nvec4 daltonizeTritanope(vec4 rgba) {\n    return vec4(daltonizeTritanope(rgba.rgb), rgba.a);\n}\n\nvec3 daltonizeTritanopia(vec3 rgb) {\n    return vec3(rgb.r * 0.95 + rgb.g * 0.05 + rgb.b * 0.00000,\n                rgb.r * 0.00000 + rgb.g * 0.43333 + rgb.b * 0.56667,\n                rgb.r * 0.00000 + rgb.g * 0.47500 + rgb.b * 0.52500);\n}\n\nvec4 daltonizeTritanopia(vec4 rgba) {\n    return vec4(daltonizeTritanopia(rgba.rgb), rgba.a);\n}\n\nvec3 daltonizeTritanomaly(vec3 rgb) {\n    return vec3(rgb.r * 0.96667 + rgb.g * 0.33333 + rgb.b * 0.00000,\n                rgb.r * 0.00000 + rgb.g * 0.73333 + rgb.b * 0.26667,\n                rgb.r * 0.00000 + rgb.g * 0.18333 + rgb.b * 0.81667);\n}\n\nvec4 daltonizeTritanomaly(vec4 rgba) {\n    return vec4(daltonizeTritanomaly(rgba.rgb), rgba.a);\n}\n\nvec3 daltonizeAchromatopsia(vec3 rgb) {\n    return vec3(rgb.r * 0.299 + rgb.g * 0.587 + rgb.b * 0.114,\n                rgb.r * 0.299 + rgb.g * 0.587 + rgb.b * 0.114,\n                rgb.r * 0.299 + rgb.g * 0.587 + rgb.b * 0.114);\n}\n\nvec4 daltonizeAchromatopsia(vec4 rgba) {\n    return vec4(daltonizeAchromatopsia(rgba.rgb), rgba.a);\n}\n\nvec3 daltonizeAchromatomaly(vec3 rgb) {\n    return vec3(rgb.r * 0.618 + rgb.g * 0.320 + rgb.b * 0.062,\n                rgb.r * 0.163 + rgb.g * 0.775 + rgb.b * 0.062,\n                rgb.r * 0.163 + rgb.g * 0.320 + rgb.b * 0.516);\n}\n\nvec4 daltonizeAchromatomaly(vec4 rgba) {\n    return vec4(daltonizeAchromatomaly(rgba.rgb), rgba.a);\n}\n\n\n// GENERAL FUNCTION\n\nvec3 daltonize(vec3 rgb) {\n    return DALTONIZE_FNC(rgb);\n}\n\nvec4 daltonize( vec4 rgba ) {\n    return DALTONIZE_FNC(rgba);\n}\n\n// From https://gist.github.com/jcdickinson/580b7fb5cc145cee8740\n//\nvec3 daltonizeCorrection(vec3 rgb) {\n    // Isolate invisible rgbs to rgb vision deficiency (calculate error matrix)\n    vec3 error = (rgb - daltonize(rgb));\n\n    // Shift rgbs towards visible spectrum (apply error modifications)\n    vec3 correction;\n    correction.r = 0.0; // (error.r * 0.0) + (error.g * 0.0) + (error.b * 0.0);\n    correction.g = (error.r * 0.7) + (error.g * 1.0); // + (error.b * 0.0);\n    correction.b = (error.r * 0.7) + (error.b * 1.0); // + (error.g * 0.0);\n\n    // Add compensation to original values\n    correction = rgb + correction;\n\n    return correction.rgb;\n}\n\nvec4 daltonizeCorrection(vec4 rgb) {\n    return vec4(daltonizeCorrection( rgb.rgb ), rgb.a);\n}\n\n#endif'},2799:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: change saturation of a color\nuse: desaturate(<float|vec3|vec4> color, float amount)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_DESATURATE\n#define FNC_DESATURATE\nvec3 desaturate(in vec3 color, in float amount ) {\n    return mix(color, vec3(dot(vec3(.3, .59, .11), color)), amount);\n}\n\nvec4 desaturate(in vec4 color, in float amount ) {\n    return vec4(desaturate(color.rgb, amount), color.a);\n}\n#endif\n'},7427:e=>{e.exports='/*\nauthor: Sam Hocevar\ndescription: pass a color in RGB and get HSB color. From http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nuse: rgb2hsv(<vec3|vec4> color)\nlicence: TODO\n*/\n\n#ifndef FNC_RGB2HSV\n#define FNC_RGB2HSV\nvec3 rgb2hsv(in vec3 c) {\n    vec4 K = vec4(0., -.33333333333333333333, .6666666666666666666, -1.);\n\n#ifdef RGB2HSV_MIX\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n#else\n    vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n    vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n#endif\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6. * d + e)), \n                d / (q.x + e), \n                q.x);\n}\n\nvec4 rgb2hsv(in vec4 c) {\n    return vec4(rgb2hsv(c.rgb), c.a);\n}\n#endif\n/*\nauthor: Inigo Quiles\ndescription: pass a color in HSB and get RGB color. Also use as reference http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nuse: hsv2rgb(<vec3|vec4> color)\nlicense: |\n  This software is released under the MIT license:\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_HSV2RGB\n#define FNC_HSV2RGB\nvec3 hsv2rgb(in vec3 hsb) {\n    vec3 rgb = clamp(abs(mod(hsb.x * 6. + vec3(0., 4., 2.), \n                            6.) - 3.) - 1.,\n                      0.,\n                      1.);\n    #ifdef HSV2RGB_SMOOTH\n    rgb = rgb*rgb*(3. - 2. * rgb);\n    #endif\n    return hsb.z * mix(vec3(1.), rgb, hsb.y);\n}\n\nvec4 hsv2rgb(in vec4 hsb) {\n    return vec4(hsv2rgb(hsb.rgb), hsb.a);\n}\n#endif\n\n/*\nauthor: Johan Ismael\ndescription: shifts color hue\nuse: hueShift(<vec3|vec4> color, <float> amount)\nlicense: |\n  Copyright (c) 2017 Johan Ismael.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_HUESHIFT\n#define FNC_HUESHIFT\nvec3 hueShift(in vec3 color, in float amount) {\n    vec3 hsv = rgb2hsv(color);\n    hsv.r += amount;\n    return hsv2rgb(hsv);\n}\n\nvec4 hueShift(in vec4 color, in float amount) {\n    return vec4(hueShift(color.rgb, amount), color.a);\n}\n#endif`'},177:e=>{e.exports='/*\nauthor: Hugh Kennedy (https://github.com/hughsk)\ndescription: get\'s the luminosity of a color. From https://github.com/hughsk/glsl-luma/blob/master/index.glsl\nuse: rgb2luma(<vec3|vec4> color)\nlicense: |\n  This software is released under the MIT license:\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_RGB2LUMA\n#define FNC_RGB2LUMA\nfloat rgb2luma(in vec3 color) {\n    return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat rgb2luma(in vec4 color) {\n    return rgb2luma(color.rgb);\n}\n#endif\n\n\n/*\nauthor: Hugh Kennedy (https://github.com/hughsk)\ndescription: get the luminosity of a color. From https://github.com/hughsk/glsl-luma/blob/master/index.glsl\nuse: luma(<vec3|vec4> color)\nlicense: |\n  This software is released under the MIT license:\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_LUMA\n#define FNC_LUMA\nfloat luma(float color) {\n    return color;\n}\n\nfloat luma(in vec3 color) {\n    return rgb2luma(color);\n}\n\nfloat luma(in vec4 color) {\n    return rgb2luma(color.rgb);\n}\n#endif\n'},4141:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: clamp a value between 0 and 1\nuse: saturation(<float|vec2|vec3|vec4> value)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef FNC_SATURATE\n#define FNC_SATURATE\n// #define saturate(x) clamp(x, 0.0, 1.0)\nfloat saturate( float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec2 saturate( vec2 x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec3 saturate( vec3 x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec4 saturate( vec4 x) {\n    return clamp(x, 0.0, 1.0);\n}\n#endif\n/*\nAuthor: [Matt DesLauriers, Johan Ismael, Patricio Gonzalez Vivo]\ndescription: Use LUT textures to modify colors (vec4 and vec3) or a position in a gradient (vec2 and floats)\nuse: lut(<sampler2D> texture, <vec4|vec3|vec2|float> value [, int row])\nlicense: |\n    The MIT License (MIT) Copyright (c) 2014 Matt DesLauriers\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n    The MIT License (MIT) Copyright (c) 2017 Patricio Gonzalez Vivo & Johan Ismael.\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef LUT_N_ROWS\n#define LUT_N_ROWS 1\n#endif\n\n#ifndef LUT_CELL_SIZE\n#define LUT_CELL_SIZE 32.0\n#endif\n\n#ifndef FNC_LUT\n#define FNC_LUT\n\n#ifdef LUT_SQUARE \nvec4 lut(in sampler2D tex_lut, in vec4 color, in int offset) {\n    float blueColor = color.b * 63.0;\n    \n    vec2 quad1 = vec2(0.0);\n    quad1.y = floor(floor(blueColor) / 8.0);\n    quad1.x = floor(blueColor) - (quad1.y * 8.0);\n    \n    vec2 quad2 = vec2(0.0);\n    quad2.y = floor(ceil(blueColor) / 8.0);\n    quad2.x = ceil(blueColor) - (quad2.y * 8.0);\n    \n    vec2 texPos1 = vec2(0.0);\n    texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * color.r);\n    texPos1.y = (quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * color.g);\n\n    #ifdef LUT_FLIP_Y\n    texPos1.y = 1.0-texPos1.y;\n    #endif\n    \n    vec2 texPos2 = vec2(0.0);\n    texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * color.r);\n    texPos2.y = (quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * color.g);\n\n    #ifdef LUT_FLIP_Y\n    texPos2.y = 1.0-texPos2.y;\n    #endif\n    \n    vec4 b0 = texture2D(tex_lut, texPos1);\n    vec4 b1 = texture2D(tex_lut, texPos2);\n\n    return mix(b0, b1, fract(blueColor));\n}\n\n#else\n// Data about how the LUTs rows are encoded\nconst float LUT_WIDTH = LUT_CELL_SIZE*LUT_CELL_SIZE;\nconst float LUT_OFFSET = 1./ float( LUT_N_ROWS );\nconst vec4 LUT_SIZE = vec4(LUT_WIDTH, LUT_CELL_SIZE, 1./LUT_WIDTH, 1./LUT_CELL_SIZE);\n\n// Apply LUT to a COLOR\n// ------------------------------------------------------------\nvec4 lut(in sampler2D tex_lut, in vec4 color, in int offset) {\n    vec3 scaledColor = clamp(color.rgb, vec3(0.), vec3(1.)) * (LUT_SIZE.y - 1.);\n    float bFrac = fract(scaledColor.z);\n\n    // offset by 0.5 pixel and fit within range [0.5, width-0.5]\n    // to prevent bilinear filtering with adjacent colors\n    vec2 texc = (.5 + scaledColor.xy) * LUT_SIZE.zw;\n\n    // offset by the blue slice\n    texc.x += (scaledColor.z - bFrac) * LUT_SIZE.w;\n    texc.y *= LUT_OFFSET;\n    texc.y += float(offset) * LUT_OFFSET;\n    #ifndef LUT_FLIP_Y\n    texc.y = 1. - texc.y; \n    #endif\n\n    // sample the 2 adjacent blue slices\n    vec4 b0 = texture2D(tex_lut, texc);\n    vec4 b1 = texture2D(tex_lut, vec2(texc.x + LUT_SIZE.w, texc.y));\n\n    // blend between the 2 adjacent blue slices\n    color = mix(b0, b1, bFrac);\n\n    return color;\n}\n#endif\n\nvec4 lut(in sampler2D tex_lut, in vec4 color) {\n  return lut(tex_lut, color, 0);\n}\n\nvec3 lut(in sampler2D tex_lut, in vec3 color, in int offset) {\n  return lut(tex_lut, vec4(color, 1.), offset).rgb;\n}\n\nvec3 lut(in sampler2D tex_lut, in vec3 color) {\n  return lut(tex_lut, color, 0).rgb;\n}\n\n#endif'},8063:e=>{e.exports='#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef ONE_OVER_PI\n#define ONE_OVER_PI 0.31830988618\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n#ifndef GOLDEN_RATIO\n#define GOLDEN_RATIO 1.6180339887\n#endif\n#ifndef GOLDEN_RATIO_CONJUGATE \n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#endif\n#ifndef GOLDEN_ANGLE // (3.-sqrt(5.0))*PI radians\n#define GOLDEN_ANGLE 2.39996323\n#endif\n\n\n/*\nauthor: Inigo Quiles\ndescription:  Procedural generation of color palette algorithm explained here http://www.iquilezles.org/www/articles/palettes/palettes.htm)\nuse: palette(<float> t, <vec3|vec4> a, <vec3|vec4> b, <vec3|vec4> c, <vec3|vec4> d)\nlicense: |\n  Copyright © 2015 Inigo Quilez\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_PALETTE\n#define FNC_PALETTE\nvec3 palette (in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(TAU * ( c * t + d ));\n}\n\nvec4 palette (in float t, in vec4 a, in vec4 b, in vec4 c, in vec4 d) {\n    return a + b * cos(TAU * ( c * t + d ));\n}\n#endif\n'},8755:e=>{e.exports="#ifndef FNC_FIRE\n#define FNC_FIRE\n\nvec3 fire(float x) {\n    return vec3(1.0, 0.25, 0.0625) * exp(4.0 * x - 1.0);\n}\n\n#endif"},5335:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: heatmap palette\nuse: heatmap(<float> value)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef FNC_HEATMAP\n#define FNC_HEATMAP\nvec3 heatmap(float v) {\n    vec3 r = v * 2.1 - vec3(1.8, 1.14, 0.3);\n    return 1.0 - r * r;\n}\n#endif'},8867:e=>{e.exports='/*\nauthor: Martijn Steinrucken\ndescription: Spectrum Response Function https://www.shadertoy.com/view/wlSBzD\nuse: heatmspectrumap(<float> value)\nlicense: |\n  Copyright (c) 2020 Martijn Steinrucken.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef FNC_SPECTRUM\n#define FNC_SPECTRUM\n\nvec3 spectrum(float x) {\n    return (vec3( 1.220023e0,-1.933277e0, 1.623776e0)\n          +(vec3(-2.965000e1, 6.806567e1,-3.606269e1)\n          +(vec3( 5.451365e2,-7.921759e2, 6.966892e2)\n          +(vec3(-4.121053e3, 4.432167e3,-4.463157e3)\n          +(vec3( 1.501655e4,-1.264621e4, 1.375260e4)\n          +(vec3(-2.904744e4, 1.969591e4,-2.330431e4)\n          +(vec3( 3.068214e4,-1.698411e4, 2.229810e4)\n          +(vec3(-1.675434e4, 7.594470e3,-1.131826e4)\n          + vec3( 3.707437e3,-1.366175e3, 2.372779e3)\n            *x)*x)*x)*x)*x)*x)*x)*x)*x;\n}\n\n#endif'},8980:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: generate a matrix to change a the saturation of any color\nuse: saturationMatrix(<float> amount)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_SATURATIONMATRIX\n#define FNC_SATURATIONMATRIX\nmat4 saturationMatrix(in float amount) {\n    vec3 lum = vec3(.3086, .6094, .0820 );\n\n    float invAmount= 1. - amount;\n\n    vec3 red = vec3(lum.x * invAmount);\n    red += vec3(amount, .0, .0);\n\n    vec3 green = vec3(lum.y * invAmount);\n    green += vec3( .0, amount, .0);\n\n    vec3 blue = vec3(lum.z * invAmount);\n    blue += vec3( .0, .0, amount);\n\n    return mat4(red,        .0,\n                green,      .0,\n                blue,       .0,\n                .0, .0, .0, 1.);\n}\n#endif\n'},82:e=>{e.exports='/*\ndescription: Include all available color spaces conversions\n*/\n\n/*\nauthor: Sam Hocevar\ndescription: pass a color in RGB and get HSB color. From http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nuse: rgb2hsv(<vec3|vec4> color)\nlicence: TODO\n*/\n\n#ifndef FNC_RGB2HSV\n#define FNC_RGB2HSV\nvec3 rgb2hsv(in vec3 c) {\n    vec4 K = vec4(0., -.33333333333333333333, .6666666666666666666, -1.);\n\n#ifdef RGB2HSV_MIX\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n#else\n    vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n    vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n#endif\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6. * d + e)), \n                d / (q.x + e), \n                q.x);\n}\n\nvec4 rgb2hsv(in vec4 c) {\n    return vec4(rgb2hsv(c.rgb), c.a);\n}\n#endif\n/*\nauthor: Inigo Quiles\ndescription: pass a color in HSB and get RGB color. Also use as reference http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nuse: hsv2rgb(<vec3|vec4> color)\nlicense: |\n  This software is released under the MIT license:\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_HSV2RGB\n#define FNC_HSV2RGB\nvec3 hsv2rgb(in vec3 hsb) {\n    vec3 rgb = clamp(abs(mod(hsb.x * 6. + vec3(0., 4., 2.), \n                            6.) - 3.) - 1.,\n                      0.,\n                      1.);\n    #ifdef HSV2RGB_SMOOTH\n    rgb = rgb*rgb*(3. - 2. * rgb);\n    #endif\n    return hsb.z * mix(vec3(1.), rgb, hsb.y);\n}\n\nvec4 hsv2rgb(in vec4 hsb) {\n    return vec4(hsv2rgb(hsb.rgb), hsb.a);\n}\n#endif\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: pass a color in RGB and get it in YUB\nuse: rgb2yuv(<vec3|vec4> color)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_RGB2YUV\n#define FNC_RGB2YUV\n\n#ifdef YUV_SDTV\nconst mat3 rgb2yuv_mat = mat3(\n    .299, -.14713,  .615,\n    .587, -.28886, -.51499,\n    .114,  .436,   -.10001\n);\n#else\nconst mat3 rgb2yuv_mat = mat3(\n    .2126,  -.09991, .615,\n    .7152,  -.33609,-.55861,\n    .0722,   .426,  -.05639\n);\n#endif\n\nvec3 rgb2yuv(in vec3 rgb) {\n    return rgb2yuv_mat * rgb;\n}\n\nvec4 rgb2yuv(in vec4 rgb) {\n    return vec4(rgb2yuv(rgb.rgb),rgb.a);\n}\n#endif\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: pass a color in YUB and get RGB color\nuse: yuv2rgb(<vec3|vec4> color)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_YUV2RGB\n#define FNC_YUV2RGB\n\n#ifdef YUV_SDTV\nconst mat3 yuv2rgb_mat = mat3(\n    1.,       1. ,      1.,\n    0.,       -.39465,  2.03211,\n    1.13983,  -.58060,  0.\n);\n#else\nconst mat3 yuv2rgb_mat = mat3(\n    1.,       1. ,      1.,\n    0.,       -.21482,  2.12798,\n    1.28033,  -.38059,  0.\n);\n#endif\n\nvec3 yuv2rgb(in vec3 yuv) {\n    return yuv2rgb_mat * yuv;\n}\n\nvec4 yuv2rgb(in vec4 yuv) {\n    return vec4(yuv2rgb(yuv.rgb), yuv.a);\n}\n#endif\n\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: Convert from RGB to YIQ which was the followin range\nuse: rgb2yiq(<vec3|vec4> color)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_RGB2YIQ\n#define FNC_RGB2YIQ\nconst mat3 rgb2yiq_mat = mat3(0.299, 0.587, 0.114, 0.596, -0.274, -0.322, 0.212, -0.523, 0.311);\n\nvec3 rgb2yiq(in vec3 rgb) {\n  return rgb2yiq_mat * rgb;\n}\n\nvec4 rgb2yiq(in vec4 rgb) {\n    return vec4(rgb2yiq(rgb.rgb), rgb.a);\n}\n#endif\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: pass a color in YIQ and get RGB color. From https://en.wikipedia.org/wiki/YIQ\nuse: yiq2rgb(<vec3|vec4> color)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_YIQ2RGB\n#define FNC_YIQ2RGB\n\nconst mat3 yiq2rgb_mat = mat3(1.0, 0.956, 0.621, 1.0, -0.272, -0.647, 1.0, -1.105, 1.702);\n\nvec3 yiq2rgb(in vec3 yiq) {\n  return yiq2rgb_mat * yiq;\n}\n\nvec4 yiq2rgb(in vec4 yiq) {\n    return vec4(yiq2rgb(yiq.rgb), yiq.a);\n}\n#endif\n\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: convert RGB to YCbCr according to https://en.wikipedia.org/wiki/YCbCr\nuse: rgb2YCbCr(<vec3|vec4> color)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_RGB2YCBCR\n#define FNC_RGB2YCBCR\nvec3 rgb2YCbCr(in vec3 rgb){\n    float y = dot(rgb, vec3(.299, .587, .114));\n    float cb = .5 + dot(rgb, vec3(-.168736, -.331264, .5));\n    float cr = .5 + dot(rgb, vec3(.5, -.418688, -.081312));\n    return vec3(y, cb, cr);\n}\n\nvec4 rgb2YCbCr(in vec4 rgb) {\n    return vec4(rgb2YCbCr(rgb.rgb),rgb.a);\n}\n#endif\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: convert YCbCr to RGB according to https://en.wikipedia.org/wiki/YCbCr\nuse: YCbCr2rgb(<vec3|vec4> color)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_YCBCR2RGB\n#define FNC_YCBCR2RGB\nvec3 YCbCr2rgb(in vec3 ycbcr) {\n    float cb = ycbcr.y - .5;\n    float cr = ycbcr.z - .5;\n    float y = ycbcr.x;\n    float r = 1.402 * cr;\n    float g = -.344 * cb - .714 * cr;\n    float b = 1.772 * cb;\n    return vec3(r, g, b) + y;\n}\n\nvec4 YCbCr2rgb(in vec4 ycbcr) {\n    return vec4(YCbCr2rgb(ycbcr.rgb),ycbcr.a);\n}\n#endif\n\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: pass a color in RGB and get it in YPbPr from http://www.equasys.de/colorconversion.html\nuse: rgb2YPbPr(<vec3|vec4> color)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_RGB2YPBPR\n#define FNC_RGB2YPBPR\n\n#ifdef YPBPR_SDTV\nconst mat3 rgb2YPbPr_mat = mat3( \n    .299, -.169,  .5,\n    .587, -.331, -.419,\n    .114,  .5,   -.081\n);\n#else\nconst mat3 rgb2YPbPr_mat = mat3( \n    0.2126, -0.1145721060573399,   0.5,\n    0.7152, -0.3854278939426601,  -0.4541529083058166,\n    0.0722,  0.5,                 -0.0458470916941834\n);\n#endif\n\nvec3 rgb2YPbPr(in vec3 rgb) {\n    return rgb2YPbPr_mat * rgb;\n}\n\nvec4 rgb2YPbPr(in vec4 rgb) {\n    return vec4(rgb2YPbPr(rgb.rgb),rgb.a);\n}\n#endif\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: pass a color in RGB and get it in YPbPr from http://www.equasys.de/colorconversion.html\nuse: YPbPr2RGB(<vec3|vec4> color)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_YPBPR2RGB\n#define FNC_YPBPR2RGB\n\n#ifdef YPBPR_SDTV\nconst mat3 YPbPr2rgb_mat = mat3( \n    1.,     1.,       1.,\n    0.,     -.344,    1.772,\n    1.402,  -.714,    0.\n);\n#else\nconst mat3 YPbPr2rgb_mat = mat3( \n    1.,     1.,       1.,\n    0.,     -.187,    1.856,\n    1.575,  -.468,    0.\n);\n#endif\n\nvec3 YPbPr2rgb(in vec3 rgb) {\n    return YPbPr2rgb_mat * rgb;\n}\n\nvec4 YPbPr2rgb(in vec4 rgb) {\n    return vec4(YPbPr2rgb(rgb.rgb),rgb.a);\n}\n#endif\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: convert from linear to gamma color space.\nuse: linear2gamma(<float|vec3|vec4> color)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#if !defined(TARGET_MOBILE) && !defined(GAMMA)\n#define GAMMA 2.2\n#endif\n\n#ifndef FNC_LINEAR2GAMMA\n#define FNC_LINEAR2GAMMA\nvec3 linear2gamma(in vec3 v) {\n#ifdef GAMMA\n    return pow(v, vec3(1. / GAMMA));\n#else\n    // assume gamma 2.0\n    return sqrt(v);\n#endif\n}\n\nvec4 linear2gamma(in vec4 v) {\n    return vec4(linear2gamma(v.rgb), v.a);\n}\n\nfloat linear2gamma(in float v) {\n#ifdef GAMMA\n    return pow(v, 1. / GAMMA);\n#else\n    // assume gamma 2.0\n    return sqrt(v);\n#endif\n}\n#endif\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: convert from gamma to linear color space.\nuse: gamma2linear(<float|vec3|vec4> color)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#if !defined(TARGET_MOBILE) && !defined(GAMMA)\n#define GAMMA 2.2\n#endif\n\n#ifndef FNC_GAMMA2LINEAR\n#define FNC_GAMMA2LINEAR\nfloat gamma2linear(in float v) {\n#ifdef GAMMA\n    return pow(v, GAMMA);\n#else\n    // assume gamma 2.0\n    return v * v;\n#endif\n}\n\nvec3 gamma2linear(in vec3 v) {\n#ifdef GAMMA\n    return pow(v, vec3(GAMMA));\n#else\n    // assume gamma 2.0\n    return v * v;\n#endif\n}\n\nvec4 gamma2linear(in vec4 v) {\n    return vec4(gamma2linear(v.rgb), v.a);\n}\n#endif\n\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: extend GLSL min function to add more arguments\nuse: \n  - min(<float> A, <float> B, <float> C[, <float> D])\n  - min(<vec2|vec3|vec4> A)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n\n*/\n\n#ifndef FNC_MIN\n#define FNC_MIN\nfloat min(in float a, in float b, in float c) {\n  return min(a, min(b, c));\n}\n\nfloat min(in float a, in float b, in float c, in float d) {\n  return min(min(a,b), min(c, d));\n}\n\nfloat min(const vec2 v) {\n    return min(v.x, v.y);\n}\n\nfloat min(const vec3 v) {\n    return min(v.x, v.y, v.z);\n}\n\nfloat min(const vec4 v) {\n    return min(v.x, v.y, v.z, v.w);\n}\n#endif\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: clamp a value between 0 and 1\nuse: saturation(<float|vec2|vec3|vec4> value)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef FNC_SATURATE\n#define FNC_SATURATE\n// #define saturate(x) clamp(x, 0.0, 1.0)\nfloat saturate( float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec2 saturate( vec2 x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec3 saturate( vec3 x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec4 saturate( vec4 x) {\n    return clamp(x, 0.0, 1.0);\n}\n#endif\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: convert CMYK to RGB\nuse: rgb2cmyk(<vec3|vec4> rgba)\nlicense: |\n  Copyright (c) 2021 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_RGB2CMYK\n#define FNC_RGB2CMYK\nvec4 rgb2cmyk(vec3 rgb) {\n    float k = min(1.0 - rgb);\n    float invK = 1.0 - k;\n    vec3 cmy = (1.0 - rgb - k) / invK;\n    cmy *= step(0.0, invK);\n    return saturate(vec4(cmy, k));\n}\n#endif\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: clamp a value between 0 and 1\nuse: saturation(<float|vec2|vec3|vec4> value)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef FNC_SATURATE\n#define FNC_SATURATE\n// #define saturate(x) clamp(x, 0.0, 1.0)\nfloat saturate( float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec2 saturate( vec2 x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec3 saturate( vec3 x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec4 saturate( vec4 x) {\n    return clamp(x, 0.0, 1.0);\n}\n#endif\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: convert CMYK to RGB\nuse: cmyk2rgb(<vec4> cmyk)\nlicense: |\n  Copyright (c) 2021 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_CMYK2RGB\n#define FNC_CMYK2RGB\nvec3 cmyk2rgb(vec4 cmyk) {\n    float invK = 1.0 - cmyk.w;\n    return saturate(1.0-min(vec3(1.0), cmyk.xyz * invK + cmyk.w));\n}\n#endif\n'},9872:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: convert YCbCr to RGB according to https://en.wikipedia.org/wiki/YCbCr\nuse: YCbCr2rgb(<vec3|vec4> color)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_YCBCR2RGB\n#define FNC_YCBCR2RGB\nvec3 YCbCr2rgb(in vec3 ycbcr) {\n    float cb = ycbcr.y - .5;\n    float cr = ycbcr.z - .5;\n    float y = ycbcr.x;\n    float r = 1.402 * cr;\n    float g = -.344 * cb - .714 * cr;\n    float b = 1.772 * cb;\n    return vec3(r, g, b) + y;\n}\n\nvec4 YCbCr2rgb(in vec4 ycbcr) {\n    return vec4(YCbCr2rgb(ycbcr.rgb),ycbcr.a);\n}\n#endif\n'},338:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: pass a color in RGB and get it in YPbPr from http://www.equasys.de/colorconversion.html\nuse: YPbPr2RGB(<vec3|vec4> color)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_YPBPR2RGB\n#define FNC_YPBPR2RGB\n\n#ifdef YPBPR_SDTV\nconst mat3 YPbPr2rgb_mat = mat3( \n    1.,     1.,       1.,\n    0.,     -.344,    1.772,\n    1.402,  -.714,    0.\n);\n#else\nconst mat3 YPbPr2rgb_mat = mat3( \n    1.,     1.,       1.,\n    0.,     -.187,    1.856,\n    1.575,  -.468,    0.\n);\n#endif\n\nvec3 YPbPr2rgb(in vec3 rgb) {\n    return YPbPr2rgb_mat * rgb;\n}\n\nvec4 YPbPr2rgb(in vec4 rgb) {\n    return vec4(YPbPr2rgb(rgb.rgb),rgb.a);\n}\n#endif'},3701:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: convert from gamma to linear color space.\nuse: gamma2linear(<float|vec3|vec4> color)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#if !defined(TARGET_MOBILE) && !defined(GAMMA)\n#define GAMMA 2.2\n#endif\n\n#ifndef FNC_GAMMA2LINEAR\n#define FNC_GAMMA2LINEAR\nfloat gamma2linear(in float v) {\n#ifdef GAMMA\n    return pow(v, GAMMA);\n#else\n    // assume gamma 2.0\n    return v * v;\n#endif\n}\n\nvec3 gamma2linear(in vec3 v) {\n#ifdef GAMMA\n    return pow(v, vec3(GAMMA));\n#else\n    // assume gamma 2.0\n    return v * v;\n#endif\n}\n\nvec4 gamma2linear(in vec4 v) {\n    return vec4(gamma2linear(v.rgb), v.a);\n}\n#endif\n'},9446:e=>{e.exports='/*\nauthor: Inigo Quiles\ndescription: pass a color in HSB and get RGB color. Also use as reference http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nuse: hsv2rgb(<vec3|vec4> color)\nlicense: |\n  This software is released under the MIT license:\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_HSV2RGB\n#define FNC_HSV2RGB\nvec3 hsv2rgb(in vec3 hsb) {\n    vec3 rgb = clamp(abs(mod(hsb.x * 6. + vec3(0., 4., 2.), \n                            6.) - 3.) - 1.,\n                      0.,\n                      1.);\n    #ifdef HSV2RGB_SMOOTH\n    rgb = rgb*rgb*(3. - 2. * rgb);\n    #endif\n    return hsb.z * mix(vec3(1.), rgb, hsb.y);\n}\n\nvec4 hsv2rgb(in vec4 hsb) {\n    return vec4(hsv2rgb(hsb.rgb), hsb.a);\n}\n#endif'},9001:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: convert from linear to gamma color space.\nuse: linear2gamma(<float|vec3|vec4> color)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#if !defined(TARGET_MOBILE) && !defined(GAMMA)\n#define GAMMA 2.2\n#endif\n\n#ifndef FNC_LINEAR2GAMMA\n#define FNC_LINEAR2GAMMA\nvec3 linear2gamma(in vec3 v) {\n#ifdef GAMMA\n    return pow(v, vec3(1. / GAMMA));\n#else\n    // assume gamma 2.0\n    return sqrt(v);\n#endif\n}\n\nvec4 linear2gamma(in vec4 v) {\n    return vec4(linear2gamma(v.rgb), v.a);\n}\n\nfloat linear2gamma(in float v) {\n#ifdef GAMMA\n    return pow(v, 1. / GAMMA);\n#else\n    // assume gamma 2.0\n    return sqrt(v);\n#endif\n}\n#endif\n'},5484:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo  \ndescription: convert LST to RGB. LMS (long, medium, short), is a color space which represents the response of the three types of cones of the human eye, named for their responsivity (sensitivity) peaks at long, medium, and short wavelengths. https://en.wikipedia.org/wiki/LMS_color_space\nuse: lms2rgb(<vec3|vec4> rgb)\nlicense: |\n  Copyright (c) 2021 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n\n#ifndef FNC_LMS2RGB\n#define FNC_LMS2RGB\nvec3 lms2rgb(vec3 lms) {\n    return vec3( \n        (0.0809444479 * lms.x) + (-0.130504409 * lms.y) + (0.116721066 * lms.z),\n        (-0.0102485335 * lms.x) + (0.0540193266 * lms.y) + (-0.113614708 * lms.z),\n        (-0.000365296938 * lms.x) + (-0.00412161469 * lms.y) + (0.693511405 * lms.z)\n    );\n}\n#endif'},9339:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: convert RGB to YCbCr according to https://en.wikipedia.org/wiki/YCbCr\nuse: rgb2YCbCr(<vec3|vec4> color)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_RGB2YCBCR\n#define FNC_RGB2YCBCR\nvec3 rgb2YCbCr(in vec3 rgb){\n    float y = dot(rgb, vec3(.299, .587, .114));\n    float cb = .5 + dot(rgb, vec3(-.168736, -.331264, .5));\n    float cr = .5 + dot(rgb, vec3(.5, -.418688, -.081312));\n    return vec3(y, cb, cr);\n}\n\nvec4 rgb2YCbCr(in vec4 rgb) {\n    return vec4(rgb2YCbCr(rgb.rgb),rgb.a);\n}\n#endif'},6084:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: pass a color in RGB and get it in YPbPr from http://www.equasys.de/colorconversion.html\nuse: rgb2YPbPr(<vec3|vec4> color)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_RGB2YPBPR\n#define FNC_RGB2YPBPR\n\n#ifdef YPBPR_SDTV\nconst mat3 rgb2YPbPr_mat = mat3( \n    .299, -.169,  .5,\n    .587, -.331, -.419,\n    .114,  .5,   -.081\n);\n#else\nconst mat3 rgb2YPbPr_mat = mat3( \n    0.2126, -0.1145721060573399,   0.5,\n    0.7152, -0.3854278939426601,  -0.4541529083058166,\n    0.0722,  0.5,                 -0.0458470916941834\n);\n#endif\n\nvec3 rgb2YPbPr(in vec3 rgb) {\n    return rgb2YPbPr_mat * rgb;\n}\n\nvec4 rgb2YPbPr(in vec4 rgb) {\n    return vec4(rgb2YPbPr(rgb.rgb),rgb.a);\n}\n#endif\n'},1725:e=>{e.exports="/*\nauthor: Sam Hocevar\ndescription: pass a color in RGB and get HSB color. From http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nuse: rgb2hsv(<vec3|vec4> color)\nlicence: TODO\n*/\n\n#ifndef FNC_RGB2HSV\n#define FNC_RGB2HSV\nvec3 rgb2hsv(in vec3 c) {\n    vec4 K = vec4(0., -.33333333333333333333, .6666666666666666666, -1.);\n\n#ifdef RGB2HSV_MIX\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n#else\n    vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n    vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n#endif\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6. * d + e)), \n                d / (q.x + e), \n                q.x);\n}\n\nvec4 rgb2hsv(in vec4 c) {\n    return vec4(rgb2hsv(c.rgb), c.a);\n}\n#endif"},5722:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo  \ndescription: convert rgb to LMS. LMS (long, medium, short), is a color space which represents the response of the three types of cones of the human eye, named for their responsivity (sensitivity) peaks at long, medium, and short wavelengths. https://en.wikipedia.org/wiki/LMS_color_space\nuse: rgb2lms(<vec3|vec4> rgb)\nlicense: |\n  Copyright (c) 2021 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n\n#ifndef FNC_RGB2LMS\n#define FNC_RGB2LMS\nvec3 rgb2lms(vec3 rgb) {\n    return vec3(\n        (17.8824 * rgb.r) + (43.5161 * rgb.g) + (4.11935 * rgb.b),\n        (3.45565 * rgb.r) + (27.1554 * rgb.g) + (3.86714 * rgb.b),\n        (0.0299566 * rgb.r) + (0.184309 * rgb.g) + (1.46709 * rgb.b)\n    );\n}\n#endif'},3713:e=>{e.exports='/*\nauthor: Hugh Kennedy (https://github.com/hughsk)\ndescription: get\'s the luminosity of a color. From https://github.com/hughsk/glsl-luma/blob/master/index.glsl\nuse: rgb2luma(<vec3|vec4> color)\nlicense: |\n  This software is released under the MIT license:\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_RGB2LUMA\n#define FNC_RGB2LUMA\nfloat rgb2luma(in vec3 color) {\n    return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat rgb2luma(in vec4 color) {\n    return rgb2luma(color.rgb);\n}\n#endif\n'},304:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: Convert from RGB to YIQ which was the followin range\nuse: rgb2yiq(<vec3|vec4> color)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_RGB2YIQ\n#define FNC_RGB2YIQ\nconst mat3 rgb2yiq_mat = mat3(0.299, 0.587, 0.114, 0.596, -0.274, -0.322, 0.212, -0.523, 0.311);\n\nvec3 rgb2yiq(in vec3 rgb) {\n  return rgb2yiq_mat * rgb;\n}\n\nvec4 rgb2yiq(in vec4 rgb) {\n    return vec4(rgb2yiq(rgb.rgb), rgb.a);\n}\n#endif\n'},7885:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: pass a color in RGB and get it in YUB\nuse: rgb2yuv(<vec3|vec4> color)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_RGB2YUV\n#define FNC_RGB2YUV\n\n#ifdef YUV_SDTV\nconst mat3 rgb2yuv_mat = mat3(\n    .299, -.14713,  .615,\n    .587, -.28886, -.51499,\n    .114,  .436,   -.10001\n);\n#else\nconst mat3 rgb2yuv_mat = mat3(\n    .2126,  -.09991, .615,\n    .7152,  -.33609,-.55861,\n    .0722,   .426,  -.05639\n);\n#endif\n\nvec3 rgb2yuv(in vec3 rgb) {\n    return rgb2yuv_mat * rgb;\n}\n\nvec4 rgb2yuv(in vec4 rgb) {\n    return vec4(rgb2yuv(rgb.rgb),rgb.a);\n}\n#endif\n'},157:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: pass a color in YIQ and get RGB color. From https://en.wikipedia.org/wiki/YIQ\nuse: yiq2rgb(<vec3|vec4> color)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_YIQ2RGB\n#define FNC_YIQ2RGB\n\nconst mat3 yiq2rgb_mat = mat3(1.0, 0.956, 0.621, 1.0, -0.272, -0.647, 1.0, -1.105, 1.702);\n\nvec3 yiq2rgb(in vec3 yiq) {\n  return yiq2rgb_mat * yiq;\n}\n\nvec4 yiq2rgb(in vec4 yiq) {\n    return vec4(yiq2rgb(yiq.rgb), yiq.a);\n}\n#endif\n'},9323:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: pass a color in YUB and get RGB color\nuse: yuv2rgb(<vec3|vec4> color)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_YUV2RGB\n#define FNC_YUV2RGB\n\n#ifdef YUV_SDTV\nconst mat3 yuv2rgb_mat = mat3(\n    1.,       1. ,      1.,\n    0.,       -.39465,  2.03211,\n    1.13983,  -.58060,  0.\n);\n#else\nconst mat3 yuv2rgb_mat = mat3(\n    1.,       1. ,      1.,\n    0.,       -.21482,  2.12798,\n    1.28033,  -.38059,  0.\n);\n#endif\n\nvec3 yuv2rgb(in vec3 yuv) {\n    return yuv2rgb_mat * yuv;\n}\n\nvec4 yuv2rgb(in vec4 yuv) {\n    return vec4(yuv2rgb(yuv.rgb), yuv.a);\n}\n#endif\n'},6405:e=>{e.exports='/*\nauthor: Brad Larson\ndescription: vibrance from https://github.com/BradLarson/GPUImage/blob/master/framework/Source/GPUImageVibranceFilter.m Vibrance is a smart-tool which cleverly increases the intensity of the more muted colors and leaves the already well-saturated colors alone. Prevents skin tones from becoming overly saturated and unnatural. \nuse: adaptiveThreshold(<float> value, <float> blur_value, <float> bias)\nlicense: |\n  Copyright (c) 2012, Brad Larson, Ben Cochran, Hugues Lismonde, Keitaroh Kobayashi, Alaric Cole, Matthew Clark, Jacob Gundersen, Chris Williams.\n  All rights reserved.\n  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n  Neither the name of the GPUImage framework nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef FNC_VIBRANCE\n#define FNC_VIBRANCE\nvec3 vibrance(in vec3 color, in float v) {\n    float average = (color.r + color.g + color.b) / 3.0;\n    float mx = max(color.r, max(color.g, color.b));\n    float amt = (mx - average) * (-v * 3.0);\n    return mix(color.rgb, vec3(mx), amt);\n}\n#endif'},4249:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: Squared length\nuse: lengthSq(<vec2|float2> st)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n\n*/\n\n#ifndef FNC_LENGTHSQ\n#define FNC_LENGTHSQ\nfloat lengthSq(in vec2 st) {\n    return dot(st, st);\n}\n\nfloat lengthSq(in vec3 pos) {\n    return dot(pos, pos);\n}\n#endif\n\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: Barrel distortion\nuse: barrel(sampler2D tex, <vec2> st, [, <vec2|float> sdf])\noptions:\n    BARREL_DISTANCE: function used to shape the distortion, defaults to radial shape with lengthSq\n    BARREL_TYPE: return type, defaults to vec3\n    BARREL_SAMPLER_FNC: function used to sample the input texture, defaults to texture2D(tex, POS_UV).rgb\n    BARREL_OCT_1: one octave of distortion\n    BARREL_OCT_2: two octaves of distortion\n    BARREL_OCT_3: three octaves of distortion\nlicense: |\n    Copyright (c) 2017 Patricio Gonzalez Vivo\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n\n*/\n\n#ifndef BARREL_DISTANCE\n#define BARREL_DISTANCE dist\n#endif\n\n#ifndef BARREL_TYPE\n#define BARREL_TYPE vec3\n#endif\n\n#ifndef BARREL_SAMPLER_FNC\n#define BARREL_SAMPLER_FNC(POS_UV) texture2D(tex, POS_UV).rgb\n#endif\n\n#ifndef FNC_BARREL\n#define FNC_BARREL\nvec2 barrel(vec2 st, float amt, float dist) {\n    return st + (st-.5) * (BARREL_DISTANCE) * amt;\n}\n\nvec2 barrel(vec2 st, float amt) {\n    return barrel(st, amt, lengthSq(st-.5));\n}\n\nBARREL_TYPE barrel(in sampler2D tex, in vec2 st, float offset) {\n    BARREL_TYPE a1 = BARREL_SAMPLER_FNC( barrel(st, .0, offset));\n    BARREL_TYPE a2 = BARREL_SAMPLER_FNC( barrel(st, .2, offset));\n    BARREL_TYPE a3 = BARREL_SAMPLER_FNC( barrel(st, .4, offset));\n    BARREL_TYPE a4 = BARREL_SAMPLER_FNC( barrel(st, .6, offset));\n#ifdef BARREL_OCT_1\n    return (a1+a2+a3+a4)/4.;\n#endif\n    BARREL_TYPE a5 = BARREL_SAMPLER_FNC( barrel(st, .8, offset));\n    BARREL_TYPE a6 = BARREL_SAMPLER_FNC( barrel(st, 1.0, offset));\n    BARREL_TYPE a7 = BARREL_SAMPLER_FNC( barrel(st, 1.2, offset));\n    BARREL_TYPE a8 = BARREL_SAMPLER_FNC( barrel(st, 1.4, offset));\n#ifdef BARREL_OCT_2\n    return (a1+a2+a3+a4+a5+a6+a7+a8)/8.;\n#endif\n    BARREL_TYPE a9 = BARREL_SAMPLER_FNC( barrel(st, 1.6, offset));\n    BARREL_TYPE a10 = BARREL_SAMPLER_FNC( barrel(st, 1.8, offset));\n    BARREL_TYPE a11 = BARREL_SAMPLER_FNC( barrel(st, 2.0, offset));\n    BARREL_TYPE a12 = BARREL_SAMPLER_FNC( barrel(st, 2.2, offset));\n    return (a1+a2+a3+a4+a5+a6+a7+a8+a9+a10+a11+a12)/12.;\n}\n\nBARREL_TYPE barrel(in sampler2D tex, in vec2 st, in vec2 offset) {\n    return barrel(tex, st, dot(vec2(.5), offset));\n}\n\nBARREL_TYPE barrel(in sampler2D tex, in vec2 st) {\n    return barrel(tex, st, lengthSq(st-.5));\n}\n\n#endif\n'},3886:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: Squared length\nuse: lengthSq(<vec2|float2> st)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n\n*/\n\n#ifndef FNC_LENGTHSQ\n#define FNC_LENGTHSQ\nfloat lengthSq(in vec2 st) {\n    return dot(st, st);\n}\n\nfloat lengthSq(in vec3 pos) {\n    return dot(pos, pos);\n}\n#endif\n\n\n/*\nauthor: Patricio Gonzalez Vivo, Johan Ismael\ndescription: Chroma Aberration inspired by https://www.shadertoy.com/view/4sX3z4\nuse: chromaAB(<sampler2D> texture, <vec2> st [, <float|vec2> sdf|offset, <float> pct])\noptions:\n    CHROMAAB_TYPE: return type, defauls to vec3\n    CHROMAAB_PCT: amount of aberration, defaults to 1.5\n    CHROMAAB_SAMPLER_FNC: function used to sample the input texture, defaults to texture2D(tex, POS_UV)\n    CHROMAAB_CENTER_BUFFER: scalar to attenuate the sdf passed in   \nlicense: |\n    Copyright (c) 2021 Patricio Gonzalez Vivo and Johan Ismael\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef CHROMAAB_PCT\n#define CHROMAAB_PCT 1.5\n#endif\n\n#ifndef CHROMAAB_TYPE\n#define CHROMAAB_TYPE vec3\n#endif\n\n#ifndef CHROMAAB_SAMPLER_FNC\n#define CHROMAAB_SAMPLER_FNC(POS_UV) texture2D(tex, POS_UV)\n#endif\n\n#ifndef FNC_CHROMAAB\n#define FNC_CHROMAAB\n\nCHROMAAB_TYPE chromaAB(in sampler2D tex, in vec2 st, in vec2 direction, in vec3 distortion ) {\n    vec2 offset = vec2(0.0);\n    CHROMAAB_TYPE c = CHROMAAB_TYPE(1.);\n    c.r = CHROMAAB_SAMPLER_FNC(st + direction * distortion.r).r;\n    c.g = CHROMAAB_SAMPLER_FNC(st + direction * distortion.g).g;\n    c.b = CHROMAAB_SAMPLER_FNC(st + direction * distortion.b).b;\n    return c;\n}\n\nCHROMAAB_TYPE chromaAB(in sampler2D tex, in vec2 st, in vec2 offset, in float pct) {\n\n  #ifdef CHROMAAB_CENTER_BUFFER\n    // modify the distance from the center, so that only the edges are affected\n    offset = max(offset - CHROMAAB_CENTER_BUFFER, 0.);\n  #endif\n\n  // Distort the UVs\n  vec2 stR = st * (1.0 + offset * 0.02 * pct),\n       stB = st * (1.0 - offset * 0.02 * pct);\n\n  // Get the individual channels using the modified UVs\n  CHROMAAB_TYPE c = CHROMAAB_TYPE(1.);\n  c.r = CHROMAAB_SAMPLER_FNC(stR).r;\n  c.g = CHROMAAB_SAMPLER_FNC(st).g;\n  c.b = CHROMAAB_SAMPLER_FNC(stB).b;\n  return c;\n}\n\nCHROMAAB_TYPE chromaAB(in sampler2D tex, in vec2 st, in float sdf, in float pct) {\n  return chromaAB(tex, st, vec2(sdf), pct);\n}\n\nCHROMAAB_TYPE chromaAB(in sampler2D tex, in vec2 st, in float sdf) {\n  return chromaAB(tex, st, sdf, CHROMAAB_PCT);\n}\n\nCHROMAAB_TYPE chromaAB(in sampler2D tex, in vec2 st, in vec2 offset) {\n  return chromaAB(tex, st, offset, CHROMAAB_PCT);\n}\n\nCHROMAAB_TYPE chromaAB(in sampler2D tex, in vec2 st) {\n  return chromaAB(tex, st, lengthSq(st - .5), CHROMAAB_PCT);\n}\n\n#endif\n'},4775:e=>{e.exports='/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: modulus of 289\nuse: mod289(<float|vec2|vec3|vec4> x)\nlicense: |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n#ifndef FNC_MOD289\n#define FNC_MOD289\nfloat mod289(in float x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec2 mod289(in vec2 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec3 mod289(in vec3 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec4 mod289(in vec4 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n#endif\n\n/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: modulus of 289\nuse: mod289(<float|vec2|vec3|vec4> x)\nlicense: |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n#ifndef FNC_MOD289\n#define FNC_MOD289\nfloat mod289(in float x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec2 mod289(in vec2 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec3 mod289(in vec3 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec4 mod289(in vec4 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n#endif\n\n\n/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: permute\nuse: permute(<float|vec2|vec3|vec4> x)\nlicense : |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n\n#ifndef FNC_PERMUTE\n#define FNC_PERMUTE\nfloat permute(in float x) {\n     return mod289(((x * 34.) + 1.)*x);\n}\n\nvec3 permute(in vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 permute(in vec4 x) {\n     return mod289(((x * 34.) + 1.)*x);\n}\n#endif\n\n/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: \nuse: taylorInvSqrt(<float|vec4> x)\nLicense : |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n\n#ifndef FNC_TAYLORINVSQRT\n#define FNC_TAYLORINVSQRT\nfloat taylorInvSqrt(in float r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 taylorInvSqrt(in vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n#endif\n/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: grad4, used for snoise(vec4 v)\nuse: grad4(<float> j, <vec4> ip)\nlicense: |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n#ifndef FNC_GRAD4\n#define FNC_GRAD4\nvec4 grad4(float j, vec4 ip) {\n    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n    vec4 p,s;\n\n    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n    s = vec4(lessThan(p, vec4(0.0)));\n    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n    return p;\n}\n#endif\n\n\n/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: Simplex Noise https://github.com/ashima/webgl-noise\nuse: snoise(<vec2|vec3|vec4> pos)\nlicense: |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Copyright (C) 2011-2016 by Stefan Gustavson (Classic noise and others)\n  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n  Neither the name of the GPUImage framework nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  \n*/\n\n#ifndef FNC_SNOISE\n#define FNC_SNOISE\nfloat snoise(in vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n\nfloat snoise(in vec3 v) {\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289(i);\n    vec4 p = permute( permute( permute(\n                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n            + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n            + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat snoise(in vec4 v) {\n    const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                        -0.447213595499958); // -1 + 4 * G4\n\n    // First corner\n    vec4 i  = floor(v + dot(v, vec4(.309016994374947451)) ); // (sqrt(5) - 1)/4\n    vec4 x0 = v -   i + dot(i, C.xxxx);\n\n    // Other corners\n\n    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n    vec4 i0;\n    vec3 isX = step( x0.yzw, x0.xxx );\n    vec3 isYZ = step( x0.zww, x0.yyz );\n    //  i0.x = dot( isX, vec3( 1.0 ) );\n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n    //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n\n    // i0 now contains the unique values 0,1,2,3 in each channel\n    vec4 i3 = clamp( i0, 0.0, 1.0 );\n    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n    //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n    //  x1 = x0 - i1  + 1.0 * C.xxxx\n    //  x2 = x0 - i2  + 2.0 * C.xxxx\n    //  x3 = x0 - i3  + 3.0 * C.xxxx\n    //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n    vec4 x1 = x0 - i1 + C.xxxx;\n    vec4 x2 = x0 - i2 + C.yyyy;\n    vec4 x3 = x0 - i3 + C.zzzz;\n    vec4 x4 = x0 + C.wwww;\n\n    // Permutations\n    i = mod289(i);\n    float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n    vec4 j1 = permute( permute( permute( permute (\n                i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n            + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n            + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n            + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n    // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n    vec4 p0 = grad4(j0,   ip);\n    vec4 p1 = grad4(j1.x, ip);\n    vec4 p2 = grad4(j1.y, ip);\n    vec4 p3 = grad4(j1.z, ip);\n    vec4 p4 = grad4(j1.w, ip);\n\n    // Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= taylorInvSqrt(dot(p4,p4));\n\n    // Mix contributions from the five corners\n    vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n    vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n    m0 = m0 * m0;\n    m1 = m1 * m1;\n    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\n\nvec3 snoise3( vec3 x ){\n    float s  = snoise(vec3( x ));\n    float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n    float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n    vec3 c = vec3( s , s1 , s2 );\n    return c;\n}\n\nvec3 snoise3( vec4 x ){\n    float s  = snoise(vec4( x ));\n    float s1 = snoise(vec4( x.y - 19.1 , x.z + 33.4 , x.x + 47.2, x.w ));\n    float s2 = snoise(vec4( x.z + 74.2 , x.x - 124.5 , x.y + 99.4, x.w ));\n    vec3 c = vec3( s , s1 , s2 );\n    return c;\n}\n\n#endif\n\n/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: modulus of 289\nuse: mod289(<float|vec2|vec3|vec4> x)\nlicense: |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n#ifndef FNC_MOD289\n#define FNC_MOD289\nfloat mod289(in float x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec2 mod289(in vec2 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec3 mod289(in vec3 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec4 mod289(in vec4 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n#endif\n\n/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: modulus of 289\nuse: mod289(<float|vec2|vec3|vec4> x)\nlicense: |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n#ifndef FNC_MOD289\n#define FNC_MOD289\nfloat mod289(in float x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec2 mod289(in vec2 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec3 mod289(in vec3 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec4 mod289(in vec4 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n#endif\n\n\n/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: permute\nuse: permute(<float|vec2|vec3|vec4> x)\nlicense : |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n\n#ifndef FNC_PERMUTE\n#define FNC_PERMUTE\nfloat permute(in float x) {\n     return mod289(((x * 34.) + 1.)*x);\n}\n\nvec3 permute(in vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 permute(in vec4 x) {\n     return mod289(((x * 34.) + 1.)*x);\n}\n#endif\n\n/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: \nuse: taylorInvSqrt(<float|vec4> x)\nLicense : |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n\n#ifndef FNC_TAYLORINVSQRT\n#define FNC_TAYLORINVSQRT\nfloat taylorInvSqrt(in float r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 taylorInvSqrt(in vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n#endif\n/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: fade\nuse: fade(<vec2|vec3|vec4> t)\nlicense: |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n\n#ifndef FNC_FADE\n#define FNC_FADE\nfloat fade(in float t) {\n  return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n\nvec2 fade(in vec2 t) {\n  return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n\nvec3 fade(in vec3 t) {\n  return t * t * t * (t * (t * 6. - 15. ) + 10.);\n}\n\nvec4 fade(vec4 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n#endif\n\n\n/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: Classic Perlin Noise with periodic variant https://github.com/ashima/webgl-noise\nuse: pnoise(<vec2|vec3|vec4> pos, <vec2|vec3|vec4> periodic)\nlicense: |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Copyright (C) 2011-2016 by Stefan Gustavson (Classic noise and others)\n    Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n  Neither the name of the GPUImage framework nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  \n*/\n\n#ifndef FNC_PNOISE\n#define FNC_PNOISE\n// Classic Perlin noise, periodic variant\nfloat pnoise(in vec2 P, in vec2 rep) {\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n    Pi = mod289(Pi);        // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n\n    vec4 i = permute(permute(ix) + iy);\n\n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n    vec4 gy = abs(gx) - 0.5 ;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n\n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n\n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n}\n\nfloat pnoise(in vec3 P, in vec3 rep) {\n    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}\n\nfloat pnoise(in vec4 P, in vec4 rep) {\n    vec4 Pi0 = mod(floor(P), rep); // Integer part modulo rep\n    vec4 Pi1 = mod(Pi0 + 1.0, rep); // Integer part + 1 mod rep\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec4 Pf0 = fract(P); // Fractional part for interpolation\n    vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = vec4(Pi0.zzzz);\n    vec4 iz1 = vec4(Pi1.zzzz);\n    vec4 iw0 = vec4(Pi0.wwww);\n    vec4 iw1 = vec4(Pi1.wwww);\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 ixy00 = permute(ixy0 + iw0);\n    vec4 ixy01 = permute(ixy0 + iw1);\n    vec4 ixy10 = permute(ixy1 + iw0);\n    vec4 ixy11 = permute(ixy1 + iw1);\n\n    vec4 gx00 = ixy00 * (1.0 / 7.0);\n    vec4 gy00 = floor(gx00) * (1.0 / 7.0);\n    vec4 gz00 = floor(gy00) * (1.0 / 6.0);\n    gx00 = fract(gx00) - 0.5;\n    gy00 = fract(gy00) - 0.5;\n    gz00 = fract(gz00) - 0.5;\n    vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n    vec4 sw00 = step(gw00, vec4(0.0));\n    gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n    gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n    vec4 gx01 = ixy01 * (1.0 / 7.0);\n    vec4 gy01 = floor(gx01) * (1.0 / 7.0);\n    vec4 gz01 = floor(gy01) * (1.0 / 6.0);\n    gx01 = fract(gx01) - 0.5;\n    gy01 = fract(gy01) - 0.5;\n    gz01 = fract(gz01) - 0.5;\n    vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n    vec4 sw01 = step(gw01, vec4(0.0));\n    gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n    gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n    vec4 gx10 = ixy10 * (1.0 / 7.0);\n    vec4 gy10 = floor(gx10) * (1.0 / 7.0);\n    vec4 gz10 = floor(gy10) * (1.0 / 6.0);\n    gx10 = fract(gx10) - 0.5;\n    gy10 = fract(gy10) - 0.5;\n    gz10 = fract(gz10) - 0.5;\n    vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n    vec4 sw10 = step(gw10, vec4(0.0));\n    gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n    gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n    vec4 gx11 = ixy11 * (1.0 / 7.0);\n    vec4 gy11 = floor(gx11) * (1.0 / 7.0);\n    vec4 gz11 = floor(gy11) * (1.0 / 6.0);\n    gx11 = fract(gx11) - 0.5;\n    gy11 = fract(gy11) - 0.5;\n    gz11 = fract(gz11) - 0.5;\n    vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n    vec4 sw11 = step(gw11, vec4(0.0));\n    gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n    gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n    vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n    vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n    vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n    vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n    vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n    vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n    vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n    vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n    vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n    vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n    vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n    vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n    vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n    vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n    vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n    vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n    vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n    g0000 *= norm00.x;\n    g0100 *= norm00.y;\n    g1000 *= norm00.z;\n    g1100 *= norm00.w;\n\n    vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n    g0001 *= norm01.x;\n    g0101 *= norm01.y;\n    g1001 *= norm01.z;\n    g1101 *= norm01.w;\n\n    vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n    g0010 *= norm10.x;\n    g0110 *= norm10.y;\n    g1010 *= norm10.z;\n    g1110 *= norm10.w;\n\n    vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n    g0011 *= norm11.x;\n    g0111 *= norm11.y;\n    g1011 *= norm11.z;\n    g1111 *= norm11.w;\n\n    float n0000 = dot(g0000, Pf0);\n    float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n    float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n    float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n    float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n    float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n    float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n    float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n    float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n    float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n    float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n    float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n    float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n    float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n    float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n    float n1111 = dot(g1111, Pf1);\n\n    vec4 fade_xyzw = fade(Pf0);\n    vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n    vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n    vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n    vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n    float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n    return 2.2 * n_xyzw;\n}\n#endif\n\n/*\nauthor: Hugh Kennedy (https://github.com/hughsk)\ndescription: get\'s the luminosity of a color. From https://github.com/hughsk/glsl-luma/blob/master/index.glsl\nuse: rgb2luma(<vec3|vec4> color)\nlicense: |\n  This software is released under the MIT license:\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_RGB2LUMA\n#define FNC_RGB2LUMA\nfloat rgb2luma(in vec3 color) {\n    return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat rgb2luma(in vec4 color) {\n    return rgb2luma(color.rgb);\n}\n#endif\n\n\n/*\nauthor: Hugh Kennedy (https://github.com/hughsk)\ndescription: get the luminosity of a color. From https://github.com/hughsk/glsl-luma/blob/master/index.glsl\nuse: luma(<vec3|vec4> color)\nlicense: |\n  This software is released under the MIT license:\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_LUMA\n#define FNC_LUMA\nfloat luma(float color) {\n    return color;\n}\n\nfloat luma(in vec3 color) {\n    return rgb2luma(color);\n}\n\nfloat luma(in vec4 color) {\n    return rgb2luma(color.rgb);\n}\n#endif\n\n/*\nauthor: Jamie Owen\ndescription: Photoshop Soft Light blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendSoftLight(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicence: TODO\n*/\n\n#ifndef FNC_BLENDSOFTLIGHT\n#define FNC_BLENDSOFTLIGHT\nfloat blendSoftLight(in float base, in float blend) {\n    return (blend < .5)? (2. * base * blend + base * base * (1. - 2.*blend)): (sqrt(base) * (2. * blend - 1.) + 2. * base * (1. - blend));\n}\n\nvec3 blendSoftLight(in vec3 base, in vec3 blend) {\n    return vec3(blendSoftLight(base.r, blend.r),\n                blendSoftLight(base.g, blend.g),\n                blendSoftLight(base.b, blend.b));\n}\n\nvec4 blendSoftLight(in vec4 base, in vec4 blend) {\n    return vec4(blendSoftLight( base.r, blend.r ),\n                blendSoftLight( base.g, blend.g ),\n                blendSoftLight( base.b, blend.b ),\n                blendSoftLight( base.a, blend.a )\n    );\n}\n\nvec3 blendSoftLight(in vec3 base, in vec3 blend, in float opacity) {\n    return (blendSoftLight(base, blend) * opacity + base * (1. - opacity));\n}\n#endif\n\n\n/*\nauthor: Matt DesLauriers\ndescription: Natural looking film grain using 3D noise functions (original source: https://github.com/mattdesl/glsl-film-grain). Inspired by [Martins Upitis](http://devlog-martinsh.blogspot.com/2013/05/image-imperfections-and-film-grain-post.html).\nuse: \n    - grain(<vec2> texCoord, <vec2> resolution [, <float> t, <float> multiplier])\n    - grain(<sampler2D> texture, <vec2> texCoord, <float|vec2> resolution [, <float> t, <float> multiplier])\nlicense: |\n    The MIT License (MIT) Copyright (c) 2015 Matt DesLauriers\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef GRAIN_TYPE\n#define GRAIN_TYPE vec3\n#endif\n\n#ifndef GRAIN_SAMPLER_FNC\n#define GRAIN_SAMPLER_FNC(POS_UV) texture2D(tex, POS_UV).rgb\n#endif\n\n#ifndef FNC_GRAIN\n#define FNC_GRAIN\nfloat grain(vec2 texCoord, vec2 resolution, float t, float multiplier) {\n    vec2 mult = texCoord * resolution;\n    float offset = snoise(vec3(mult / multiplier, t));\n    float n1 = pnoise(vec3(mult, offset), vec3(1. / texCoord * resolution, 1.));\n    return n1 / 2. + .5;\n}\n\nfloat grain(vec2 texCoord, vec2 resolution, float t) {\n    return grain(texCoord, resolution, t, 2.5);\n}\n\nfloat grain(vec2 texCoord, vec2 resolution) {\n    return grain(texCoord, resolution, 0.);\n}\n\nGRAIN_TYPE grain(sampler2D tex, vec2 st, vec2 resolution, float t, float multiplier ) {\n    GRAIN_TYPE org = GRAIN_SAMPLER_FNC(st);\n\n    float g = grain(st, resolution, t, multiplier);\n\n    //get the luminance of the background\n    float luminance = luma(org);\n    \n    //reduce the noise based on some \n    //threshold of the background luminance\n    float response = smoothstep(0.05, 0.5, luminance);\n    return mix( blendSoftLight(org, GRAIN_TYPE(g)), \n                org, \n                response * response);\n}\n\nGRAIN_TYPE grain(sampler2D tex, vec2 st, vec2 resolution, float t ) {\n    return grain(tex, st, resolution, t, 2.5 );\n}\n\nGRAIN_TYPE grain(sampler2D tex, vec2 st, vec2 resolution) {\n    return grain(tex, st, resolution, 0.);\n}\n\nGRAIN_TYPE grain(sampler2D tex, vec2 st, float resolution, float t, float multiplier  ) {\n    return grain(tex, st, vec2(resolution), t, multiplier );\n}\n\nGRAIN_TYPE grain(sampler2D tex, vec2 st, float resolution, float t ) {\n    return grain(tex, st, resolution, t, 2.5 );\n}\n\nGRAIN_TYPE grain(sampler2D tex, vec2 st, float resolution) {\n    return grain(tex, st, resolution, 0.);\n}\n\n#endif'},8249:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo, Johan Ismael\ndescription: Samples multiple times a texture in the specified direction\nuse: stretch(<sampler2D> tex, <vec2> st, <vec2> direction [, int samples])\noptions:\n    STRETCH_SAMPLES: number of samples taken, defaults to 20\n    STRETCH_TYPE: return type, defauls to vec4\n    STRETCH_SAMPLER_FNC(POS_UV): function used to sample the input texture, defaults to texture2D(tex, POS_UV)\n    STRETCH_WEIGHT: shaping equation to multiply the sample weight.\nlicense: |\n    Copyright (c) 2021 Patricio Gonzalez Vivo and Johan Ismael\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOF\n*/\n\n#ifndef STRETCH_SAMPLES\n#define STRETCH_SAMPLES 20\n#endif\n\n#ifndef STRETCH_TYPE\n#define STRETCH_TYPE vec4\n#endif\n\n#ifndef STRETCH_SAMPLER_FNC\n#define STRETCH_SAMPLER_FNC(POS_UV) texture2D(tex, POS_UV)\n#endif\n\n#ifndef FNC_STRETCH\n#define FNC_STRETCH\nSTRETCH_TYPE stretch(in sampler2D tex, in vec2 st, in vec2 direction, const int i_samples) {\n    float f_samples = float(i_samples);\n    STRETCH_TYPE color = STRETCH_TYPE(0.);\n\n    #ifdef PLATFORM_WEBGL\n    for (int i = 0; i < 50; i++) {\n        if (i == i_samples) break;\n    #else\n    for (int i = 0; i < i_samples; i++) {\n    #endif\n\n        float f_sample = float(i);\n        STRETCH_TYPE tx = STRETCH_SAMPLER_FNC(st + direction * f_sample);\n        #ifdef STRETCH_WEIGHT\n        tx *= STRETCH_WEIGHT;\n        #endif\n        color += tx;\n    }\n    return color / f_samples;\n}\n\nSTRETCH_TYPE stretch(in sampler2D tex, in vec2 st, in vec2 direction) {\n    float f_samples = float(STRETCH_SAMPLES);  \n    STRETCH_TYPE color = STRETCH_TYPE(0.);\n    for (int i = 0; i < STRETCH_SAMPLES; i++) {\n        float f_sample = float(i);    \n        STRETCH_TYPE tx = STRETCH_SAMPLER_FNC(st + direction * f_sample);\n        #ifdef STRETCH_WEIGHT\n        tx *= STRETCH_WEIGHT;    \n        #endif\n        color += tx;\n    }\n    return color / f_samples;\n}\n#endif\n'},1595:e=>{e.exports='/*\nauthor: Matt DesLauriers\ndescription: Performs a smoothstep using standard derivatives for anti-aliased edges at any level of magnification. From https://github.com/glslify/glsl-aastep\nuse: aastep(<float> threshold, <float> value)\noption:\n    AA_EDGE: in the absence of derivatives you can specify the antialiasing factor\nlicense: |\n    The MIT License (MIT) Copyright (c) 2015 stackgl\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_AASTEP\n#define FNC_AASTEP\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n\nfloat aastep(float threshold, float value) {\n    #ifdef GL_OES_standard_derivatives\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n    #elif defined(AA_EDGE)\n    float afwidth = AA_EDGE;\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n    #else \n    return step(threshold, value);\n    #endif\n}\n#endif'},9797:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: fill a stroke in a SDF. From PixelSpiritDeck https://github.com/patriciogonzalezvivo/PixelSpiritDeck\nuse: stroke(<float> sdf, <float> size, <float> width [, <float> edge])\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n  Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n  https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_STROKE\n#define FNC_STROKE\n\n/*\nauthor: Matt DesLauriers\ndescription: Performs a smoothstep using standard derivatives for anti-aliased edges at any level of magnification. From https://github.com/glslify/glsl-aastep\nuse: aastep(<float> threshold, <float> value)\noption:\n    AA_EDGE: in the absence of derivatives you can specify the antialiasing factor\nlicense: |\n    The MIT License (MIT) Copyright (c) 2015 stackgl\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_AASTEP\n#define FNC_AASTEP\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n\nfloat aastep(float threshold, float value) {\n    #ifdef GL_OES_standard_derivatives\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n    #elif defined(AA_EDGE)\n    float afwidth = AA_EDGE;\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n    #else \n    return step(threshold, value);\n    #endif\n}\n#endif\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: clamp a value between 0 and 1\nuse: saturation(<float|vec2|vec3|vec4> value)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef FNC_SATURATE\n#define FNC_SATURATE\n// #define saturate(x) clamp(x, 0.0, 1.0)\nfloat saturate( float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec2 saturate( vec2 x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec3 saturate( vec3 x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec4 saturate( vec4 x) {\n    return clamp(x, 0.0, 1.0);\n}\n#endif\n\nfloat stroke(float x, float size, float w) {\n    float d = aastep(size, x + w * 0.5) - aastep(size, x - w * 0.5);\n    return saturate(d);\n}\n\nfloat stroke(float x, float size, float w, float edge) {\n    float d = smoothstep(size - edge, size + edge, x + w * 0.5) - smoothstep(size - edge, size + edge, x - w * 0.5);\n    return saturate(d);\n}\n\n#endif\n\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: create a bridge on a given in_value and draw a stroke inside that gap\nuse: bridge(<float|vec2|vec3|vec4> in_value, <float> sdf, <float> size, <float> width)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n  Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n  https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_BRIDGE\n#define FNC_BRIDGE\nfloat bridge(float c, float d, float s, float w) {\n    c *= 1.0 - stroke(d, s , w * 2.0);\n    return c + stroke(d, s, w);\n}\n\nvec2 bridge(vec2 c, float d, float s, float w) {\n    c *= 1.0 - stroke(d, s , w * 2.0);\n    return c + stroke(d, s, w);\n}\n\nvec3 bridge(vec3 c, float d, float s, float w) {\n    c *= 1.0 - stroke(d, s , w * 2.0);\n    return c + stroke(d, s, w);\n}\n\nvec4 bridge(vec4 c, float d, float s, float w) {\n    c *= 1.0 - stroke(d, s , w * 2.0);\n    return c + stroke(d, s, w);\n}\n\n#endif'},4525:e=>{e.exports='\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: Returns a circle-shaped SDF.\nuse: circleSDF(vec2 st[, vec2 center])\noptions:\n    CIRCLESDF_FNC(POS_UV) : function used to calculate the SDF, defaults to GLSL length function, use lengthSq for a different slope\nlicense: |\n    Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n    Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n    https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef CIRCLESDF_FNC\n#define CIRCLESDF_FNC(POS_UV) length(POS_UV)\n#endif\n\n#ifndef FNC_CIRCLESDF\n#define FNC_CIRCLESDF\n\nfloat circleSDF(in vec2 st, in vec2 center) {\n    return CIRCLESDF_FNC(st - center) * 2.;\n}\n\nfloat circleSDF(in vec2 st) {\n    return circleSDF(st, vec2(.5));\n}\n\n#endif\n\n\n/*\nauthor: Matt DesLauriers\ndescription: Performs a smoothstep using standard derivatives for anti-aliased edges at any level of magnification. From https://github.com/glslify/glsl-aastep\nuse: aastep(<float> threshold, <float> value)\noption:\n    AA_EDGE: in the absence of derivatives you can specify the antialiasing factor\nlicense: |\n    The MIT License (MIT) Copyright (c) 2015 stackgl\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_AASTEP\n#define FNC_AASTEP\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n\nfloat aastep(float threshold, float value) {\n    #ifdef GL_OES_standard_derivatives\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n    #elif defined(AA_EDGE)\n    float afwidth = AA_EDGE;\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n    #else \n    return step(threshold, value);\n    #endif\n}\n#endif\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: fill a SDF. From PixelSpiritDeck https://github.com/patriciogonzalezvivo/PixelSpiritDeck\nuse: fill(<float> sdf, <float> size [, <float> edge])\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n  Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n  https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_FILL\n#define FNC_FILL\nfloat fill(float x, float size, float edge) {\n    return 1.0 - smoothstep(size - edge, size + edge, x);\n}\n\nfloat fill(float x, float size) {\n    return 1.0 - aastep(size, x);\n}\n#endif\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: fill a stroke in a SDF. From PixelSpiritDeck https://github.com/patriciogonzalezvivo/PixelSpiritDeck\nuse: stroke(<float> sdf, <float> size, <float> width [, <float> edge])\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n  Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n  https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_STROKE\n#define FNC_STROKE\n\n/*\nauthor: Matt DesLauriers\ndescription: Performs a smoothstep using standard derivatives for anti-aliased edges at any level of magnification. From https://github.com/glslify/glsl-aastep\nuse: aastep(<float> threshold, <float> value)\noption:\n    AA_EDGE: in the absence of derivatives you can specify the antialiasing factor\nlicense: |\n    The MIT License (MIT) Copyright (c) 2015 stackgl\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_AASTEP\n#define FNC_AASTEP\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n\nfloat aastep(float threshold, float value) {\n    #ifdef GL_OES_standard_derivatives\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n    #elif defined(AA_EDGE)\n    float afwidth = AA_EDGE;\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n    #else \n    return step(threshold, value);\n    #endif\n}\n#endif\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: clamp a value between 0 and 1\nuse: saturation(<float|vec2|vec3|vec4> value)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef FNC_SATURATE\n#define FNC_SATURATE\n// #define saturate(x) clamp(x, 0.0, 1.0)\nfloat saturate( float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec2 saturate( vec2 x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec3 saturate( vec3 x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec4 saturate( vec4 x) {\n    return clamp(x, 0.0, 1.0);\n}\n#endif\n\nfloat stroke(float x, float size, float w) {\n    float d = aastep(size, x + w * 0.5) - aastep(size, x - w * 0.5);\n    return saturate(d);\n}\n\nfloat stroke(float x, float size, float w, float edge) {\n    float d = smoothstep(size - edge, size + edge, x + w * 0.5) - smoothstep(size - edge, size + edge, x - w * 0.5);\n    return saturate(d);\n}\n\n#endif\n\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: draw a circle filled or not. \nuse: circle(<vec2> st, <float> size [, <float> width])\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_CIRCLE\n#define FNC_CIRCLE\nfloat circle(vec2 st, float size) {\n    return fill(circleSDF(st), size);\n}\n\nfloat circle(vec2 st, float size, float strokeWidth) {\n    return stroke(circleSDF(st), size, strokeWidth);\n}\n#endif'},2788:e=>{e.exports='\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: Returns a rectangular SDF\nuse: rectSDF(<vec2> st, <vec2> size)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n  Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n  https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_RECTSDF\n#define FNC_RECTSDF\nfloat rectSDF(in vec2 st, in vec2 s) {\n    st = st * 2. - 1.;\n    return max( abs(st.x / s.x),\n                abs(st.y / s.y) );\n}\n#endif\n\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: Returns a cross-shaped SDF\nuse: crossSDF(<vec2> st, size s)\nlicense: |\n    Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n    Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n    https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_CROSSSDF\n#define FNC_CROSSSDF\nfloat crossSDF(in vec2 st, in float s) {\n    vec2 size = vec2(.25, s);\n    return min(rectSDF(st.xy, size.xy),\n               rectSDF(st.xy, size.yx));\n}\n#endif\n\n\n/*\nauthor: Matt DesLauriers\ndescription: Performs a smoothstep using standard derivatives for anti-aliased edges at any level of magnification. From https://github.com/glslify/glsl-aastep\nuse: aastep(<float> threshold, <float> value)\noption:\n    AA_EDGE: in the absence of derivatives you can specify the antialiasing factor\nlicense: |\n    The MIT License (MIT) Copyright (c) 2015 stackgl\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_AASTEP\n#define FNC_AASTEP\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n\nfloat aastep(float threshold, float value) {\n    #ifdef GL_OES_standard_derivatives\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n    #elif defined(AA_EDGE)\n    float afwidth = AA_EDGE;\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n    #else \n    return step(threshold, value);\n    #endif\n}\n#endif\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: fill a SDF. From PixelSpiritDeck https://github.com/patriciogonzalezvivo/PixelSpiritDeck\nuse: fill(<float> sdf, <float> size [, <float> edge])\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n  Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n  https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_FILL\n#define FNC_FILL\nfloat fill(float x, float size, float edge) {\n    return 1.0 - smoothstep(size - edge, size + edge, x);\n}\n\nfloat fill(float x, float size) {\n    return 1.0 - aastep(size, x);\n}\n#endif\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: fill a stroke in a SDF. From PixelSpiritDeck https://github.com/patriciogonzalezvivo/PixelSpiritDeck\nuse: stroke(<float> sdf, <float> size, <float> width [, <float> edge])\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n  Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n  https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_STROKE\n#define FNC_STROKE\n\n/*\nauthor: Matt DesLauriers\ndescription: Performs a smoothstep using standard derivatives for anti-aliased edges at any level of magnification. From https://github.com/glslify/glsl-aastep\nuse: aastep(<float> threshold, <float> value)\noption:\n    AA_EDGE: in the absence of derivatives you can specify the antialiasing factor\nlicense: |\n    The MIT License (MIT) Copyright (c) 2015 stackgl\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_AASTEP\n#define FNC_AASTEP\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n\nfloat aastep(float threshold, float value) {\n    #ifdef GL_OES_standard_derivatives\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n    #elif defined(AA_EDGE)\n    float afwidth = AA_EDGE;\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n    #else \n    return step(threshold, value);\n    #endif\n}\n#endif\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: clamp a value between 0 and 1\nuse: saturation(<float|vec2|vec3|vec4> value)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef FNC_SATURATE\n#define FNC_SATURATE\n// #define saturate(x) clamp(x, 0.0, 1.0)\nfloat saturate( float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec2 saturate( vec2 x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec3 saturate( vec3 x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec4 saturate( vec4 x) {\n    return clamp(x, 0.0, 1.0);\n}\n#endif\n\nfloat stroke(float x, float size, float w) {\n    float d = aastep(size, x + w * 0.5) - aastep(size, x - w * 0.5);\n    return saturate(d);\n}\n\nfloat stroke(float x, float size, float w, float edge) {\n    float d = smoothstep(size - edge, size + edge, x + w * 0.5) - smoothstep(size - edge, size + edge, x - w * 0.5);\n    return saturate(d);\n}\n\n#endif\n\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: draw a cross filled or not. \nuse: cross(<vec2> st, <float> size [, <float> width])\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_CROSS\n#define FNC_CROSS\nfloat cross(vec2 st, float size) {\n    return fill(crossSDF(st, 1.), size);\n}\n\nfloat cross(vec2 st, float size, float strokeWidth) {\n    return stroke(crossSDF(st, 1.), size, strokeWidth);\n}\n#endif'},2823:e=>{e.exports="/*\nauthor: Patricio Gonzalez Vivo\ndescription: |\n  Draws all the digits of a floating point number, useful for debugging.\n  Requires high precision to work properly.\nuse: digits(<vec2> st, <float> value [, <float> nDecDigit])\noptions:\n  DIGITS_DECIMALS: number of decimals after the point, defaults to 2\n  DIGITS_SIZE: size of the font, defaults to vec2(.025)\n*/\n\n#ifndef DIGITS_SIZE\n#define DIGITS_SIZE vec2(.025)\n#endif\n\n#ifndef DIGITS_DECIMALS\n#define DIGITS_DECIMALS 2.0\n#endif\n\n#ifndef FNC_DIGITS\n#define FNC_DIGITS\nfloat digits(in vec2 st, in float value, in float nDecDigit) {\n    st /= DIGITS_SIZE;\n\n    float absValue = abs(value);\n    float biggestDigitIndex = max(floor(log2(absValue) / log2(10.)), 0.);\n\n    float counter = floor(value);\n    float nIntDigits = 0.;\n    for (int i = 0; i < 9; i++) {\n        counter = floor(counter*.1);\n        nIntDigits++;\n        if (counter == 0.)\n            break;\n    }\n    float digit = 12.;\n    float digitIndex = (nIntDigits-1.) - floor(st.x);\n    if (digitIndex > (-nDecDigit - 1.5)) {\n        if (digitIndex > biggestDigitIndex) {\n            if (value < 0.) {\n                if (digitIndex < (biggestDigitIndex+1.5)) {\n                    digit = 11.;\n                }\n            }\n        } \n        else {\n            if (digitIndex == -1.) {\n                if (nDecDigit > 0.) {\n                    digit = 10.;\n                }\n            } \n            else {\n                if (digitIndex < 0.) {\n                    digitIndex += 1.;\n                }\n                float digitValue = (absValue / (pow(10., digitIndex)));\n                digit = mod(floor(0.0001+digitValue), 10.);\n            }\n        }\n    }\n    vec2 pos = vec2(fract(st.x), st.y);\n\n    if (pos.x < 0.) return 0.;\n    if (pos.y < 0.) return 0.;\n    if (pos.x >= 1.) return 0.;\n    if (pos.y >= 1.) return 0.;\n\n    // make a 4x5 array of bits\n    float bin = 0.;\n    if (digit < 0.5) // 0\n        bin = 7. + 5. * 16. + 5. * 256. + 5. * 4096. + 7. * 65536.; \n    else if (digit < 1.5) // 1\n        bin = 2. + 2. * 16. + 2. * 256. + 2. * 4096. + 2. * 65536.;\n    else if (digit < 2.5) // 2\n        bin = 7. + 1. * 16. + 7. * 256. + 4. * 4096. + 7. * 65536.;\n    else if (digit < 3.5) // 3\n        bin = 7. + 4. * 16. + 7. * 256. + 4. * 4096. + 7. * 65536.;\n    else if (digit < 4.5) // 4\n        bin = 4. + 7. * 16. + 5. * 256. + 1. * 4096. + 1. * 65536.;\n    else if (digit < 5.5) // 5\n        bin = 7. + 4. * 16. + 7. * 256. + 1. * 4096. + 7. * 65536.;\n    else if (digit < 6.5) // 6\n        bin = 7. + 5. * 16. + 7. * 256. + 1. * 4096. + 7. * 65536.;\n    else if (digit < 7.5) // 7\n        bin = 4. + 4. * 16. + 4. * 256. + 4. * 4096. + 7. * 65536.;\n    else if (digit < 8.5) // 8\n        bin = 7. + 5. * 16. + 7. * 256. + 5. * 4096. + 7. * 65536.;\n    else if (digit < 9.5) // 9\n        bin = 7. + 4. * 16. + 7. * 256. + 5. * 4096. + 7. * 65536.;\n    else if (digit < 10.5) // '.'\n        bin = 2. + 0. * 16. + 0. * 256. + 0. * 4096. + 0. * 65536.;\n    else if (digit < 11.5) // '-'\n        bin = 0. + 0. * 16. + 7. * 256. + 0. * 4096. + 0. * 65536.;\n\n    vec2 pixel = floor(pos * vec2(4., 5.));\n    return mod(floor(bin / pow(2., (pixel.x + (pixel.y * 4.)))), 2.);\n}\n\nfloat digits(in vec2 st, in float value, in float nDecDigit, in float nIntDigits) {\n    vec2 st2 = st;\n    float result = 0.0;\n    for (float i = nIntDigits - 1.0; i > 0. ; --i) {\n        if (value < i * 10.) {\n            result += digits(st2, 0.0, nDecDigit);\n            st2.x -= DIGITS_SIZE.x;\n        }\n    }\n    result += digits(st2, value, nDecDigit);\n    return result; \n}\n\nfloat digits(in vec2 st, in float value) {\n    return digits(st, value, (DIGITS_DECIMALS));\n}\n#endif\n"},5991:e=>{e.exports='/*\nauthor: Matt DesLauriers\ndescription: Performs a smoothstep using standard derivatives for anti-aliased edges at any level of magnification. From https://github.com/glslify/glsl-aastep\nuse: aastep(<float> threshold, <float> value)\noption:\n    AA_EDGE: in the absence of derivatives you can specify the antialiasing factor\nlicense: |\n    The MIT License (MIT) Copyright (c) 2015 stackgl\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_AASTEP\n#define FNC_AASTEP\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n\nfloat aastep(float threshold, float value) {\n    #ifdef GL_OES_standard_derivatives\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n    #elif defined(AA_EDGE)\n    float afwidth = AA_EDGE;\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n    #else \n    return step(threshold, value);\n    #endif\n}\n#endif\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: fill a SDF. From PixelSpiritDeck https://github.com/patriciogonzalezvivo/PixelSpiritDeck\nuse: fill(<float> sdf, <float> size [, <float> edge])\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n  Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n  https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_FILL\n#define FNC_FILL\nfloat fill(float x, float size, float edge) {\n    return 1.0 - smoothstep(size - edge, size + edge, x);\n}\n\nfloat fill(float x, float size) {\n    return 1.0 - aastep(size, x);\n}\n#endif\n'},6141:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: Flips the float passed in, 0 becomes 1 and 1 becomes 0\nuse: flip(<float> v, <float> pct)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n  Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n  https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_FLIP\n#define FNC_FLIP\nfloat flip(in float v, in float pct) {\n    return mix(v, 1. - v, pct);\n}\n#endif\n'},5651:e=>{e.exports='\n/*\\\nauthor: Patricio Gonzalez Vivo\ndescription: Returns a hexagon-shaped SDF\nuse: hexSDF(<vec2> st)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n  Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n  https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_HEXSDF\n#define FNC_HEXSDF\nfloat hexSDF(in vec2 st) {\n    st = abs(st * 2. - 1.);\n    return max(abs(st.y), st.x * .866025 + st.y * .5);\n}\n#endif\n\n\n/*\nauthor: Matt DesLauriers\ndescription: Performs a smoothstep using standard derivatives for anti-aliased edges at any level of magnification. From https://github.com/glslify/glsl-aastep\nuse: aastep(<float> threshold, <float> value)\noption:\n    AA_EDGE: in the absence of derivatives you can specify the antialiasing factor\nlicense: |\n    The MIT License (MIT) Copyright (c) 2015 stackgl\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_AASTEP\n#define FNC_AASTEP\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n\nfloat aastep(float threshold, float value) {\n    #ifdef GL_OES_standard_derivatives\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n    #elif defined(AA_EDGE)\n    float afwidth = AA_EDGE;\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n    #else \n    return step(threshold, value);\n    #endif\n}\n#endif\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: fill a SDF. From PixelSpiritDeck https://github.com/patriciogonzalezvivo/PixelSpiritDeck\nuse: fill(<float> sdf, <float> size [, <float> edge])\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n  Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n  https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_FILL\n#define FNC_FILL\nfloat fill(float x, float size, float edge) {\n    return 1.0 - smoothstep(size - edge, size + edge, x);\n}\n\nfloat fill(float x, float size) {\n    return 1.0 - aastep(size, x);\n}\n#endif\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: fill a stroke in a SDF. From PixelSpiritDeck https://github.com/patriciogonzalezvivo/PixelSpiritDeck\nuse: stroke(<float> sdf, <float> size, <float> width [, <float> edge])\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n  Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n  https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_STROKE\n#define FNC_STROKE\n\n/*\nauthor: Matt DesLauriers\ndescription: Performs a smoothstep using standard derivatives for anti-aliased edges at any level of magnification. From https://github.com/glslify/glsl-aastep\nuse: aastep(<float> threshold, <float> value)\noption:\n    AA_EDGE: in the absence of derivatives you can specify the antialiasing factor\nlicense: |\n    The MIT License (MIT) Copyright (c) 2015 stackgl\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_AASTEP\n#define FNC_AASTEP\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n\nfloat aastep(float threshold, float value) {\n    #ifdef GL_OES_standard_derivatives\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n    #elif defined(AA_EDGE)\n    float afwidth = AA_EDGE;\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n    #else \n    return step(threshold, value);\n    #endif\n}\n#endif\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: clamp a value between 0 and 1\nuse: saturation(<float|vec2|vec3|vec4> value)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef FNC_SATURATE\n#define FNC_SATURATE\n// #define saturate(x) clamp(x, 0.0, 1.0)\nfloat saturate( float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec2 saturate( vec2 x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec3 saturate( vec3 x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec4 saturate( vec4 x) {\n    return clamp(x, 0.0, 1.0);\n}\n#endif\n\nfloat stroke(float x, float size, float w) {\n    float d = aastep(size, x + w * 0.5) - aastep(size, x - w * 0.5);\n    return saturate(d);\n}\n\nfloat stroke(float x, float size, float w, float edge) {\n    float d = smoothstep(size - edge, size + edge, x + w * 0.5) - smoothstep(size - edge, size + edge, x - w * 0.5);\n    return saturate(d);\n}\n\n#endif\n\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: draw a hexagon filled or not. \nuse: hex(<vec2> st, <float> size [, <float> width])\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_HEX\n#define FNC_HEX\nfloat hex(vec2 st, float size) {\n    return fill(hexSDF(st), size);\n}\n\nfloat hex(vec2 st, float size, float strokeWidth) {\n    return stroke(hexSDF(st), size, strokeWidth);\n}\n#endif'},672:e=>{e.exports='\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: Returns a rectangular SDF\nuse: rectSDF(<vec2> st, <vec2> size)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n  Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n  https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_RECTSDF\n#define FNC_RECTSDF\nfloat rectSDF(in vec2 st, in vec2 s) {\n    st = st * 2. - 1.;\n    return max( abs(st.x / s.x),\n                abs(st.y / s.y) );\n}\n#endif\n\n\n/*\nauthor: Matt DesLauriers\ndescription: Performs a smoothstep using standard derivatives for anti-aliased edges at any level of magnification. From https://github.com/glslify/glsl-aastep\nuse: aastep(<float> threshold, <float> value)\noption:\n    AA_EDGE: in the absence of derivatives you can specify the antialiasing factor\nlicense: |\n    The MIT License (MIT) Copyright (c) 2015 stackgl\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_AASTEP\n#define FNC_AASTEP\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n\nfloat aastep(float threshold, float value) {\n    #ifdef GL_OES_standard_derivatives\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n    #elif defined(AA_EDGE)\n    float afwidth = AA_EDGE;\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n    #else \n    return step(threshold, value);\n    #endif\n}\n#endif\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: fill a SDF. From PixelSpiritDeck https://github.com/patriciogonzalezvivo/PixelSpiritDeck\nuse: fill(<float> sdf, <float> size [, <float> edge])\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n  Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n  https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_FILL\n#define FNC_FILL\nfloat fill(float x, float size, float edge) {\n    return 1.0 - smoothstep(size - edge, size + edge, x);\n}\n\nfloat fill(float x, float size) {\n    return 1.0 - aastep(size, x);\n}\n#endif\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: fill a stroke in a SDF. From PixelSpiritDeck https://github.com/patriciogonzalezvivo/PixelSpiritDeck\nuse: stroke(<float> sdf, <float> size, <float> width [, <float> edge])\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n  Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n  https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_STROKE\n#define FNC_STROKE\n\n/*\nauthor: Matt DesLauriers\ndescription: Performs a smoothstep using standard derivatives for anti-aliased edges at any level of magnification. From https://github.com/glslify/glsl-aastep\nuse: aastep(<float> threshold, <float> value)\noption:\n    AA_EDGE: in the absence of derivatives you can specify the antialiasing factor\nlicense: |\n    The MIT License (MIT) Copyright (c) 2015 stackgl\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_AASTEP\n#define FNC_AASTEP\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n\nfloat aastep(float threshold, float value) {\n    #ifdef GL_OES_standard_derivatives\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n    #elif defined(AA_EDGE)\n    float afwidth = AA_EDGE;\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n    #else \n    return step(threshold, value);\n    #endif\n}\n#endif\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: clamp a value between 0 and 1\nuse: saturation(<float|vec2|vec3|vec4> value)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef FNC_SATURATE\n#define FNC_SATURATE\n// #define saturate(x) clamp(x, 0.0, 1.0)\nfloat saturate( float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec2 saturate( vec2 x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec3 saturate( vec3 x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec4 saturate( vec4 x) {\n    return clamp(x, 0.0, 1.0);\n}\n#endif\n\nfloat stroke(float x, float size, float w) {\n    float d = aastep(size, x + w * 0.5) - aastep(size, x - w * 0.5);\n    return saturate(d);\n}\n\nfloat stroke(float x, float size, float w, float edge) {\n    float d = smoothstep(size - edge, size + edge, x + w * 0.5) - smoothstep(size - edge, size + edge, x - w * 0.5);\n    return saturate(d);\n}\n\n#endif\n\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: draw a rectangel filled or not. \nuse: rect(<vec2> st, <vec2> size [, <float> width])\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_RECT\n#define FNC_RECT\nfloat rect(vec2 st, vec2 size) {\n    return fill(rectSDF(st, size), 1.0);\n}\n\nfloat rect(vec2 st, vec2 size, float strokeWidth) {\n    return stroke(rectSDF(st, size), 1.0, strokeWidth);\n}\n#endif'},7328:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: fill a stroke in a SDF. From PixelSpiritDeck https://github.com/patriciogonzalezvivo/PixelSpiritDeck\nuse: stroke(<float> sdf, <float> size, <float> width [, <float> edge])\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n  Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n  https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_STROKE\n#define FNC_STROKE\n\n/*\nauthor: Matt DesLauriers\ndescription: Performs a smoothstep using standard derivatives for anti-aliased edges at any level of magnification. From https://github.com/glslify/glsl-aastep\nuse: aastep(<float> threshold, <float> value)\noption:\n    AA_EDGE: in the absence of derivatives you can specify the antialiasing factor\nlicense: |\n    The MIT License (MIT) Copyright (c) 2015 stackgl\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_AASTEP\n#define FNC_AASTEP\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n\nfloat aastep(float threshold, float value) {\n    #ifdef GL_OES_standard_derivatives\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n    #elif defined(AA_EDGE)\n    float afwidth = AA_EDGE;\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n    #else \n    return step(threshold, value);\n    #endif\n}\n#endif\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: clamp a value between 0 and 1\nuse: saturation(<float|vec2|vec3|vec4> value)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef FNC_SATURATE\n#define FNC_SATURATE\n// #define saturate(x) clamp(x, 0.0, 1.0)\nfloat saturate( float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec2 saturate( vec2 x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec3 saturate( vec3 x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec4 saturate( vec4 x) {\n    return clamp(x, 0.0, 1.0);\n}\n#endif\n\nfloat stroke(float x, float size, float w) {\n    float d = aastep(size, x + w * 0.5) - aastep(size, x - w * 0.5);\n    return saturate(d);\n}\n\nfloat stroke(float x, float size, float w, float edge) {\n    float d = smoothstep(size - edge, size + edge, x + w * 0.5) - smoothstep(size - edge, size + edge, x - w * 0.5);\n    return saturate(d);\n}\n\n#endif\n'},5080:e=>{e.exports='\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: Returns a triangle-shaped sdf\nuse: triSDF(<vec2> st)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n  Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n  https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_TRISDF\n#define FNC_TRISDF\nfloat triSDF(in vec2 st) {\n    st = (st * 2. - 1.) * 2.;\n    return max(abs(st.x) * .866025 + st.y * .5, -st.y * .5);\n}\n#endif\n\n\n/*\nauthor: Matt DesLauriers\ndescription: Performs a smoothstep using standard derivatives for anti-aliased edges at any level of magnification. From https://github.com/glslify/glsl-aastep\nuse: aastep(<float> threshold, <float> value)\noption:\n    AA_EDGE: in the absence of derivatives you can specify the antialiasing factor\nlicense: |\n    The MIT License (MIT) Copyright (c) 2015 stackgl\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_AASTEP\n#define FNC_AASTEP\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n\nfloat aastep(float threshold, float value) {\n    #ifdef GL_OES_standard_derivatives\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n    #elif defined(AA_EDGE)\n    float afwidth = AA_EDGE;\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n    #else \n    return step(threshold, value);\n    #endif\n}\n#endif\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: fill a SDF. From PixelSpiritDeck https://github.com/patriciogonzalezvivo/PixelSpiritDeck\nuse: fill(<float> sdf, <float> size [, <float> edge])\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n  Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n  https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_FILL\n#define FNC_FILL\nfloat fill(float x, float size, float edge) {\n    return 1.0 - smoothstep(size - edge, size + edge, x);\n}\n\nfloat fill(float x, float size) {\n    return 1.0 - aastep(size, x);\n}\n#endif\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: fill a stroke in a SDF. From PixelSpiritDeck https://github.com/patriciogonzalezvivo/PixelSpiritDeck\nuse: stroke(<float> sdf, <float> size, <float> width [, <float> edge])\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n  Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n  https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_STROKE\n#define FNC_STROKE\n\n/*\nauthor: Matt DesLauriers\ndescription: Performs a smoothstep using standard derivatives for anti-aliased edges at any level of magnification. From https://github.com/glslify/glsl-aastep\nuse: aastep(<float> threshold, <float> value)\noption:\n    AA_EDGE: in the absence of derivatives you can specify the antialiasing factor\nlicense: |\n    The MIT License (MIT) Copyright (c) 2015 stackgl\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_AASTEP\n#define FNC_AASTEP\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n\nfloat aastep(float threshold, float value) {\n    #ifdef GL_OES_standard_derivatives\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n    #elif defined(AA_EDGE)\n    float afwidth = AA_EDGE;\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n    #else \n    return step(threshold, value);\n    #endif\n}\n#endif\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: clamp a value between 0 and 1\nuse: saturation(<float|vec2|vec3|vec4> value)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef FNC_SATURATE\n#define FNC_SATURATE\n// #define saturate(x) clamp(x, 0.0, 1.0)\nfloat saturate( float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec2 saturate( vec2 x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec3 saturate( vec3 x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec4 saturate( vec4 x) {\n    return clamp(x, 0.0, 1.0);\n}\n#endif\n\nfloat stroke(float x, float size, float w) {\n    float d = aastep(size, x + w * 0.5) - aastep(size, x - w * 0.5);\n    return saturate(d);\n}\n\nfloat stroke(float x, float size, float w, float edge) {\n    float d = smoothstep(size - edge, size + edge, x + w * 0.5) - smoothstep(size - edge, size + edge, x - w * 0.5);\n    return saturate(d);\n}\n\n#endif\n\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: draw a triangle filled or not. \nuse: tri(<vec2> st, <float> size [, <float> width])\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_TRI\n#define FNC_TRI\nfloat tri(vec2 st, float size) {\n    return fill(triSDF(st), size);\n}\n\nfloat tri(vec2 st, float size, float strokeWidth) {\n    return stroke(triSDF(st), size, strokeWidth);\n}\n#endif'},1995:e=>{e.exports='/*\nauthor: Hugh Kennedy (https://github.com/hughsk)\ndescription: get\'s the luminosity of a color. From https://github.com/hughsk/glsl-luma/blob/master/index.glsl\nuse: rgb2luma(<vec3|vec4> color)\nlicense: |\n  This software is released under the MIT license:\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_RGB2LUMA\n#define FNC_RGB2LUMA\nfloat rgb2luma(in vec3 color) {\n    return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat rgb2luma(in vec4 color) {\n    return rgb2luma(color.rgb);\n}\n#endif\n\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: TODO\nuse: bilateralBlur(<sampler2D> texture, <vec2> st, <vec2> duv)\noptions: TODO\nlicense: TODO\n*/\n\n#ifndef BILATERALBLUR_AMOUNT\n#define BILATERALBLUR_AMOUNT bilateralBlur13\n#endif\n\n#ifndef BILATERALBLUR_TYPE\n#define BILATERALBLUR_TYPE vec4\n#endif\n\n#ifndef BILATERALBLUR_SAMPLER_FNC\n#define BILATERALBLUR_SAMPLER_FNC(POS_UV) texture2D(tex, POS_UV)\n#endif\n\n#ifndef BILATERALBLUR_LUMA\n#define BILATERALBLUR_LUMA(RGB) rgb2luma(RGB.rgb)\n#endif\n\n/*\nauthor: Hugh Kennedy (https://github.com/hughsk)\ndescription: get\'s the luminosity of a color. From https://github.com/hughsk/glsl-luma/blob/master/index.glsl\nuse: rgb2luma(<vec3|vec4> color)\nlicense: |\n  This software is released under the MIT license:\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_RGB2LUMA\n#define FNC_RGB2LUMA\nfloat rgb2luma(in vec3 color) {\n    return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat rgb2luma(in vec4 color) {\n    return rgb2luma(color.rgb);\n}\n#endif\n\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: two dimensional bilateral Blur, to do it in one single pass\nuse: bilateralBlur2D(<sampler2D> texture, <vec2> st, <vec2> offset, <int> kernelSize)\noptions:\n  BILATERALBLUR2D_TYPE: default is vec3\n  BILATERALBLUR2D_SAMPLER_FNC(POS_UV): default texture2D(tex, POS_UV)\n  BILATERALBLUR2D_LUMA(RGB): default rgb2luma\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef BILATERALBLUR2D_TYPE\n#define BILATERALBLUR2D_TYPE vec4\n#endif\n\n#ifndef BILATERALBLUR2D_SAMPLER_FNC\n#define BILATERALBLUR2D_SAMPLER_FNC(POS_UV) texture2D(tex, POS_UV)\n#endif\n\n#ifndef BILATERALBLUR2D_LUMA\n#define BILATERALBLUR2D_LUMA(RGB) rgb2luma(RGB.rgb)\n#endif\n\n#ifndef FNC_BILATERALBLUR2D\n#define FNC_BILATERALBLUR2D\nBILATERALBLUR2D_TYPE bilateralBlur2D(in sampler2D tex, in vec2 st, in vec2 offset, const int kernelSize) {\n  BILATERALBLUR2D_TYPE accumColor = BILATERALBLUR2D_TYPE(0.);\n  #ifndef BILATERALBLUR2D_KERNELSIZE\n  #define BILATERALBLUR2D_KERNELSIZE kernelSize\n  #endif\n  float accumWeight = 0.;\n  const float k = .15915494; // 1. / (2.*PI)\n  const float k2 = k * k;\n  float kernelSize2 = float(BILATERALBLUR2D_KERNELSIZE) * float(BILATERALBLUR2D_KERNELSIZE);\n  BILATERALBLUR2D_TYPE tex0 = BILATERALBLUR2D_SAMPLER_FNC(st);\n  float lum0 = BILATERALBLUR2D_LUMA(tex0);\n\n  for (int j = 0; j < BILATERALBLUR2D_KERNELSIZE; j++) {\n    float dy = -.5 * (float(BILATERALBLUR2D_KERNELSIZE) - 1.0) + float(j);\n    for (int i = 0; i < BILATERALBLUR2D_KERNELSIZE; i++) {\n      float dx = -.5 * (float(BILATERALBLUR2D_KERNELSIZE) - 1.0) + float(i);\n      BILATERALBLUR2D_TYPE tex = BILATERALBLUR2D_SAMPLER_FNC(st + vec2(dx, dy) * offset);\n      float lum = BILATERALBLUR2D_LUMA(tex);\n      float dl = 255. * (lum - lum0);\n      float weight = (k2 / kernelSize2) * exp(-(dx * dx + dy * dy + dl * dl) / (2. * kernelSize2));\n      accumColor += weight * tex;\n      accumWeight += weight;\n    }\n  }\n  return accumColor / accumWeight;\n}\n#endif\n\n\n#ifndef FNC_BILATERALFILTER\n#define FNC_BILATERALFILTER\nBILATERALBLUR_TYPE bilateralBlur(in sampler2D tex, in vec2 st, in vec2 offset, const int kernelSize) {\n  return bilateralBlur2D(tex, st, offset, kernelSize);\n}\n\nBILATERALBLUR_TYPE bilateralBlur13(in sampler2D tex, in vec2 st, in vec2 offset) {\n  return bilateralBlur(tex, st, offset, 7);\n}\n\nBILATERALBLUR_TYPE bilateralBlur9(in sampler2D tex, in vec2 st, in vec2 offset) {\n  return bilateralBlur(tex, st, offset, 5);\n}\n\nBILATERALBLUR_TYPE bilateralBlur5(in sampler2D tex, in vec2 st, in vec2 offset) {\n  return bilateralBlur(tex, st, offset, 3);\n}\n\nBILATERALBLUR_TYPE bilateralBlur(in sampler2D tex, in vec2 st, in vec2 offset) {\n  return BILATERALBLUR_AMOUNT(tex, st, offset);\n}\n#endif\n'},4207:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: given a texture return a simple box blured pixel\nuse: boxBlur(<sampler2D> texture, <vec2> st, <vec2> pixel_offset)\noptions:\n  BOXBLUR_2D: default to 1D\n  BOXBLUR_ITERATIONS: default 3\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef BOXBLUR_ITERATIONS\n#define BOXBLUR_ITERATIONS 3\n#endif\n\n#ifndef BOXBLUR_TYPE\n#define BOXBLUR_TYPE vec4\n#endif\n\n#ifndef BOXBLUR_SAMPLER_FNC\n#define BOXBLUR_SAMPLER_FNC(POS_UV) texture2D(tex, POS_UV)\n#endif\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: simple one dimentional box blur, to be applied in two passes\nuse: boxBlur1D(<sampler2D> texture, <vec2> st, <vec2> pixel_offset, <int> kernelSize)\noptions:\n  BOXBLUR1D_TYPE: default is vec4\n  BOXBLUR1D_SAMPLER_FNC(POS_UV): default texture2D(tex, POS_UV)\n  BOXBLUR1D_KERNELSIZE: Use only for WebGL 1.0 and OpenGL ES 2.0 . For example RaspberryPis is not happy with dynamic loops. Default is \'kernelSize\'\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n#ifndef BOXBLUR1D_TYPE\n#define BOXBLUR1D_TYPE vec4\n#endif\n\n#ifndef BOXBLUR1D_SAMPLER_FNC\n#define BOXBLUR1D_SAMPLER_FNC(POS_UV) texture2D(tex, POS_UV)\n#endif\n\n#ifndef FNC_BOXBLUR1D\n#define FNC_BOXBLUR1D\nBOXBLUR1D_TYPE boxBlur1D(in sampler2D tex, in vec2 st, in vec2 offset, const int kernelSize) {\n  BOXBLUR1D_TYPE color = BOXBLUR1D_TYPE(0.);\n  #ifndef BOXBLUR1D_KERNELSIZE\n  #define BOXBLUR1D_KERNELSIZE kernelSize\n  #endif\n\n  float f_kernelSize = float(BOXBLUR1D_KERNELSIZE);\n  float weight = 1. / f_kernelSize;\n\n  for (int i = 0; i < BOXBLUR1D_KERNELSIZE; i++) {\n    float x = -.5 * (f_kernelSize - 1.) + float(i);\n    color += BOXBLUR1D_SAMPLER_FNC(st + offset * x ) * weight;\n  }\n  return color;\n}\n#endif\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: simple two dimentional box blur, so can be apply in a single pass\nuse: boxBlur2D(<sampler2D> texture, <vec2> st, <vec2> pixel_offset, <int> kernelSize)\noptions:\n  BOXBLUR2D_TYPE: Default `vec4`\n  BOXBLUR2D_SAMPLER_FNC(POS_UV): default is `texture2D(tex, POS_UV)`\n  BOXBLUR2D_KERNELSIZE: Use only for WebGL 1.0 and OpenGL ES 2.0 . For example RaspberryPis is not happy with dynamic loops. Default is \'kernelSize\'\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef BOXBLUR2D_TYPE\n#define BOXBLUR2D_TYPE vec4\n#endif\n\n#ifndef BOXBLUR2D_SAMPLER_FNC\n#define BOXBLUR2D_SAMPLER_FNC(POS_UV) texture2D(tex, POS_UV)\n#endif\n\n#ifndef FNC_BOXBLUR2D\n#define FNC_BOXBLUR2D\nBOXBLUR2D_TYPE boxBlur2D(in sampler2D tex, in vec2 st, in vec2 pixel, const int kernelSize) {\n  BOXBLUR2D_TYPE color = BOXBLUR2D_TYPE(0.);\n  #ifndef BOXBLUR2D_KERNELSIZE\n  #define BOXBLUR2D_KERNELSIZE kernelSize\n  #endif\n\n  float accumWeight = 0.;\n  float f_kernelSize = float(BOXBLUR2D_KERNELSIZE);\n  float kernelSize2 = f_kernelSize * f_kernelSize;\n  float weight = 1. / kernelSize2;\n\n  for (int j = 0; j < BOXBLUR2D_KERNELSIZE; j++) {\n    float y = -.5 * (f_kernelSize - 1.) + float(j);\n    for (int i = 0; i < BOXBLUR2D_KERNELSIZE; i++) {\n      float x = -.5 * (f_kernelSize - 1.) + float(i);\n      color += BOXBLUR2D_SAMPLER_FNC(st + vec2(x, y) * pixel) * weight;\n    }\n  }\n  return color;\n}\n#endif\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: simple two dimentional box blur, so can be apply in a single pass\nuse: boxBlur1D_fast9(<sampler2D> texture, <vec2> st, <vec2> pixel_direction)\noptions:\n  BOXBLUR2D_FAST9_TYPE: Default is `vec4`\n  BOXBLUR2D_FAST9_SAMPLER_FNC(POS_UV): Default is `texture2D(tex, POS_UV)`\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef BOXBLUR2D_FAST9_TYPE\n#define BOXBLUR2D_FAST9_TYPE vec4\n#endif\n\n#ifndef BOXBLUR2D_FAST9_SAMPLER_FNC\n#define BOXBLUR2D_FAST9_SAMPLER_FNC(POS_UV) texture2D(tex, POS_UV)\n#endif\n\n#ifndef FNC_BOXBLUR2D_FAST9\n#define FNC_BOXBLUR2D_FAST9\nBOXBLUR2D_FAST9_TYPE boxBlur2D_fast9(in sampler2D tex, in vec2 st, in vec2 offset) {\n  BOXBLUR2D_FAST9_TYPE color = BOXBLUR2D_FAST9_SAMPLER_FNC(st);           // center\n  color += BOXBLUR2D_FAST9_SAMPLER_FNC(st + vec2(-offset.x, offset.y));  // tleft\n  color += BOXBLUR2D_FAST9_SAMPLER_FNC(st + vec2(-offset.x, 0.));        // left\n  color += BOXBLUR2D_FAST9_SAMPLER_FNC(st + vec2(-offset.x, -offset.y)); // bleft\n  color += BOXBLUR2D_FAST9_SAMPLER_FNC(st + vec2(0., offset.y));         // top\n  color += BOXBLUR2D_FAST9_SAMPLER_FNC(st + vec2(0., -offset.y));        // bottom\n  color += BOXBLUR2D_FAST9_SAMPLER_FNC(st + offset);                     // tright\n  color += BOXBLUR2D_FAST9_SAMPLER_FNC(st + vec2(offset.x, 0.));         // right\n  color += BOXBLUR2D_FAST9_SAMPLER_FNC(st + vec2(offset.x, -offset.y));  // bright\n  return color * 0.1111111111; // 1./9.\n}\n#endif\n\n\n#ifndef FNC_BOXBLUR\n#define FNC_BOXBLUR\nBOXBLUR_TYPE boxBlur13(in sampler2D tex, in vec2 st, in vec2 offset) {\n#ifdef BOXBLUR_2D\n  return boxBlur2D(tex, st, offset, 7);\n#else\n  return boxBlur1D(tex, st, offset, 7);\n#endif\n}\n\nBOXBLUR_TYPE boxBlur9(in sampler2D tex, in vec2 st, in vec2 offset) {\n#ifdef BOXBLUR_2D\n  return boxBlur2D_fast9(tex, st, offset);\n#else\n  return boxBlur1D(tex, st, offset, 5);\n#endif\n}\n\nBOXBLUR_TYPE boxBlur5(in sampler2D tex, in vec2 st, in vec2 offset) {\n#ifdef BOXBLUR_2D\n  return boxBlur2D(tex, st, offset, 3);\n#else\n  return boxBlur1D(tex, st, offset, 3);\n#endif\n}\n\nvec4 boxBlur(in sampler2D tex, in vec2 st, vec2 offset, const int kernelSize) {\n#ifdef BOXBLUR_2D\n  return boxBlur2D(tex, st, offset, kernelSize);\n#else\n  return boxBlur1D(tex, st, offset, kernelSize);\n#endif\n}\n\nvec4 boxBlur(in sampler2D tex, in vec2 st, vec2 offset) {\n  #ifdef BOXBLUR_2D\n    return boxBlur2D(tex, st, offset, BOXBLUR_ITERATIONS);\n  #else\n    return boxBlur1D(tex, st, offset, BOXBLUR_ITERATIONS);\n  #endif\n}\n#endif\n'},548:e=>{e.exports='/*\nauthor: [Matt DesLauriers, Patricio Gonzalez Vivo]\ndescription: adapted versions from 5, 9 and 13 gaussian fast blur from https://github.com/Jam3/glsl-fast-gaussian-blur\nuse: gaussianBlur(<sampler2D> texture, <vec2> st, <vec2> pixel_direction [, const int kernelSize])\noptions:\n  GAUSSIANBLUR_AMOUNT: gaussianBlur5 gaussianBlur9 gaussianBlur13 \n  GAUSSIANBLUR_2D: default to 1D\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n#ifndef GAUSSIANBLUR_AMOUNT\n#define GAUSSIANBLUR_AMOUNT gaussianBlur13\n#endif\n\n#ifndef GAUSSIANBLUR_TYPE\n#define GAUSSIANBLUR_TYPE vec4\n#endif\n\n#ifndef GAUSSIANBLUR_SAMPLER_FNC\n#define GAUSSIANBLUR_SAMPLER_FNC(POS_UV) texture2D(tex, POS_UV)\n#endif\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: two dimension Gaussian Blur to be applied in only one passes\nuse: gaussianBlur2D(<sampler2D> texture, <vec2> st, <vec2> pixel_direction , const int kernelSize)\noptions:\n    GAUSSIANBLUR2D_TYPE: Default `vec4`\n    GAUSSIANBLUR2D_SAMPLER_FNC(POS_UV): Default `texture2D(tex, POS_UV)`\n    GAUSSIANBLUR2D_KERNELSIZE: Use only for WebGL 1.0 and OpenGL ES 2.0 . For example RaspberryPis is not happy with dynamic loops. Default is \'kernelSize\'\nlicense: |\n    Copyright (c) 2017 Patricio Gonzalez Vivo.\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n#ifndef GAUSSIANBLUR2D_TYPE\n#define GAUSSIANBLUR2D_TYPE vec4\n#endif\n\n#ifndef GAUSSIANBLUR2D_SAMPLER_FNC\n#define GAUSSIANBLUR2D_SAMPLER_FNC(POS_UV) texture2D(tex, POS_UV)\n#endif\n\n#ifndef FNC_GAUSSIANBLUR2D\n#define FNC_GAUSSIANBLUR2D\nGAUSSIANBLUR2D_TYPE gaussianBlur2D(in sampler2D tex, in vec2 st, in vec2 offset, const int kernelSize) {\n    GAUSSIANBLUR2D_TYPE accumColor = GAUSSIANBLUR2D_TYPE(0.);\n    #ifndef GAUSSIANBLUR2D_KERNELSIZE\n    #define GAUSSIANBLUR2D_KERNELSIZE kernelSize\n    #endif\n\n    float accumWeight = 0.;\n    const float k = .15915494; // 1 / (2*PI)\n    float kernelSize2 = float(GAUSSIANBLUR2D_KERNELSIZE) * float(GAUSSIANBLUR2D_KERNELSIZE);\n\n    for (int j = 0; j < GAUSSIANBLUR2D_KERNELSIZE; j++) {\n        float y = -.5 * (float(GAUSSIANBLUR2D_KERNELSIZE) - 1.) + float(j);\n        for (int i = 0; i < GAUSSIANBLUR2D_KERNELSIZE; i++) {\n            float x = -.5 * (float(GAUSSIANBLUR2D_KERNELSIZE) - 1.) + float(i);\n            float weight = (k / float(GAUSSIANBLUR2D_KERNELSIZE)) * exp(-(x * x + y * y) / (2. * kernelSize2));\n            GAUSSIANBLUR2D_TYPE tex = GAUSSIANBLUR2D_SAMPLER_FNC(st + vec2(x, y) * offset);\n            accumColor += weight * tex;\n            accumWeight += weight;\n        }\n    }\n    return accumColor / accumWeight;\n}\n#endif\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: one dimension Gaussian Blur to be applied in two passes\nuse: gaussianBlur1D(<sampler2D> texture, <vec2> st, <vec2> pixel_direction , const int kernelSize)\noptions:\n    GAUSSIANBLUR1D_TYPE:\n    GAUSSIANBLUR1D_SAMPLER_FNC(POS_UV):\n    GAUSSIANBLUR1D_KERNELSIZE: Use only for WebGL 1.0 and OpenGL ES 2.0 . For example RaspberryPis is not happy with dynamic loops. Default is \'kernelSize\'\nlicense: |\n    Copyright (c) 2017 Patricio Gonzalez Vivo.\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef GAUSSIANBLUR1D_TYPE\n#define GAUSSIANBLUR1D_TYPE vec4\n#endif\n\n#ifndef GAUSSIANBLUR1D_SAMPLER_FNC\n#define GAUSSIANBLUR1D_SAMPLER_FNC(POS_UV)texture2D(tex,POS_UV)\n#endif\n\n#ifndef FNC_GAUSSIANBLUR1D\n#define FNC_GAUSSIANBLUR1D\n\n#ifdef GAUSSIANBLUR1D_DYNAMIC\n\nGAUSSIANBLUR1D_TYPE gaussianBlur1D(in sampler2D tex,in vec2 st,in vec2 offset,const int kernelSize){\n    GAUSSIANBLUR1D_TYPE accumColor = GAUSSIANBLUR1D_TYPE(0.0);\n    \n    float accumWeight = 0.0;\n    const float k = 0.39894228;// 1 / sqrt(2*PI)\n    float kernelSize2 = float(kernelSize)*float(kernelSize);\n    for(int i = 0; i < 16; i++){\n        if( i >= kernelSize)\n            break;\n        float x = -0.5 * (float(kernelSize) - 1.0)+float(i);\n        float weight = (k/float(kernelSize)) * exp(-(x*x)/(2.0*kernelSize2));\n        GAUSSIANBLUR1D_TYPE tex = GAUSSIANBLUR1D_SAMPLER_FNC(st + x * offset);\n        accumColor += weight * tex;\n        accumWeight += weight;\n    }\n    return accumColor/accumWeight;\n}\n\n#else\nGAUSSIANBLUR1D_TYPE gaussianBlur1D(in sampler2D tex,in vec2 st,in vec2 offset,const int kernelSize){\n    GAUSSIANBLUR1D_TYPE accumColor=GAUSSIANBLUR1D_TYPE(0.);\n    #ifndef GAUSSIANBLUR1D_KERNELSIZE\n    #define GAUSSIANBLUR1D_KERNELSIZE kernelSize\n    #endif\n    \n    float accumWeight = 0.0;\n    const float k = 0.39894228;// 1 / sqrt(2*PI)\n    float kernelSize2=float(GAUSSIANBLUR1D_KERNELSIZE)*float(GAUSSIANBLUR1D_KERNELSIZE);\n    for(int i = 0; i < GAUSSIANBLUR1D_KERNELSIZE; i++){\n        float x = -0.5 * (float(GAUSSIANBLUR1D_KERNELSIZE) -1.0) + float(i);\n        float weight = (k/float(GAUSSIANBLUR1D_KERNELSIZE)) * exp(-(x*x)/(2.0*kernelSize2));\n        GAUSSIANBLUR1D_TYPE tex = GAUSSIANBLUR1D_SAMPLER_FNC(st + x * offset);\n        accumColor += weight * tex;\n        accumWeight += weight;\n    }\n    return accumColor/accumWeight;\n}\n#endif\n\n#endif\n\n/*\nfunction: gaussianBlur1D_fast13\nauthor: Matt DesLauriers\ndescription: adapted versions of gaussian fast blur 13 from https://github.com/Jam3/glsl-fast-gaussian-blur\nuse: gaussianBlur1D_fast13(<sampler2D> texture, <vec2> st, <vec2> pixel_direction)\noptions:\n    GAUSSIANBLUR1D_FAST13_TYPE\n    GAUSSIANBLUR1D_FAST13_SAMPLER_FNC(POS_UV)\nlicense: |\n    The MIT License (MIT) Copyright (c) 2015 Jam3\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n\n#ifndef GAUSSIANBLUR1D_FAST13_TYPE\n#define GAUSSIANBLUR1D_FAST13_TYPE vec4\n#endif\n\n#ifndef GAUSSIANBLUR1D_FAST13_SAMPLER_FNC\n#define GAUSSIANBLUR1D_FAST13_SAMPLER_FNC(POS_UV) texture2D(tex, POS_UV)\n#endif\n\n#ifndef FNC_GAUSSIANBLUR1D_FAST13\n#define FNC_GAUSSIANBLUR1D_FAST13\nGAUSSIANBLUR1D_FAST13_TYPE gaussianBlur1D_fast13(in sampler2D tex, in vec2 st, in vec2 offset) {\n    GAUSSIANBLUR1D_FAST13_TYPE color = GAUSSIANBLUR1D_FAST13_TYPE(0.);\n    vec2 off1 = vec2(1.411764705882353) * offset;\n    vec2 off2 = vec2(3.2941176470588234) * offset;\n    vec2 off3 = vec2(5.176470588235294) * offset;\n    color += GAUSSIANBLUR1D_FAST13_SAMPLER_FNC(st) * .1964825501511404;\n    color += GAUSSIANBLUR1D_FAST13_SAMPLER_FNC(st + (off1)) * .2969069646728344;\n    color += GAUSSIANBLUR1D_FAST13_SAMPLER_FNC(st - (off1)) * .2969069646728344;\n    color += GAUSSIANBLUR1D_FAST13_SAMPLER_FNC(st + (off2)) * .09447039785044732;\n    color += GAUSSIANBLUR1D_FAST13_SAMPLER_FNC(st - (off2)) * .09447039785044732;\n    color += GAUSSIANBLUR1D_FAST13_SAMPLER_FNC(st + (off3)) * .010381362401148057;\n    color += GAUSSIANBLUR1D_FAST13_SAMPLER_FNC(st - (off3)) * .010381362401148057;\n    return color;\n}\n#endif\n\n/*\nauthor: Matt DesLauriers\ndescription: adapted versions of gaussian fast blur 13 from https://github.com/Jam3/glsl-fast-gaussian-blur\nuse: gaussianBlur1D_fast9(<sampler2D> texture, <vec2> st, <vec2> pixel_direction)\noptions:\n    GAUSSIANBLUR1D_FAST9_TYPE\n    GAUSSIANBLUR1D_FAST9_SAMPLER_FNC(POS_UV)\nlicense: |\n    The MIT License (MIT) Copyright (c) 2015 Jam3\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n#ifndef GAUSSIANBLUR1D_FAST9_TYPE\n#define GAUSSIANBLUR1D_FAST9_TYPE vec4\n#endif\n\n#ifndef GAUSSIANBLUR1D_FAST9_SAMPLER_FNC\n#define GAUSSIANBLUR1D_FAST9_SAMPLER_FNC(POS_UV) texture2D(tex, POS_UV)\n#endif\n\n#ifndef FNC_GAUSSIANBLUR1D_FAST9\n#define FNC_GAUSSIANBLUR1D_FAST9\nGAUSSIANBLUR1D_FAST9_TYPE gaussianBlur1D_fast9(in sampler2D tex, in vec2 st, in vec2 offset) {\n    GAUSSIANBLUR1D_FAST9_TYPE color = GAUSSIANBLUR1D_FAST9_TYPE(0.);\n    vec2 off1 = vec2(1.3846153846) * offset;\n    vec2 off2 = vec2(3.2307692308) * offset;\n    color += GAUSSIANBLUR1D_FAST9_SAMPLER_FNC(st) * .2270270270;\n    color += GAUSSIANBLUR1D_FAST9_SAMPLER_FNC(st + (off1)) * .3162162162;\n    color += GAUSSIANBLUR1D_FAST9_SAMPLER_FNC(st - (off1)) * .3162162162;\n    color += GAUSSIANBLUR1D_FAST9_SAMPLER_FNC(st + (off2)) * .0702702703;\n    color += GAUSSIANBLUR1D_FAST9_SAMPLER_FNC(st - (off2)) * .0702702703;\n    return color;\n}\n#endif\n\n/*\nauthor: Matt DesLauriers\ndescription: adapted versions of gaussian fast blur 13 from https://github.com/Jam3/glsl-fast-gaussian-blur\nuse: gaussianBlur1D_fast5(<sampler2D> texture, <vec2> st, <vec2> pixel_direction)\noptions:\n    GAUSSIANBLUR1D_FAST5_TYPE\n    GAUSSIANBLUR1D_FAST5_SAMPLER_FNC(POS_UV)\nlicense: |\n    The MIT License (MIT) Copyright (c) 2015 Jam3\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef GAUSSIANBLUR1D_FAST5_TYPE\n#define GAUSSIANBLUR1D_FAST5_TYPE vec4\n#endif\n\n#ifndef GAUSSIANBLUR1D_FAST5_SAMPLER_FNC\n#define GAUSSIANBLUR1D_FAST5_SAMPLER_FNC(POS_UV) texture2D(tex, POS_UV)\n#endif\n\n#ifndef FNC_GAUSSIANBLUR1D_FAST5\n#define FNC_GAUSSIANBLUR1D_FAST5\nGAUSSIANBLUR1D_FAST5_TYPE gaussianBlur1D_fast5(in sampler2D tex, in vec2 st, in vec2 offset) {\n    GAUSSIANBLUR1D_FAST5_TYPE color = GAUSSIANBLUR1D_FAST5_TYPE(0.);\n    vec2 off1 = vec2(1.3333333333333333) * offset;\n    color += GAUSSIANBLUR1D_FAST5_SAMPLER_FNC(st) * .29411764705882354;\n    color += GAUSSIANBLUR1D_FAST5_SAMPLER_FNC(st + (off1)) * .35294117647058826;\n    color += GAUSSIANBLUR1D_FAST5_SAMPLER_FNC(st - (off1)) * .35294117647058826;\n    return color;\n}\n#endif\n\n\n#ifndef FNC_GAUSSIANBLUR\n#define FNC_GAUSSIANBLUR\nGAUSSIANBLUR_TYPE gaussianBlur13(in sampler2D tex, in vec2 st, in vec2 offset) {\n#ifdef GAUSSIANBLUR_2D\n  return gaussianBlur2D(tex, st, offset, 7);\n#else\n  return gaussianBlur1D_fast13(tex, st, offset);\n#endif\n}\n\nGAUSSIANBLUR_TYPE gaussianBlur9(in sampler2D tex, in vec2 st, in vec2 offset) {\n#ifdef GAUSSIANBLUR_2D\n  return gaussianBlur2D(tex, st, offset, 5);\n#else\n  return gaussianBlur1D_fast9(tex, st, offset);\n#endif\n}\n\nGAUSSIANBLUR_TYPE gaussianBlur5(in sampler2D tex, in vec2 st, in vec2 offset) {\n#ifdef GAUSSIANBLUR_2D\n  return gaussianBlur2D(tex, st, offset, 3);\n#else\n  return gaussianBlur1D_fast5(tex, st, offset);\n#endif\n}\n\nGAUSSIANBLUR_TYPE gaussianBlur(in sampler2D tex, in vec2 st, in vec2 offset, const int kernelSize) {\n#ifdef GAUSSIANBLUR_2D\n  return gaussianBlur2D(tex, st, offset, kernelSize);\n#else\n  return gaussianBlur1D(tex, st, offset, kernelSize);\n#endif\n}\n\nGAUSSIANBLUR_TYPE gaussianBlur(in sampler2D tex, in vec2 st, in vec2 offset) {\n  return GAUSSIANBLUR_AMOUNT(tex, st, offset);\n}\n#endif\n'},5551:e=>{e.exports='/*\nauthor: Brad Larson\ndescription: Kuwahara image abstraction, drawn from the work of Kyprianidis, et. al. in their publication "Anisotropic Kuwahara Filtering on the GPU" within the GPU Pro collection. This produces an oil-painting-like image, but it is extremely computationally expensive, so it can take seconds to render a frame on an iPad 2. This might be best used for still images.\nuse: kuwahara(<sampler2D> texture, <vec2> st, <vec2> pixel)\noptions:\n    KUWAHARA_TYPE: defaults to vec3\n    KUWAHARA_SAMPLER_FNC(POS_UV): defaults to texture2D(tex, POS_UV).rgb\n    KUWAHARA_RADIUS radius\nlicence:\n    Copyright (c) 2012, Brad Larson, Ben Cochran, Hugues Lismonde, Keitaroh Kobayashi, Alaric Cole, Matthew Clark, Jacob Gundersen, Chris Williams.\n    All rights reserved.\n    Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n    Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n    Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n    Neither the name of the GPUImage framework nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef KUWAHARA_TYPE\n#define KUWAHARA_TYPE vec3\n#endif\n\n#ifndef KUWAHARA_SAMPLER_FNC\n#define KUWAHARA_SAMPLER_FNC(POS_UV) texture2D(tex, POS_UV).rgb\n#endif\n\n#ifndef KUWAHARA_RADIUS\n#define KUWAHARA_RADIUS radius\n#endif\n\n#ifndef FNC_KUWAHARA\n#define FNC_KUWAHARA\n\n#ifdef TARGET_MOBILE\nKUWAHARA_TYPE kuwahara(in sampler2D tex, in vec2 st, in vec2 pixel, in int radius) {\n    float n = float((KUWAHARA_RADIUS + 1) * (KUWAHARA_RADIUS + 1));\n    int i; int j;\n    KUWAHARA_TYPE m0 = KUWAHARA_TYPE(0.0); KUWAHARA_TYPE m1 = KUWAHARA_TYPE(0.0); KUWAHARA_TYPE m2 = KUWAHARA_TYPE(0.0); KUWAHARA_TYPE m3 = KUWAHARA_TYPE(0.0);\n    KUWAHARA_TYPE s0 = KUWAHARA_TYPE(0.0); KUWAHARA_TYPE s1 = KUWAHARA_TYPE(0.0); KUWAHARA_TYPE s2 = KUWAHARA_TYPE(0.0); KUWAHARA_TYPE s3 = KUWAHARA_TYPE(0.0);\n    KUWAHARA_TYPE rta = KUWAHARA_TYPE(0.0);\n    KUWAHARA_TYPE c;\n\n    for (j = -KUWAHARA_RADIUS; j <= 0; ++j)  {\n        for (i = -KUWAHARA_RADIUS; i <= 0; ++i)  {\n            c = KUWAHARA_SAMPLER_FNC(st + vec2(i,j) * pixel);\n            m0 += c;\n            s0 += c * c;\n        }\n    }\n\n    for (j = -KUWAHARA_RADIUS; j <= 0; ++j)  {\n        for (i = 0; i <= KUWAHARA_RADIUS; ++i)  {\n            c = KUWAHARA_SAMPLER_FNC(st + vec2(i,j) * pixel);\n            m1 += c;\n            s1 += c * c;\n        }\n    }\n\n    for (j = 0; j <= KUWAHARA_RADIUS; ++j)  {\n        for (i = 0; i <= KUWAHARA_RADIUS; ++i)  {\n            c = KUWAHARA_SAMPLER_FNC(st + vec2(i,j) * pixel);\n            m2 += c;\n            s2 += c * c;\n        }\n    }\n\n    for (j = 0; j <= KUWAHARA_RADIUS; ++j)  {\n        for (i = -KUWAHARA_RADIUS; i <= 0; ++i)  {\n            c = KUWAHARA_SAMPLER_FNC(st + vec2(i,j) * pixel);\n            m3 += c;\n            s3 += c * c;\n        }\n    }\n\n    float min_sigma2 = 1e+2;\n    m0 /= n;\n    s0 = abs(s0 / n - m0 * m0);\n\n    float sigma2 = s0.r + s0.g + s0.b;\n    if (sigma2 < min_sigma2) {\n        min_sigma2 = sigma2;\n        rta = m0;\n    }\n\n    m1 /= n;\n    s1 = abs(s1 / n - m1 * m1);\n\n    sigma2 = s1.r + s1.g + s1.b;\n    if (sigma2 < min_sigma2) {\n        min_sigma2 = sigma2;\n        rta = m1;\n    }\n\n    m2 /= n;\n    s2 = abs(s2 / n - m2 * m2);\n\n    sigma2 = s2.r + s2.g + s2.b;\n    if (sigma2 < min_sigma2) {\n        min_sigma2 = sigma2;\n        rta = m2;\n    }\n\n    m3 /= n;\n    s3 = abs(s3 / n - m3 * m3);\n\n    sigma2 = s3.r + s3.g + s3.b;\n    if (sigma2 < min_sigma2) {\n        min_sigma2 = sigma2;\n        rta = m3;\n    }\n\n    return rta;\n}\n#else\n\nKUWAHARA_TYPE kuwahara(in sampler2D tex, in vec2 st, in vec2 pixel, in int radius) {\n\n    float n = float((KUWAHARA_RADIUS + 1) * (KUWAHARA_RADIUS + 1));\n    int i; int j;\n    KUWAHARA_TYPE m0 = KUWAHARA_TYPE(0.0); KUWAHARA_TYPE m1 = KUWAHARA_TYPE(0.0); KUWAHARA_TYPE m2 = KUWAHARA_TYPE(0.0); KUWAHARA_TYPE m3 = KUWAHARA_TYPE(0.0);\n    KUWAHARA_TYPE s0 = KUWAHARA_TYPE(0.0); KUWAHARA_TYPE s1 = KUWAHARA_TYPE(0.0); KUWAHARA_TYPE s2 = KUWAHARA_TYPE(0.0); KUWAHARA_TYPE s3 = KUWAHARA_TYPE(0.0);\n    KUWAHARA_TYPE rta = KUWAHARA_TYPE(0.0);\n    KUWAHARA_TYPE c;\n    \n    for (j = -KUWAHARA_RADIUS; j <= 0; ++j)  {\n        for (i = -KUWAHARA_RADIUS; i <= 0; ++i)  {\n            c = KUWAHARA_SAMPLER_FNC(st + vec2(i,j) * pixel);\n            m0 += c;\n            s0 += c * c;\n        }\n    }\n    \n    for (j = -KUWAHARA_RADIUS; j <= 0; ++j)  {\n        for (i = 0; i <= KUWAHARA_RADIUS; ++i)  {\n            c = KUWAHARA_SAMPLER_FNC(st + vec2(i,j) * pixel);\n            m1 += c;\n            s1 += c * c;\n        }\n    }\n    \n    for (j = 0; j <= KUWAHARA_RADIUS; ++j)  {\n        for (i = 0; i <= KUWAHARA_RADIUS; ++i)  {\n            c = KUWAHARA_SAMPLER_FNC(st + vec2(i,j) * pixel);\n            m2 += c;\n            s2 += c * c;\n        }\n    }\n    \n    for (j = 0; j <= KUWAHARA_RADIUS; ++j)  {\n        for (i = -KUWAHARA_RADIUS; i <= 0; ++i)  {\n            c = KUWAHARA_SAMPLER_FNC(st + vec2(i,j) * pixel);\n            m3 += c;\n            s3 += c * c;\n        }\n    }\n    \n    \n    float min_sigma2 = 1e+2;\n    m0 /= n;\n    s0 = abs(s0 / n - m0 * m0);\n    \n    float sigma2 = s0.r + s0.g + s0.b;\n    if (sigma2 < min_sigma2) {\n        min_sigma2 = sigma2;\n        rta = m0;\n    }\n    \n    m1 /= n;\n    s1 = abs(s1 / n - m1 * m1);\n    \n    sigma2 = s1.r + s1.g + s1.b;\n    if (sigma2 < min_sigma2) {\n        min_sigma2 = sigma2;\n        rta = m1;\n    }\n    \n    m2 /= n;\n    s2 = abs(s2 / n - m2 * m2);\n    \n    sigma2 = s2.r + s2.g + s2.b;\n    if (sigma2 < min_sigma2) {\n        min_sigma2 = sigma2;\n        rta = m2;\n    }\n    \n    m3 /= n;\n    s3 = abs(s3 / n - m3 * m3);\n    \n    sigma2 = s3.r + s3.g + s3.b;\n    if (sigma2 < min_sigma2) {\n        min_sigma2 = sigma2;\n        rta = m3;\n    }\n\n    return rta;\n}\n\n#endif\n\n#endif'},3018:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: laplacian filter\nuse: laplacian(<sampler2D> texture, <vec2> st, <vec2> pixels_scale [, <float> pixel_padding])\noptions:\n    LAPLACIAN_TYPE: Return type, defaults to float\n    LAPLACIAN_SAMPLER_FNC: Function used to sample the input texture, defaults to texture2D(tex,POS_UV).r\nlicense: |\n    Copyright (c) 2021 Patricio Gonzalez Vivo.\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef LAPLACIAN_TYPE\n#define LAPLACIAN_TYPE vec3\n#endif\n\n#ifndef LAPLACIAN_SAMPLER_FNC\n#define LAPLACIAN_SAMPLER_FNC(POS_UV) texture2D(tex, POS_UV).rgb\n#endif\n\n#ifndef LAPLACIAN_FNC\n#define LAPLACIAN_FNC laplacian_w4\n#endif\n\n// #define LAPLACE_W4 0\n// #define LAPLACE_W8 0\n// #define LAPLACE_W12 0\n\n// LAPLACE FILTER (highpass)\n//                                  \n//   0  1  0    1  1  1    1   2   1\n//   1 -4  1    1 -8  1    2 -12   2\n//   0  1  0    1  1  1    1   2   1\n//    \n\n#ifndef FNC_LAPLACIAN\n#define FNC_LAPLACIAN\n\nLAPLACIAN_TYPE laplacian_w4(sampler2D tex, vec2 st, vec2 pixel) {\n    LAPLACIAN_TYPE acc = LAPLACIAN_TYPE(0.0);\n    acc += LAPLACIAN_SAMPLER_FNC(st) * 4.0;\n    acc -= LAPLACIAN_SAMPLER_FNC(st + vec2(-1.0,  0.0) * pixel);\n    acc -= LAPLACIAN_SAMPLER_FNC(st + vec2( 0.0, -1.0) * pixel);\n    acc -= LAPLACIAN_SAMPLER_FNC(st + vec2( 0.0,  1.0) * pixel);\n    acc -= LAPLACIAN_SAMPLER_FNC(st + vec2( 1.0,  0.0) * pixel);\n    return acc;\n}\n\nLAPLACIAN_TYPE laplacian_w8(sampler2D tex, vec2 st, vec2 pixel) {\n    LAPLACIAN_TYPE acc = LAPLACIAN_TYPE(0.0);\n    acc += LAPLACIAN_SAMPLER_FNC(st) * 8.0;\n    acc -= LAPLACIAN_SAMPLER_FNC(st + vec2(-1.0,  0.0) * pixel);\n    acc -= LAPLACIAN_SAMPLER_FNC(st + vec2( 0.0, -1.0) * pixel);\n    acc -= LAPLACIAN_SAMPLER_FNC(st + vec2( 0.0,  1.0) * pixel);\n    acc -= LAPLACIAN_SAMPLER_FNC(st + vec2( 1.0,  0.0) * pixel);\n    acc -= LAPLACIAN_SAMPLER_FNC(st + vec2(-1.0,  1.0) * pixel);\n    acc -= LAPLACIAN_SAMPLER_FNC(st + vec2( 1.0, -1.0) * pixel);\n    acc -= LAPLACIAN_SAMPLER_FNC(st + vec2( 1.0,  1.0) * pixel);\n    acc -= LAPLACIAN_SAMPLER_FNC(st + vec2( 1.0,  1.0) * pixel);\n    return acc;\n}\n\nLAPLACIAN_TYPE laplacian_w12(sampler2D tex, vec2 st, vec2 pixel) {\n    LAPLACIAN_TYPE acc = LAPLACIAN_TYPE(0.0);\n    acc += LAPLACIAN_SAMPLER_FNC(st) * 12.0;\n    acc -= LAPLACIAN_SAMPLER_FNC(st + vec2(-1.0,  0.0) * pixel) * 2.0;\n    acc -= LAPLACIAN_SAMPLER_FNC(st + vec2( 0.0, -1.0) * pixel) * 2.0;\n    acc -= LAPLACIAN_SAMPLER_FNC(st + vec2( 0.0,  1.0) * pixel) * 2.0;\n    acc -= LAPLACIAN_SAMPLER_FNC(st + vec2( 1.0,  0.0) * pixel) * 2.0;\n\n    acc -= LAPLACIAN_SAMPLER_FNC(st + vec2(-1.0,  1.0) * pixel);\n    acc -= LAPLACIAN_SAMPLER_FNC(st + vec2( 1.0, -1.0) * pixel);\n    acc -= LAPLACIAN_SAMPLER_FNC(st + vec2( 1.0,  1.0) * pixel);\n    acc -= LAPLACIAN_SAMPLER_FNC(st + vec2( 1.0,  1.0) * pixel);\n    return acc;\n}\n\nLAPLACIAN_TYPE laplacian(sampler2D tex, vec2 st, vec2 pixel) {\n    return LAPLACIAN_FNC(tex, st, pixel);\n}\n\nbool laplacian_isOutside(vec2 pos) {\n    return (pos.x < 0.0 || pos.y < 0.0 || pos.x > 1.0 || pos.y > 1.0);\n}\n\nLAPLACIAN_TYPE laplacian_w4(sampler2D tex, vec2 st, vec2 pixel, float pixel_pad) {\n    LAPLACIAN_TYPE acc = LAPLACIAN_TYPE(0.0);\n    vec2 uv = st * vec2(1.0 + pixel_pad * 2.0 * pixel) - pixel_pad * pixel;\n    vec3 pixelShift = LAPLACIAN_TYPE(pixel, 0.0);\n\n    if (!laplacian_isOutside(uv)) acc.xyz = 4.0 * LAPLACIAN_SAMPLER_FNC(uv);\n    vec2 e = uv + pixelShift.xz;\n    if (!laplacian_isOutside(e)) acc.xyz -= LAPLACIAN_SAMPLER_FNC(e);\n    vec2 n = uv + pixelShift.zy;\n    if (!laplacian_isOutside(n)) acc.xyz -= LAPLACIAN_SAMPLER_FNC(n);\n    vec2 w = uv - pixelShift.xz;\n    if (!laplacian_isOutside(w)) acc.xyz -= LAPLACIAN_SAMPLER_FNC(w);\n    vec2 s = uv - pixelShift.zy;\n    if (!laplacian_isOutside(s)) acc.xyz -= LAPLACIAN_SAMPLER_FNC(s);\n    return acc;\n}\n\nLAPLACIAN_TYPE laplacian_w8(sampler2D tex, vec2 st, vec2 pixel, float pixel_pad) {\n    LAPLACIAN_TYPE acc = LAPLACIAN_TYPE(0.0);\n    vec2 uv = st * vec2(1.0 + pixel_pad * 2.0 * pixel) - pixel_pad * pixel;\n    vec3 pixelShift = vec3(pixel, 0.0);\n\n    if (!laplacian_isOutside(uv)) acc.xyz = 8.0 * LAPLACIAN_SAMPLER_FNC(uv);\n    vec2 e = uv + pixelShift.xz;\n    if (!laplacian_isOutside(e)) acc.xyz -= LAPLACIAN_SAMPLER_FNC(e);\n    vec2 n = uv + pixelShift.zy;\n    if (!laplacian_isOutside(n)) acc.xyz -= LAPLACIAN_SAMPLER_FNC(n);\n    vec2 w = uv - pixelShift.xz;\n    if (!laplacian_isOutside(w)) acc.xyz -= LAPLACIAN_SAMPLER_FNC(w);\n    vec2 s = uv - pixelShift.zy;\n    if (!laplacian_isOutside(s)) acc.xyz -= LAPLACIAN_SAMPLER_FNC(s);\n\n    vec2 ne = n + e;\n    if (!laplacian_isOutside(e)) acc.xyz -= LAPLACIAN_SAMPLER_FNC(e);\n    vec2 nw = n + w;\n    if (!laplacian_isOutside(n)) acc.xyz -= LAPLACIAN_SAMPLER_FNC(n);\n    vec2 se = s + e;\n    if (!laplacian_isOutside(w)) acc.xyz -= LAPLACIAN_SAMPLER_FNC(w);\n    vec2 sw = s + w;\n    if (!laplacian_isOutside(s)) acc.xyz -= LAPLACIAN_SAMPLER_FNC(s);\n\n    return acc;\n}\n\nLAPLACIAN_TYPE laplacian_w12(sampler2D tex, vec2 st, vec2 pixel, float pixel_pad) {\n    LAPLACIAN_TYPE acc = LAPLACIAN_TYPE(0.0);\n    vec2 uv = st * vec2(1.0 + pixel_pad * 2.0 * pixel) - pixel_pad * pixel;\n    vec3 pixelShift = vec3(pixel, 0.0);\n\n    if (!laplacian_isOutside(uv)) acc.xyz = 12.0 * LAPLACIAN_SAMPLER_FNC(uv);\n\n    vec2 e = uv + pixelShift.xz;\n    if (!laplacian_isOutside(e)) acc.xyz -= LAPLACIAN_SAMPLER_FNC(e) * 2.0;\n    vec2 n = uv + pixelShift.zy;\n    if (!laplacian_isOutside(n)) acc.xyz -= LAPLACIAN_SAMPLER_FNC(n) * 2.0;\n    vec2 w = uv - pixelShift.xz;\n    if (!laplacian_isOutside(w)) acc.xyz -= LAPLACIAN_SAMPLER_FNC(w) * 2.0;\n    vec2 s = uv - pixelShift.zy;\n    if (!laplacian_isOutside(s)) acc.xyz -= LAPLACIAN_SAMPLER_FNC(s) * 2.0;\n\n    vec2 ne = n + e;\n    if (!laplacian_isOutside(e)) acc.xyz -= LAPLACIAN_SAMPLER_FNC(e);\n    vec2 nw = n + w;\n    if (!laplacian_isOutside(n)) acc.xyz -= LAPLACIAN_SAMPLER_FNC(n);\n    vec2 se = s + e;\n    if (!laplacian_isOutside(w)) acc.xyz -= LAPLACIAN_SAMPLER_FNC(w);\n    vec2 sw = s + w;\n    if (!laplacian_isOutside(s)) acc.xyz -= LAPLACIAN_SAMPLER_FNC(s);\n\n    return acc;\n}\n\nLAPLACIAN_TYPE laplacian(sampler2D tex, vec2 st, vec2 pixel, float pixel_pad) {\n    return LAPLACIAN_FNC(tex, st, pixel, pixel_pad);\n}\n\n#endif'},7030:e=>{e.exports='/*\nauthor: Brad Larson\ndescription: adapted version of mean average sampling on four coorners of a sampled point from https://github.com/BradLarson/GPUImage2\nuse: mean(<sampler2D> texture, <vec2> st, <vec2> pixel)\noptions:\n    MEAN_TYPE: defaults to vec4\n    AVERAGE_SAMPLER_FNC(POS_UV): defaults to texture2D(tex,POS_UV)\nlicence:\n    Copyright (c) 2015, Brad Larson. All rights reserved.\n    Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n    Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n    Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n    Neither the name of the GPUImage framework nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef MEAN_TYPE\n#define MEAN_TYPE vec4\n#endif\n\n#ifndef MEAN_AMOUNT\n#define MEAN_AMOUNT mean4\n#endif\n\n#ifndef MEAN_SAMPLER_FNC\n#define MEAN_SAMPLER_FNC(POS_UV) texture2D(tex,POS_UV)\n#endif\n\n#ifndef FNC_AVERAGE\n#define FNC_AVERAGE\nMEAN_TYPE mean4(in sampler2D tex, in vec2 st, in vec2 pixel) {\n    MEAN_TYPE topLeft = MEAN_SAMPLER_FNC(st - pixel);\n    MEAN_TYPE bottomLeft = MEAN_SAMPLER_FNC(st + vec2(-pixel.x, pixel.y));\n    MEAN_TYPE topRight = MEAN_SAMPLER_FNC(st + vec2(pixel.x, -pixel.y));\n    MEAN_TYPE bottomRight = MEAN_SAMPLER_FNC(st + pixel);\n    return 0.25 * (topLeft + topRight + bottomLeft + bottomRight);\n}\n\nMEAN_TYPE mean(in sampler2D tex, in vec2 st, in vec2 pixel) {\n    return MEAN_AMOUNT(tex, st, pixel);\n}\n#endif\n'},6815:e=>{e.exports='/*\nauthor:[Morgan McGuire, Kyle Whitson]\ndescription: 3x3 and 5x5 median filter, adapted from "A Fast, Small-Radius GPU Median Filter" by Morgan McGuire in ShaderX6 https://casual-effects.com/research/McGuire2008Median/index.html\nuse: median(<sampler2D> texture, <vec2> st, <vec2> pixel)\noptions:\n  MEDIAN_AMOUNT: median3 (3x3) median5 (5x5)\n  MEDIAN_TYPE: default vec4\n  MEDIAN_SAMPLER_FNC(POS_UV): default texture2D(tex, POS_UV)\nlicense:\n  Copyright (c) Morgan McGuire and Williams College, 2006. All rights reserved.\n  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef MEDIAN_AMOUNT\n#define MEDIAN_AMOUNT median5\n#endif\n\n#ifndef MEDIAN_TYPE\n#define MEDIAN_TYPE vec4\n#endif\n\n#ifndef MEDIAN_SAMPLER_FNC\n#define MEDIAN_SAMPLER_FNC(POS_UV) texture2D(tex, POS_UV)\n#endif\n\n/*\nauthor: [Morgan McGuire, Kyle Whitson]\ndescription: |\n    3x3 median filter, adapted from "A Fast, Small-Radius GPU Median Filter" \n    by Morgan McGuire in ShaderX6 https://casual-effects.com/research/McGuire2008Median/index.html\nuse: median2D_fast3(<sampler2D> texture, <vec2> st, <vec2> pixel)\noptions:\n    MEDIAN2D_FAST3_TYPE: default vec4\n    MEDIAN2D_FAST3_SAMPLER_FNC(POS_UV): default texture2D(tex, POS_UV)\nlicense:\n    Copyright (c) Morgan McGuire and Williams College, 2006. All rights reserved.\n    Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n    Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n    Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n*/\n\n#ifndef MEDIAN2D_FAST3_TYPE\n#define MEDIAN2D_FAST3_TYPE vec4\n#endif\n\n#ifndef MEDIAN2D_FAST3_SAMPLER_FNC\n#define MEDIAN2D_FAST3_SAMPLER_FNC(POS_UV) texture2D(tex, POS_UV)\n#endif\n\n#ifndef MEDIAN_S2\n#define MEDIAN_S2(a, b) temp = a; a = min(a, b); b = max(temp, b);\n#endif\n\n#ifndef MEDIAN_2\n#define MEDIAN_2(a, b) MEDIAN_S2(v[a], v[b]);\n#endif\n\n#ifndef FNC_MEDIAN2D_FAST3\n#define FNC_MEDIAN2D_FAST3\n#define MEDIAN_MN3(a, b, c) MEDIAN_2(a, b); MEDIAN_2(a, c);\n#define MEDIAN_MX3(a, b, c) MEDIAN_2(b, c); MEDIAN_2(a, c);\n#define MEDIAN_MNMX3(a, b, c) MEDIAN_MX3(a, b, c); MEDIAN_2(a, b);                                                                // 3 exchanges\n#define MEDIAN_MNMX4(a, b, c, d) MEDIAN_2(a, b); MEDIAN_2(c, d); MEDIAN_2(a, c); MEDIAN_2(b, d);                                  // 4 exchanges\n#define MEDIAN_MNMX5(a, b, c, d, e) MEDIAN_2(a, b); MEDIAN_2(c, d); MEDIAN_MN3(a, c, e); MEDIAN_MX3(b, d, e);                     // 6 exchanges\n#define MEDIAN_MNMX6(a, b, c, d, e, f) MEDIAN_2(a, d); MEDIAN_2(b, e); MEDIAN_2(c, f); MEDIAN_MN3(a, b, c); MEDIAN_MX3(d, e, f);  // 7 exchanges\nMEDIAN2D_FAST3_TYPE median2D_fast3(in sampler2D tex, in vec2 st, in vec2 radius) {\n    MEDIAN2D_FAST3_TYPE v[9];\n    for (int dX = -1; dX <= 1; ++dX) {\n        for (int dY = -1; dY <= 1; ++dY) {\n            vec2 offset = vec2(float(dX), float(dY));\n            // If a pixel in the window is located at (x+dX, y+dY), put it at index (dX + R)(2R + 1) + (dY + R) of the\n            // pixel array. This will fill the pixel array, with the top left pixel of the window at pixel[0] and the\n            // bottom right pixel of the window at pixel[N-1].\n            v[(dX + 1) * 3 + (dY + 1)] = MEDIAN2D_FAST3_SAMPLER_FNC(st + offset * radius);\n        }\n    }\n    MEDIAN2D_FAST3_TYPE temp = MEDIAN2D_FAST3_TYPE(0.);\n    MEDIAN_MNMX6(0, 1, 2, 3, 4, 5);\n    MEDIAN_MNMX5(1, 2, 3, 4, 6);\n    MEDIAN_MNMX4(2, 3, 4, 7);\n    MEDIAN_MNMX3(3, 4, 8);\n    return v[4];\n}\n#endif\n\n/*\nauthor: [Morgan McGuire, Kyle Whitson]\ndescription: |\n    3x3 median filter, adapted from "A Fast, Small-Radius GPU Median Filter" \n    by Morgan McGuire in ShaderX6 https://casual-effects.com/research/McGuire2008Median/index.html\nuse: median2D_fast5(<sampler2D> texture, <vec2> st, <vec2> pixel)\noptions:\n    MEDIAN2D_FAST5_TYPE: default vec4\n    MEDIAN2D_FAST5_SAMPLER_FNC(POS_UV): default texture2D(tex, POS_UV)\nlicense:\n    Copyright (c) Morgan McGuire and Williams College, 2006. All rights reserved.\n    Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n    Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n    Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n*/\n\n#ifndef MEDIAN2D_FAST5_TYPE\n#define MEDIAN2D_FAST5_TYPE vec4\n#endif\n\n#ifndef MEDIAN2D_FAST5_SAMPLER_FNC\n#define MEDIAN2D_FAST5_SAMPLER_FNC(POS_UV) texture2D(tex, POS_UV)\n#endif\n\n#ifndef MEDIAN_S2\n#define MEDIAN_S2(a, b) temp = a; a = min(a, b); b = max(temp, b);\n#endif\n\n#ifndef MEDIAN_2\n#define MEDIAN_2(a, b) MEDIAN_S2(v[a], v[b]);\n#endif\n\n#ifndef FNC_MEDIAN2D_FAST5\n#define FNC_MEDIAN2D_FAST5\n#define MEDIAN_S2(a, b) temp = a; a = min(a, b); b = max(temp, b);\n#define MEDIAN_2(a, b) MEDIAN_S2(v[a], v[b]);\n\n#define MEDIAN_24(a, b, c, d, e, f, g, h) MEDIAN_2(a, b); MEDIAN_2(c, d); MEDIAN_2(e, f); MEDIAN_2(g, h);\n#define MEDIAN_25(a, b, c, d, e, f, g, h, i, j) MEDIAN_24(a, b, c, d, e, f, g, h); MEDIAN_2(i, j);\n\nMEDIAN2D_FAST5_TYPE median2D_fast5(in sampler2D tex, in vec2 st, in vec2 radius) {\n    MEDIAN2D_FAST5_TYPE v[25];\n    for (int dX = -2; dX <= 2; ++dX) {\n        for (int dY = -2; dY <= 2; ++dY) {\n            vec2 offset = vec2(float(dX), float(dY));\n            // If a pixel in the window is located at (x+dX, y+dY), put it at index (dX + R)(2R + 1) + (dY + R) of the\n            // pixel array. This will fill the pixel array, with the top left pixel of the window at pixel[0] and the\n            // bottom right pixel of the window at pixel[N-1].\n            v[(dX + 2) * 5 + (dY + 2)] = MEDIAN2D_FAST5_SAMPLER_FNC(st + offset * radius);\n        }\n    }\n\n    MEDIAN2D_FAST5_TYPE temp = MEDIAN2D_FAST5_TYPE(0.);\n    MEDIAN_25(0,  1,   3, 4,  2,  4,  2,  3,  6,  7);\n    MEDIAN_25(5,  7,   5, 6,  9,  7,  1,  7,  1,  4);\n    MEDIAN_25(12, 13, 11, 13, 11, 12, 15, 16, 14, 16);\n    MEDIAN_25(14, 15, 18, 19, 17, 19, 17, 18, 21, 22);\n    MEDIAN_25(20, 22, 20, 21, 23, 24, 2,  5,  3,  6);\n    MEDIAN_25(0,  6,  0,  3,  4,  7,  1,  7,  1,  4);\n    MEDIAN_25(11, 14, 8,  14, 8,  11, 12, 15, 9,  15);\n    MEDIAN_25(9,  12, 13, 16, 10, 16, 10, 13, 20, 23);\n    MEDIAN_25(17, 23, 17, 20, 21, 24, 18, 24, 18, 21);\n    MEDIAN_25(19, 22, 8,  17, 9,  18, 0,  18, 0,  9);\n    MEDIAN_25(10, 19, 1,  19, 1,  10, 11, 20, 2,  20);\n    MEDIAN_25(2,  11, 12, 21, 3,  21, 3,  12, 13, 22);\n    MEDIAN_25(4,  22, 4,  13, 14, 23, 5,  23, 5,  14);\n    MEDIAN_25(15, 24, 6,  24, 6,  15, 7,  16, 7,  19);\n    MEDIAN_25(3,  11, 5,  17, 11, 17, 9,  17, 4,  10);\n    MEDIAN_25(6,  12, 7,  14, 4,  6,  4,  7,  12, 14);\n    MEDIAN_25(10, 14, 6,  7,  10, 12, 6,  10, 6,  17);\n    MEDIAN_25(12, 17, 7,  17, 7,  10, 12, 18, 7,  12);\n    MEDIAN_24(10, 18, 12, 20, 10, 20, 10, 12);\n    return v[12];\n}\n#endif\n\n\n#ifndef FNC_MEDIAN\n#define FNC_MEDIAN\nMEDIAN_TYPE median3(in sampler2D tex, in vec2 st, in vec2 radius) {\n  return median2D_fast3(tex, st, radius);\n}\n\nMEDIAN_TYPE median5(in sampler2D tex, in vec2 st, in vec2 radius) {\n  return median2D_fast5(tex, st, radius);\n}\n\nMEDIAN_TYPE median(in sampler2D tex, in vec2 st, in vec2 radius) {\n  return MEDIAN_AMOUNT(tex, st, radius);\n}\n#endif\n'},6105:e=>{e.exports="/*\nauthor: Alan Wolfe\ndescription:  white noise blur based on this shader https://www.shadertoy.com/view/XsVBDR\nuse: noiseBlur(<sampler2D> texture, <vec2> st, <vec2> pixel, <float> radius)\noptions:\n    NOISEBLUR_TYPE: default to vec3\n    NOISEBLUR_GAUSSIAN_K: no gaussian by default\n    NOISEBLUR_RANDOM23_FNC(UV): defaults to random2(UV)\n    NOISEBLUR_SAMPLE_FNC(UV): defualts to texture2D(tex, UV).rgb\n    NOISEBLUR_SAMPLES: default to 4\nlicence: |\n    TODO\n*/\n\n#define RANDOM_SCALE3 vec3(443.897, 441.423, .0973)\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: pass a value and get some random normalize value between 0 and 1\nuse: float random[2|3](<float|vec2|vec3> value)\n*/\n\n#ifndef FNC_RANDOM\n#define FNC_RANDOM\nfloat random(in float x) {\n  return fract(sin(x) * 43758.5453);\n}\n\nfloat random(in vec2 st) {\n  return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat random(in vec3 pos) {\n  return fract(sin(dot(pos.xyz, vec3(70.9898, 78.233, 32.4355))) * 43758.5453123);\n}\n\nfloat random(in vec4 pos) {\n    float dot_product = dot(pos, vec4(12.9898,78.233,45.164,94.673));\n    return fract(sin(dot_product) * 43758.5453);\n}\n\n// Hash function from https://www.shadertoy.com/view/4djSRW\n#ifndef RANDOM_SCALE3\n#define RANDOM_SCALE3 vec3(.1031, .1030, .0973)\n#endif\n\n#ifndef FANDOM_SCALE4\n#define FANDOM_SCALE4 vec4(1031, .1030, .0973, .1099)\n#endif\nvec2 random2(float p) {\n    vec3 p3 = fract(vec3(p) * RANDOM_SCALE3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 random2(in vec2 st) {\n    const vec2 k = vec2(.3183099, .3678794);\n    st = st * k + k.yx;\n    return -1. + 2. * fract(16. * k * fract(st.x * st.y * (st.x + st.y)));\n}\n\nvec2 random2(vec3 p3) {\n    p3 = fract(p3 * RANDOM_SCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 random3(float p) {\n    vec3 p3 = fract(vec3(p) * RANDOM_SCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec3 random3(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * RANDOM_SCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 random3(in vec3 p) {\n    p = vec3( dot(p, vec3(127.1, 311.7, 74.7)),\n            dot(p, vec3(269.5, 183.3, 246.1)),\n            dot(p, vec3(113.5, 271.9, 124.6)));\n    return -1. + 2. * fract(sin(p) * 43758.5453123);\n}\n\nvec4 random4(float p) {\n    vec4 p4 = fract(vec4(p) * FANDOM_SCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);   \n}\n\nvec4 random4(vec2 p) {\n    vec4 p4 = fract(vec4(p.xyxy) * FANDOM_SCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 random4(vec3 p) {\n    vec4 p4 = fract(vec4(p.xyzx)  * FANDOM_SCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 random4(vec4 p4) {\n    p4 = fract(p4  * FANDOM_SCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n#endif\n\n\n#ifndef NOISEBLUR_SAMPLES\n#define NOISEBLUR_SAMPLES 4\n#endif\n\n#ifndef NOISEBLUR_TYPE\n#define NOISEBLUR_TYPE vec3\n#endif\n\n#ifndef NOISEBLUR_SAMPLE_FNC\n#define NOISEBLUR_SAMPLE_FNC(UV) texture2D(tex, UV).rgb\n#endif\n\n#ifndef NOISEBLUR_RANDOM23_FNC\n#define NOISEBLUR_RANDOM23_FNC(UV) random2(UV)\n#endif\n\n#ifndef FNC_NOISEBLUR\n#define FNC_NOISEBLUR\nNOISEBLUR_TYPE noiseBlur(in sampler2D tex, in vec2 st, in vec2 pixel, float radius) {\n    float blurRadius = radius;\n    vec2 whiteNoiseUV = st;\n    NOISEBLUR_TYPE result = NOISEBLUR_TYPE(0.0);\n    for (int i = 0; i < NOISEBLUR_SAMPLES; ++i) {\n        vec2 whiteNoiseRand = NOISEBLUR_RANDOM23_FNC(vec3(whiteNoiseUV.xy, float(i)));\n        whiteNoiseUV = whiteNoiseRand;\n\n        vec2 r = whiteNoiseRand;\n        r.x *= TAU;\n        \n        #if defined(NOISEBLUR_GAUSSIAN_K)\n        // box-muller transform to get gaussian distributed sample points in the circle\n        vec2 cr = vec2(sin(r.x),cos(r.x))*sqrt(-NOISEBLUR_GAUSSIAN_K * log(r.y));\n        #else\n        // uniform sample the circle\n        vec2 cr = vec2(sin(r.x),cos(r.x))*sqrt(r.y);\n        #endif\n        \n        NOISEBLUR_TYPE color = NOISEBLUR_SAMPLE_FNC( st + cr * blurRadius * pixel );\n        // average the samples as we get em\n        // https://blog.demofox.org/2016/08/23/incremental-averaging/\n        result = mix(result, color, 1.0 / float(i+1));\n    }\n    return result;\n}\n#endif"},6827:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: make a radial blur, with dir as the direction to the center and strength as the amount\nuse: radialBlur(<sampler2D> texture, <vec2> st, <vec2> dir [, <float> strength] )\noptions:\n  RADIALBLUR_KERNELSIZE: Default 64 \n  RADIALBLUR_STRENGTH: Default 0.125\n  RADIALBLUR_TYPE: Default `vec4`\n  RADIALBLUR_SAMPLER_FNC(POS_UV): Default `texture2D(tex, POS_UV)`\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef RADIALBLUR_KERNELSIZE\n#define RADIALBLUR_KERNELSIZE 64\n#endif\n\n#ifndef RADIALBLUR_STRENGTH\n#define RADIALBLUR_STRENGTH .125\n#endif\n\n#ifndef RADIALBLUR_TYPE\n#define RADIALBLUR_TYPE vec4\n#endif\n\n#ifndef RADIALBLUR_SAMPLER_FNC\n#define RADIALBLUR_SAMPLER_FNC(POS_UV) texture2D(tex, POS_UV)\n#endif\n\n#ifndef FNC_RADIALBLUR\n#define FNC_RADIALBLUR\nRADIALBLUR_TYPE radialBlur(in sampler2D tex, in vec2 st, in vec2 dir, in float strength) {\n  RADIALBLUR_TYPE color = RADIALBLUR_TYPE(0.);\n  float f_samples = float(RADIALBLUR_KERNELSIZE);\n  float f_factor = 1./f_samples;\n  for (int i = 0; i < RADIALBLUR_KERNELSIZE; i += 2) {\n      color += RADIALBLUR_SAMPLER_FNC(st + float(i) * f_factor * dir * strength);\n      color += RADIALBLUR_SAMPLER_FNC(st + float(i+1) * f_factor * dir * strength);\n  }\n  return color * f_factor;\n}\n\nRADIALBLUR_TYPE radialBlur(in sampler2D tex, in vec2 st, in vec2 dir) {\n  return radialBlur(tex, st, dir, RADIALBLUR_STRENGTH);\n}\n#endif\n'},678:e=>{e.exports='/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: modulus of 289\nuse: mod289(<float|vec2|vec3|vec4> x)\nlicense: |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n#ifndef FNC_MOD289\n#define FNC_MOD289\nfloat mod289(in float x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec2 mod289(in vec2 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec3 mod289(in vec3 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec4 mod289(in vec4 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n#endif\n\n/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: modulus of 289\nuse: mod289(<float|vec2|vec3|vec4> x)\nlicense: |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n#ifndef FNC_MOD289\n#define FNC_MOD289\nfloat mod289(in float x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec2 mod289(in vec2 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec3 mod289(in vec3 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec4 mod289(in vec4 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n#endif\n\n\n/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: permute\nuse: permute(<float|vec2|vec3|vec4> x)\nlicense : |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n\n#ifndef FNC_PERMUTE\n#define FNC_PERMUTE\nfloat permute(in float x) {\n     return mod289(((x * 34.) + 1.)*x);\n}\n\nvec3 permute(in vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 permute(in vec4 x) {\n     return mod289(((x * 34.) + 1.)*x);\n}\n#endif\n\n/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: \nuse: taylorInvSqrt(<float|vec4> x)\nLicense : |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n\n#ifndef FNC_TAYLORINVSQRT\n#define FNC_TAYLORINVSQRT\nfloat taylorInvSqrt(in float r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 taylorInvSqrt(in vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n#endif\n/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: fade\nuse: fade(<vec2|vec3|vec4> t)\nlicense: |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n\n#ifndef FNC_FADE\n#define FNC_FADE\nfloat fade(in float t) {\n  return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n\nvec2 fade(in vec2 t) {\n  return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n\nvec3 fade(in vec3 t) {\n  return t * t * t * (t * (t * 6. - 15. ) + 10.);\n}\n\nvec4 fade(vec4 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n#endif\n\n\n/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: Classic Perlin Noise https://github.com/ashima/webgl-noise\nuse: cnoise(<vec2|vec3|vec4> pos)\nlicense: |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Copyright (C) 2011-2016 by Stefan Gustavson (Classic noise and others)\n    Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n  Neither the name of the GPUImage framework nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef FNC_CNOISE\n#define FNC_CNOISE\n\nfloat cnoise(in vec2 P) {\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod289(Pi); // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n\n    vec4 i = permute(permute(ix) + iy);\n\n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n    vec4 gy = abs(gx) - 0.5 ;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n\n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n\n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n}\n\nfloat cnoise(in vec3 P) {\n    vec3 Pi0 = floor(P); // Integer part for indexing\n    vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}\n\nfloat cnoise(in vec4 P) {\n    vec4 Pi0 = floor(P); // Integer part for indexing\n    vec4 Pi1 = Pi0 + 1.0; // Integer part + 1\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec4 Pf0 = fract(P); // Fractional part for interpolation\n    vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = vec4(Pi0.zzzz);\n    vec4 iz1 = vec4(Pi1.zzzz);\n    vec4 iw0 = vec4(Pi0.wwww);\n    vec4 iw1 = vec4(Pi1.wwww);\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 ixy00 = permute(ixy0 + iw0);\n    vec4 ixy01 = permute(ixy0 + iw1);\n    vec4 ixy10 = permute(ixy1 + iw0);\n    vec4 ixy11 = permute(ixy1 + iw1);\n\n    vec4 gx00 = ixy00 * (1.0 / 7.0);\n    vec4 gy00 = floor(gx00) * (1.0 / 7.0);\n    vec4 gz00 = floor(gy00) * (1.0 / 6.0);\n    gx00 = fract(gx00) - 0.5;\n    gy00 = fract(gy00) - 0.5;\n    gz00 = fract(gz00) - 0.5;\n    vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n    vec4 sw00 = step(gw00, vec4(0.0));\n    gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n    gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n    vec4 gx01 = ixy01 * (1.0 / 7.0);\n    vec4 gy01 = floor(gx01) * (1.0 / 7.0);\n    vec4 gz01 = floor(gy01) * (1.0 / 6.0);\n    gx01 = fract(gx01) - 0.5;\n    gy01 = fract(gy01) - 0.5;\n    gz01 = fract(gz01) - 0.5;\n    vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n    vec4 sw01 = step(gw01, vec4(0.0));\n    gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n    gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n    vec4 gx10 = ixy10 * (1.0 / 7.0);\n    vec4 gy10 = floor(gx10) * (1.0 / 7.0);\n    vec4 gz10 = floor(gy10) * (1.0 / 6.0);\n    gx10 = fract(gx10) - 0.5;\n    gy10 = fract(gy10) - 0.5;\n    gz10 = fract(gz10) - 0.5;\n    vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n    vec4 sw10 = step(gw10, vec4(0.0));\n    gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n    gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n    vec4 gx11 = ixy11 * (1.0 / 7.0);\n    vec4 gy11 = floor(gx11) * (1.0 / 7.0);\n    vec4 gz11 = floor(gy11) * (1.0 / 6.0);\n    gx11 = fract(gx11) - 0.5;\n    gy11 = fract(gy11) - 0.5;\n    gz11 = fract(gz11) - 0.5;\n    vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n    vec4 sw11 = step(gw11, vec4(0.0));\n    gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n    gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n    vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n    vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n    vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n    vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n    vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n    vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n    vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n    vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n    vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n    vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n    vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n    vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n    vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n    vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n    vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n    vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n    vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n    g0000 *= norm00.x;\n    g0100 *= norm00.y;\n    g1000 *= norm00.z;\n    g1100 *= norm00.w;\n\n    vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n    g0001 *= norm01.x;\n    g0101 *= norm01.y;\n    g1001 *= norm01.z;\n    g1101 *= norm01.w;\n\n    vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n    g0010 *= norm10.x;\n    g0110 *= norm10.y;\n    g1010 *= norm10.z;\n    g1110 *= norm10.w;\n\n    vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n    g0011 *= norm11.x;\n    g0111 *= norm11.y;\n    g1011 *= norm11.z;\n    g1111 *= norm11.w;\n\n    float n0000 = dot(g0000, Pf0);\n    float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n    float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n    float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n    float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n    float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n    float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n    float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n    float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n    float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n    float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n    float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n    float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n    float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n    float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n    float n1111 = dot(g1111, Pf1);\n\n    vec4 fade_xyzw = fade(Pf0);\n    vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n    vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n    vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n    vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n    float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n    return 2.2 * n_xyzw;\n}\n#endif\n'},4686:e=>{e.exports="/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: modulus of 289\nuse: mod289(<float|vec2|vec3|vec4> x)\nlicense: |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n#ifndef FNC_MOD289\n#define FNC_MOD289\nfloat mod289(in float x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec2 mod289(in vec2 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec3 mod289(in vec3 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec4 mod289(in vec4 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n#endif\n\n/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: modulus of 289\nuse: mod289(<float|vec2|vec3|vec4> x)\nlicense: |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n#ifndef FNC_MOD289\n#define FNC_MOD289\nfloat mod289(in float x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec2 mod289(in vec2 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec3 mod289(in vec3 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec4 mod289(in vec4 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n#endif\n\n\n/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: permute\nuse: permute(<float|vec2|vec3|vec4> x)\nlicense : |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n\n#ifndef FNC_PERMUTE\n#define FNC_PERMUTE\nfloat permute(in float x) {\n     return mod289(((x * 34.) + 1.)*x);\n}\n\nvec3 permute(in vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 permute(in vec4 x) {\n     return mod289(((x * 34.) + 1.)*x);\n}\n#endif\n\n/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: \nuse: taylorInvSqrt(<float|vec4> x)\nLicense : |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n\n#ifndef FNC_TAYLORINVSQRT\n#define FNC_TAYLORINVSQRT\nfloat taylorInvSqrt(in float r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 taylorInvSqrt(in vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n#endif\n/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: grad4, used for snoise(vec4 v)\nuse: grad4(<float> j, <vec4> ip)\nlicense: |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n#ifndef FNC_GRAD4\n#define FNC_GRAD4\nvec4 grad4(float j, vec4 ip) {\n    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n    vec4 p,s;\n\n    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n    s = vec4(lessThan(p, vec4(0.0)));\n    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n    return p;\n}\n#endif\n\n\n/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: Simplex Noise https://github.com/ashima/webgl-noise\nuse: snoise(<vec2|vec3|vec4> pos)\nlicense: |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Copyright (C) 2011-2016 by Stefan Gustavson (Classic noise and others)\n  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n  Neither the name of the GPUImage framework nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  \n*/\n\n#ifndef FNC_SNOISE\n#define FNC_SNOISE\nfloat snoise(in vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n\nfloat snoise(in vec3 v) {\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289(i);\n    vec4 p = permute( permute( permute(\n                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n            + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n            + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat snoise(in vec4 v) {\n    const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                        -0.447213595499958); // -1 + 4 * G4\n\n    // First corner\n    vec4 i  = floor(v + dot(v, vec4(.309016994374947451)) ); // (sqrt(5) - 1)/4\n    vec4 x0 = v -   i + dot(i, C.xxxx);\n\n    // Other corners\n\n    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n    vec4 i0;\n    vec3 isX = step( x0.yzw, x0.xxx );\n    vec3 isYZ = step( x0.zww, x0.yyz );\n    //  i0.x = dot( isX, vec3( 1.0 ) );\n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n    //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n\n    // i0 now contains the unique values 0,1,2,3 in each channel\n    vec4 i3 = clamp( i0, 0.0, 1.0 );\n    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n    //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n    //  x1 = x0 - i1  + 1.0 * C.xxxx\n    //  x2 = x0 - i2  + 2.0 * C.xxxx\n    //  x3 = x0 - i3  + 3.0 * C.xxxx\n    //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n    vec4 x1 = x0 - i1 + C.xxxx;\n    vec4 x2 = x0 - i2 + C.yyyy;\n    vec4 x3 = x0 - i3 + C.zzzz;\n    vec4 x4 = x0 + C.wwww;\n\n    // Permutations\n    i = mod289(i);\n    float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n    vec4 j1 = permute( permute( permute( permute (\n                i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n            + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n            + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n            + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n    // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n    vec4 p0 = grad4(j0,   ip);\n    vec4 p1 = grad4(j1.x, ip);\n    vec4 p2 = grad4(j1.y, ip);\n    vec4 p3 = grad4(j1.z, ip);\n    vec4 p4 = grad4(j1.w, ip);\n\n    // Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= taylorInvSqrt(dot(p4,p4));\n\n    // Mix contributions from the five corners\n    vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n    vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n    m0 = m0 * m0;\n    m1 = m1 * m1;\n    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\n\nvec3 snoise3( vec3 x ){\n    float s  = snoise(vec3( x ));\n    float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n    float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n    vec3 c = vec3( s , s1 , s2 );\n    return c;\n}\n\nvec3 snoise3( vec4 x ){\n    float s  = snoise(vec4( x ));\n    float s1 = snoise(vec4( x.y - 19.1 , x.z + 33.4 , x.x + 47.2, x.w ));\n    float s2 = snoise(vec4( x.z + 74.2 , x.x - 124.5 , x.y + 99.4, x.w ));\n    vec3 c = vec3( s , s1 , s2 );\n    return c;\n}\n\n#endif\n\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: Fractal Brownian Motion\nuse: fbm(<vec2> pos)\noptions:\n  FBM_OCTAVES: numbers of octaves. Default is 4.\n  FBM_NOISE_FNC(POS_UV): noise function to use Default 'snoise(POS_UV)' (simplex noise)\n  FBM_VALUE_INITIAL: initial value. Default is 0.\n  FBM_SCALE_SCALAR: scalar. Defualt is 2.\n  FBM_AMPLITUD_INITIAL: initial amplitud value. Default is 0.5\n  FBM_AMPLITUD_SCALAR: amplitud scalar. Default is 0.5\n*/\n\n#ifndef FBM_OCTAVES\n#define FBM_OCTAVES 4\n#endif\n\n#ifndef FBM_NOISE_FNC\n#define FBM_NOISE_FNC(POS_UV) snoise(POS_UV)\n#endif\n\n#ifndef FBM_VALUE_INITIAL\n#define FBM_VALUE_INITIAL 0.0\n#endif\n\n#ifndef FBM_SCALE_SCALAR\n#define FBM_SCALE_SCALAR 2.0\n#endif\n\n#ifndef FBM_AMPLITUD_INITIAL\n#define FBM_AMPLITUD_INITIAL 0.5\n#endif\n\n#ifndef FBM_AMPLITUD_SCALAR\n#define FBM_AMPLITUD_SCALAR 0.5\n#endif\n\n#ifndef FNC_FBM\n#define FNC_FBM\nfloat fbm(in vec2 st) {\n    // Initial values\n    float value = FBM_VALUE_INITIAL;\n    float amplitud = FBM_AMPLITUD_INITIAL;\n\n    // Loop of octaves\n    for (int i = 0; i < FBM_OCTAVES; i++) {\n        value += amplitud * FBM_NOISE_FNC(st);\n        st *= FBM_SCALE_SCALAR;\n        amplitud *= FBM_AMPLITUD_SCALAR;\n    }\n    return value;\n}\n\nfloat fbm(in vec3 pos) {\n    // Initial values\n    float value = FBM_VALUE_INITIAL;\n    float amplitud = FBM_AMPLITUD_INITIAL;\n\n    // Loop of octaves\n    for (int i = 0; i < FBM_OCTAVES; i++) {\n        value += amplitud * FBM_NOISE_FNC(pos);\n        pos *= FBM_SCALE_SCALAR;\n        amplitud *= FBM_AMPLITUD_SCALAR;\n    }\n    return value;\n}\n#endif\n"},4401:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: pass a value and get some random normalize value between 0 and 1\nuse: float random[2|3](<float|vec2|vec3> value)\n*/\n\n#ifndef FNC_RANDOM\n#define FNC_RANDOM\nfloat random(in float x) {\n  return fract(sin(x) * 43758.5453);\n}\n\nfloat random(in vec2 st) {\n  return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat random(in vec3 pos) {\n  return fract(sin(dot(pos.xyz, vec3(70.9898, 78.233, 32.4355))) * 43758.5453123);\n}\n\nfloat random(in vec4 pos) {\n    float dot_product = dot(pos, vec4(12.9898,78.233,45.164,94.673));\n    return fract(sin(dot_product) * 43758.5453);\n}\n\n// Hash function from https://www.shadertoy.com/view/4djSRW\n#ifndef RANDOM_SCALE3\n#define RANDOM_SCALE3 vec3(.1031, .1030, .0973)\n#endif\n\n#ifndef FANDOM_SCALE4\n#define FANDOM_SCALE4 vec4(1031, .1030, .0973, .1099)\n#endif\nvec2 random2(float p) {\n    vec3 p3 = fract(vec3(p) * RANDOM_SCALE3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 random2(in vec2 st) {\n    const vec2 k = vec2(.3183099, .3678794);\n    st = st * k + k.yx;\n    return -1. + 2. * fract(16. * k * fract(st.x * st.y * (st.x + st.y)));\n}\n\nvec2 random2(vec3 p3) {\n    p3 = fract(p3 * RANDOM_SCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 random3(float p) {\n    vec3 p3 = fract(vec3(p) * RANDOM_SCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec3 random3(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * RANDOM_SCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 random3(in vec3 p) {\n    p = vec3( dot(p, vec3(127.1, 311.7, 74.7)),\n            dot(p, vec3(269.5, 183.3, 246.1)),\n            dot(p, vec3(113.5, 271.9, 124.6)));\n    return -1. + 2. * fract(sin(p) * 43758.5453123);\n}\n\nvec4 random4(float p) {\n    vec4 p4 = fract(vec4(p) * FANDOM_SCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);   \n}\n\nvec4 random4(vec2 p) {\n    vec4 p4 = fract(vec4(p.xyxy) * FANDOM_SCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 random4(vec3 p) {\n    vec4 p4 = fract(vec4(p.xyzx)  * FANDOM_SCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 random4(vec4 p4) {\n    p4 = fract(p4  * FANDOM_SCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n#endif\n\n\n/*\nauthor: Inigo Quilez\ndescription: returns 2D/3D value noise in the first channel and in the rest the derivatives. For more details read this nice article http://www.iquilezles.org/www/articles/gradientnoise/gradientnoise.htm\nuse: noised(<vec2|vec3> space)\noptions:\n  NOISED_QUINTIC_INTERPOLATION: Quintic interpolation on/off. Default is off.\nlicense: |\n  Copyright © 2017 Inigo Quilez\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_NOISED\n#define FNC_NOISED\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised (in vec2 p) {\n  // grid\n  vec2 i = floor( p );\n  vec2 f = fract( p );\n\n#ifdef NOISED_QUINTIC_INTERPOLATION\n  // quintic interpolation\n  vec2 u = f * f * f * (f * (f * 6. - 15.) + 10.);\n  vec2 du = 30. * f * f * (f * (f - 2.) + 1.);\n#else\n  // cubic interpolation\n  vec2 u = f * f * (3. - 2. * f);\n  vec2 du = 6. * f * (1. - f);\n#endif\n\n  vec2 ga = random2(i + vec2(0., 0.));\n  vec2 gb = random2(i + vec2(1., 0.));\n  vec2 gc = random2(i + vec2(0., 1.));\n  vec2 gd = random2(i + vec2(1., 1.));\n\n  float va = dot(ga, f - vec2(0., 0.));\n  float vb = dot(gb, f - vec2(1., 0.));\n  float vc = dot(gc, f - vec2(0., 1.));\n  float vd = dot(gd, f - vec2(1., 1.));\n\n  return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n               ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n               du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n// returns 3D value noise (in .x)  and its derivatives (in .yzw)\n// https://www.shadertoy.com/view/4dffRH\nvec4 noised (in vec3 pos) {\n  // grid\n  vec3 p = floor(pos);\n  vec3 w = fract(pos);\n\n#ifdef NOISED_QUINTIC_INTERPOLATION\n  // quintic interpolant\n  vec3 u = w * w * w * ( w * (w * 6. - 15.) + 10. );\n  vec3 du = 30.0 * w * w * ( w * (w - 2.) + 1.);\n#else\n  // cubic interpolant\n  vec3 u = w * w * (3. - 2. * w);\n  vec3 du = 6. * w * (1. - w);\n#endif\n\n  // gradients\n  vec3 ga = random3(p + vec3(0., 0., 0.));\n  vec3 gb = random3(p + vec3(1., 0., 0.));\n  vec3 gc = random3(p + vec3(0., 1., 0.));\n  vec3 gd = random3(p + vec3(1., 1., 0.));\n  vec3 ge = random3(p + vec3(0., 0., 1.));\n  vec3 gf = random3(p + vec3(1., 0., 1.));\n  vec3 gg = random3(p + vec3(0., 1., 1.));\n  vec3 gh = random3(p + vec3(1., 1., 1.));\n\n  // projections\n  float va = dot(ga, w - vec3(0., 0., 0.));\n  float vb = dot(gb, w - vec3(1., 0., 0.));\n  float vc = dot(gc, w - vec3(0., 1., 0.));\n  float vd = dot(gd, w - vec3(1., 1., 0.));\n  float ve = dot(ge, w - vec3(0., 0., 1.));\n  float vf = dot(gf, w - vec3(1., 0., 1.));\n  float vg = dot(gg, w - vec3(0., 1., 1.));\n  float vh = dot(gh, w - vec3(1., 1., 1.));\n\n  // interpolations\n  return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\n               ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\n               du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n}\n\n#endif\n'},3700:e=>{e.exports='/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: modulus of 289\nuse: mod289(<float|vec2|vec3|vec4> x)\nlicense: |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n#ifndef FNC_MOD289\n#define FNC_MOD289\nfloat mod289(in float x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec2 mod289(in vec2 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec3 mod289(in vec3 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec4 mod289(in vec4 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n#endif\n\n/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: modulus of 289\nuse: mod289(<float|vec2|vec3|vec4> x)\nlicense: |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n#ifndef FNC_MOD289\n#define FNC_MOD289\nfloat mod289(in float x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec2 mod289(in vec2 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec3 mod289(in vec3 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec4 mod289(in vec4 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n#endif\n\n\n/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: permute\nuse: permute(<float|vec2|vec3|vec4> x)\nlicense : |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n\n#ifndef FNC_PERMUTE\n#define FNC_PERMUTE\nfloat permute(in float x) {\n     return mod289(((x * 34.) + 1.)*x);\n}\n\nvec3 permute(in vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 permute(in vec4 x) {\n     return mod289(((x * 34.) + 1.)*x);\n}\n#endif\n\n/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: \nuse: taylorInvSqrt(<float|vec4> x)\nLicense : |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n\n#ifndef FNC_TAYLORINVSQRT\n#define FNC_TAYLORINVSQRT\nfloat taylorInvSqrt(in float r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 taylorInvSqrt(in vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n#endif\n/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: fade\nuse: fade(<vec2|vec3|vec4> t)\nlicense: |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n\n#ifndef FNC_FADE\n#define FNC_FADE\nfloat fade(in float t) {\n  return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n\nvec2 fade(in vec2 t) {\n  return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n\nvec3 fade(in vec3 t) {\n  return t * t * t * (t * (t * 6. - 15. ) + 10.);\n}\n\nvec4 fade(vec4 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n#endif\n\n\n/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: Classic Perlin Noise with periodic variant https://github.com/ashima/webgl-noise\nuse: pnoise(<vec2|vec3|vec4> pos, <vec2|vec3|vec4> periodic)\nlicense: |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Copyright (C) 2011-2016 by Stefan Gustavson (Classic noise and others)\n    Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n  Neither the name of the GPUImage framework nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  \n*/\n\n#ifndef FNC_PNOISE\n#define FNC_PNOISE\n// Classic Perlin noise, periodic variant\nfloat pnoise(in vec2 P, in vec2 rep) {\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n    Pi = mod289(Pi);        // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n\n    vec4 i = permute(permute(ix) + iy);\n\n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n    vec4 gy = abs(gx) - 0.5 ;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n\n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n\n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n}\n\nfloat pnoise(in vec3 P, in vec3 rep) {\n    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}\n\nfloat pnoise(in vec4 P, in vec4 rep) {\n    vec4 Pi0 = mod(floor(P), rep); // Integer part modulo rep\n    vec4 Pi1 = mod(Pi0 + 1.0, rep); // Integer part + 1 mod rep\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec4 Pf0 = fract(P); // Fractional part for interpolation\n    vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = vec4(Pi0.zzzz);\n    vec4 iz1 = vec4(Pi1.zzzz);\n    vec4 iw0 = vec4(Pi0.wwww);\n    vec4 iw1 = vec4(Pi1.wwww);\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 ixy00 = permute(ixy0 + iw0);\n    vec4 ixy01 = permute(ixy0 + iw1);\n    vec4 ixy10 = permute(ixy1 + iw0);\n    vec4 ixy11 = permute(ixy1 + iw1);\n\n    vec4 gx00 = ixy00 * (1.0 / 7.0);\n    vec4 gy00 = floor(gx00) * (1.0 / 7.0);\n    vec4 gz00 = floor(gy00) * (1.0 / 6.0);\n    gx00 = fract(gx00) - 0.5;\n    gy00 = fract(gy00) - 0.5;\n    gz00 = fract(gz00) - 0.5;\n    vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n    vec4 sw00 = step(gw00, vec4(0.0));\n    gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n    gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n    vec4 gx01 = ixy01 * (1.0 / 7.0);\n    vec4 gy01 = floor(gx01) * (1.0 / 7.0);\n    vec4 gz01 = floor(gy01) * (1.0 / 6.0);\n    gx01 = fract(gx01) - 0.5;\n    gy01 = fract(gy01) - 0.5;\n    gz01 = fract(gz01) - 0.5;\n    vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n    vec4 sw01 = step(gw01, vec4(0.0));\n    gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n    gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n    vec4 gx10 = ixy10 * (1.0 / 7.0);\n    vec4 gy10 = floor(gx10) * (1.0 / 7.0);\n    vec4 gz10 = floor(gy10) * (1.0 / 6.0);\n    gx10 = fract(gx10) - 0.5;\n    gy10 = fract(gy10) - 0.5;\n    gz10 = fract(gz10) - 0.5;\n    vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n    vec4 sw10 = step(gw10, vec4(0.0));\n    gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n    gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n    vec4 gx11 = ixy11 * (1.0 / 7.0);\n    vec4 gy11 = floor(gx11) * (1.0 / 7.0);\n    vec4 gz11 = floor(gy11) * (1.0 / 6.0);\n    gx11 = fract(gx11) - 0.5;\n    gy11 = fract(gy11) - 0.5;\n    gz11 = fract(gz11) - 0.5;\n    vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n    vec4 sw11 = step(gw11, vec4(0.0));\n    gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n    gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n    vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n    vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n    vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n    vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n    vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n    vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n    vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n    vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n    vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n    vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n    vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n    vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n    vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n    vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n    vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n    vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n    vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n    g0000 *= norm00.x;\n    g0100 *= norm00.y;\n    g1000 *= norm00.z;\n    g1100 *= norm00.w;\n\n    vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n    g0001 *= norm01.x;\n    g0101 *= norm01.y;\n    g1001 *= norm01.z;\n    g1101 *= norm01.w;\n\n    vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n    g0010 *= norm10.x;\n    g0110 *= norm10.y;\n    g1010 *= norm10.z;\n    g1110 *= norm10.w;\n\n    vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n    g0011 *= norm11.x;\n    g0111 *= norm11.y;\n    g1011 *= norm11.z;\n    g1111 *= norm11.w;\n\n    float n0000 = dot(g0000, Pf0);\n    float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n    float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n    float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n    float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n    float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n    float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n    float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n    float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n    float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n    float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n    float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n    float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n    float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n    float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n    float n1111 = dot(g1111, Pf1);\n\n    vec4 fade_xyzw = fade(Pf0);\n    vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n    vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n    vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n    vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n    float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n    return 2.2 * n_xyzw;\n}\n#endif\n'},6518:e=>{e.exports="/*\nauthor: Patricio Gonzalez Vivo\ndescription: pass a value and get some random normalize value between 0 and 1\nuse: float random[2|3](<float|vec2|vec3> value)\n*/\n\n#ifndef FNC_RANDOM\n#define FNC_RANDOM\nfloat random(in float x) {\n  return fract(sin(x) * 43758.5453);\n}\n\nfloat random(in vec2 st) {\n  return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat random(in vec3 pos) {\n  return fract(sin(dot(pos.xyz, vec3(70.9898, 78.233, 32.4355))) * 43758.5453123);\n}\n\nfloat random(in vec4 pos) {\n    float dot_product = dot(pos, vec4(12.9898,78.233,45.164,94.673));\n    return fract(sin(dot_product) * 43758.5453);\n}\n\n// Hash function from https://www.shadertoy.com/view/4djSRW\n#ifndef RANDOM_SCALE3\n#define RANDOM_SCALE3 vec3(.1031, .1030, .0973)\n#endif\n\n#ifndef FANDOM_SCALE4\n#define FANDOM_SCALE4 vec4(1031, .1030, .0973, .1099)\n#endif\nvec2 random2(float p) {\n    vec3 p3 = fract(vec3(p) * RANDOM_SCALE3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 random2(in vec2 st) {\n    const vec2 k = vec2(.3183099, .3678794);\n    st = st * k + k.yx;\n    return -1. + 2. * fract(16. * k * fract(st.x * st.y * (st.x + st.y)));\n}\n\nvec2 random2(vec3 p3) {\n    p3 = fract(p3 * RANDOM_SCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 random3(float p) {\n    vec3 p3 = fract(vec3(p) * RANDOM_SCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec3 random3(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * RANDOM_SCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 random3(in vec3 p) {\n    p = vec3( dot(p, vec3(127.1, 311.7, 74.7)),\n            dot(p, vec3(269.5, 183.3, 246.1)),\n            dot(p, vec3(113.5, 271.9, 124.6)));\n    return -1. + 2. * fract(sin(p) * 43758.5453123);\n}\n\nvec4 random4(float p) {\n    vec4 p4 = fract(vec4(p) * FANDOM_SCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);   \n}\n\nvec4 random4(vec2 p) {\n    vec4 p4 = fract(vec4(p.xyxy) * FANDOM_SCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 random4(vec3 p) {\n    vec4 p4 = fract(vec4(p.xyzx)  * FANDOM_SCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 random4(vec4 p4) {\n    p4 = fract(p4  * FANDOM_SCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n#endif\n"},6998:e=>{e.exports='/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: modulus of 289\nuse: mod289(<float|vec2|vec3|vec4> x)\nlicense: |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n#ifndef FNC_MOD289\n#define FNC_MOD289\nfloat mod289(in float x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec2 mod289(in vec2 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec3 mod289(in vec3 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec4 mod289(in vec4 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n#endif\n\n/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: modulus of 289\nuse: mod289(<float|vec2|vec3|vec4> x)\nlicense: |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n#ifndef FNC_MOD289\n#define FNC_MOD289\nfloat mod289(in float x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec2 mod289(in vec2 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec3 mod289(in vec3 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec4 mod289(in vec4 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n#endif\n\n\n/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: permute\nuse: permute(<float|vec2|vec3|vec4> x)\nlicense : |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n\n#ifndef FNC_PERMUTE\n#define FNC_PERMUTE\nfloat permute(in float x) {\n     return mod289(((x * 34.) + 1.)*x);\n}\n\nvec3 permute(in vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 permute(in vec4 x) {\n     return mod289(((x * 34.) + 1.)*x);\n}\n#endif\n\n/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: \nuse: taylorInvSqrt(<float|vec4> x)\nLicense : |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n\n#ifndef FNC_TAYLORINVSQRT\n#define FNC_TAYLORINVSQRT\nfloat taylorInvSqrt(in float r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 taylorInvSqrt(in vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n#endif\n/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: grad4, used for snoise(vec4 v)\nuse: grad4(<float> j, <vec4> ip)\nlicense: |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n#ifndef FNC_GRAD4\n#define FNC_GRAD4\nvec4 grad4(float j, vec4 ip) {\n    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n    vec4 p,s;\n\n    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n    s = vec4(lessThan(p, vec4(0.0)));\n    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n    return p;\n}\n#endif\n\n\n/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: Simplex Noise https://github.com/ashima/webgl-noise\nuse: snoise(<vec2|vec3|vec4> pos)\nlicense: |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Copyright (C) 2011-2016 by Stefan Gustavson (Classic noise and others)\n  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n  Neither the name of the GPUImage framework nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  \n*/\n\n#ifndef FNC_SNOISE\n#define FNC_SNOISE\nfloat snoise(in vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n\nfloat snoise(in vec3 v) {\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289(i);\n    vec4 p = permute( permute( permute(\n                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n            + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n            + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat snoise(in vec4 v) {\n    const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                        -0.447213595499958); // -1 + 4 * G4\n\n    // First corner\n    vec4 i  = floor(v + dot(v, vec4(.309016994374947451)) ); // (sqrt(5) - 1)/4\n    vec4 x0 = v -   i + dot(i, C.xxxx);\n\n    // Other corners\n\n    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n    vec4 i0;\n    vec3 isX = step( x0.yzw, x0.xxx );\n    vec3 isYZ = step( x0.zww, x0.yyz );\n    //  i0.x = dot( isX, vec3( 1.0 ) );\n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n    //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n\n    // i0 now contains the unique values 0,1,2,3 in each channel\n    vec4 i3 = clamp( i0, 0.0, 1.0 );\n    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n    //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n    //  x1 = x0 - i1  + 1.0 * C.xxxx\n    //  x2 = x0 - i2  + 2.0 * C.xxxx\n    //  x3 = x0 - i3  + 3.0 * C.xxxx\n    //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n    vec4 x1 = x0 - i1 + C.xxxx;\n    vec4 x2 = x0 - i2 + C.yyyy;\n    vec4 x3 = x0 - i3 + C.zzzz;\n    vec4 x4 = x0 + C.wwww;\n\n    // Permutations\n    i = mod289(i);\n    float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n    vec4 j1 = permute( permute( permute( permute (\n                i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n            + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n            + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n            + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n    // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n    vec4 p0 = grad4(j0,   ip);\n    vec4 p1 = grad4(j1.x, ip);\n    vec4 p2 = grad4(j1.y, ip);\n    vec4 p3 = grad4(j1.z, ip);\n    vec4 p4 = grad4(j1.w, ip);\n\n    // Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= taylorInvSqrt(dot(p4,p4));\n\n    // Mix contributions from the five corners\n    vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n    vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n    m0 = m0 * m0;\n    m1 = m1 * m1;\n    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\n\nvec3 snoise3( vec3 x ){\n    float s  = snoise(vec3( x ));\n    float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n    float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n    vec3 c = vec3( s , s1 , s2 );\n    return c;\n}\n\nvec3 snoise3( vec4 x ){\n    float s  = snoise(vec4( x ));\n    float s1 = snoise(vec4( x.y - 19.1 , x.z + 33.4 , x.x + 47.2, x.w ));\n    float s2 = snoise(vec4( x.z + 74.2 , x.x - 124.5 , x.y + 99.4, x.w ));\n    vec3 c = vec3( s , s1 , s2 );\n    return c;\n}\n\n#endif\n'},2640:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: absolute of integer\nuse: absi(<int> value)\nlicense: |\n  Copyright (c) 2021 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef FNC_ABSI\n#define FNC_ABSI\n#define absi(x)     ( (x < 0)? x * -1 : x )\n#endif'},8236:e=>{e.exports='/*\nauthor: Brad Larson\ndescription: adaptive threshold from https://github.com/BradLarson/GPUImage/blob/master/framework/Source/GPUImageAdaptiveThresholdFilter.m\nuse: adaptiveThreshold(<float> value, <float> blur_value, <float> bias)\nlicense: |\n  Copyright (c) 2012, Brad Larson, Ben Cochran, Hugues Lismonde, Keitaroh Kobayashi, Alaric Cole, Matthew Clark, Jacob Gundersen, Chris Williams.\n  All rights reserved.\n  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n  Neither the name of the GPUImage framework nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef FNC_ADAPTIVETHRESHOLD\n#define FNC_ADAPTIVETHRESHOLD\nfloat adaptiveThreshold(in float value, in float blur_value, in float bias) {\n    return step(blur_value + bias, value);\n}\n\nfloat adaptiveThreshold(in float value, in float blur_value) {\n    return step(blur_value - 0.05, value);\n}\n#endif\n'},6951:e=>{e.exports="#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef ONE_OVER_PI\n#define ONE_OVER_PI 0.31830988618\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n#ifndef GOLDEN_RATIO\n#define GOLDEN_RATIO 1.6180339887\n#endif\n#ifndef GOLDEN_RATIO_CONJUGATE \n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#endif\n#ifndef GOLDEN_ANGLE // (3.-sqrt(5.0))*PI radians\n#define GOLDEN_ANGLE 2.39996323\n#endif\n"},7877:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: decimate a value with an specific presicion \nuse: decimation(<float|vec2|vec3|vec4> value, <float|vec2|vec3|vec4> presicion)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef FNC_DECIMATION\n#define FNC_DECIMATION\n#define decimation(value, presicion) (floor(value * presicion)/presicion)\n#endif'},1496:e=>{e.exports="/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: fade\nuse: fade(<vec2|vec3|vec4> t)\nlicense: |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n\n#ifndef FNC_FADE\n#define FNC_FADE\nfloat fade(in float t) {\n  return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n\nvec2 fade(in vec2 t) {\n  return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n\nvec3 fade(in vec3 t) {\n  return t * t * t * (t * (t * 6. - 15. ) + 10.);\n}\n\nvec4 fade(vec4 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n#endif\n"},2381:e=>{e.exports="/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: grad4, used for snoise(vec4 v)\nuse: grad4(<float> j, <vec4> ip)\nlicense: |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n#ifndef FNC_GRAD4\n#define FNC_GRAD4\nvec4 grad4(float j, vec4 ip) {\n    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n    vec4 p,s;\n\n    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n    s = vec4(lessThan(p, vec4(0.0)));\n    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n    return p;\n}\n#endif\n"},1056:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: Squared length\nuse: lengthSq(<vec2|float2> st)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n\n*/\n\n#ifndef FNC_LENGTHSQ\n#define FNC_LENGTHSQ\nfloat lengthSq(in vec2 st) {\n    return dot(st, st);\n}\n\nfloat lengthSq(in vec3 pos) {\n    return dot(pos, pos);\n}\n#endif\n'},1578:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: clamp a value between 0 and 1\nuse: saturation(<float|vec2|vec3|vec4> value)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef FNC_SATURATE\n#define FNC_SATURATE\n// #define saturate(x) clamp(x, 0.0, 1.0)\nfloat saturate( float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec2 saturate( vec2 x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec3 saturate( vec3 x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec4 saturate( vec4 x) {\n    return clamp(x, 0.0, 1.0);\n}\n#endif\n\n/*\nauthor: Johan Ismael\ndescription: Map a value between one range to another.\nuse: map(<float|vec2|vec3|vec4> value, <float|vec2|vec3|vec4> inMin, <float|vec2|vec3|vec4> inMax, <float|vec2|vec3|vec4> outMin, <float|vec2|vec3|vec4> outMax)\nlicense: |\n  Copyright (c) 2017 Johan Ismael.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef FNC_MAP\n#define FNC_MAP\n\nfloat map( float value, float inMin, float inMax ) {\n    return saturate( (value-inMin)/(inMax-inMin));\n}\n\nvec2 map( vec2 value, vec2 inMin, vec2 inMax ) {\n    return saturate( (value-inMin)/(inMax-inMin));\n}\n\nvec3 map( vec3 value, vec3 inMin, vec3 inMax ) {\n    return saturate( (value-inMin)/(inMax-inMin));\n}\n\nvec4 map( vec4 value, vec4 inMin, vec4 inMax ) {\n    return saturate( (value-inMin)/(inMax-inMin));\n}\n\nfloat map(in float value, in float inMin, in float inMax, in float outMin, in float outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\nvec2 map(in vec2 value, in vec2 inMin, in vec2 inMax, in vec2 outMin, in vec2 outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\nvec3 map(in vec3 value, in vec3 inMin, in vec3 inMax, in vec3 outMin, in vec3 outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\nvec4 map(in vec4 value, in vec4 inMin, in vec4 inMax, in vec4 outMin, in vec4 outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\n#endif\n'},4688:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: extend GLSL Max function to add more arguments\nuse: \n  - max(<float> A, <float> B, <float> C[, <float> D])\n  - max(<vec2|vec3|vec4> A)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef FNC_MAX\n#define FNC_MAX\nfloat max(in float a, in float b, in float c) {\n  return max(a, max(b, c));\n}\n\nfloat max(in float a, in float b, in float c, in float d) {\n  return max(max(a, b), max(c, d));\n}\n\nfloat max(const vec2 v) {\n    return max(v.x, v.y);\n}\n\nfloat max(const vec3 v) {\n    return max(v.x, v.y, v.z);\n}\n\nfloat max(const vec4 v) {\n    return max(v.x, v.y, v.z, v.w);\n}\n#endif\n'},254:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: extend GLSL min function to add more arguments\nuse: \n  - min(<float> A, <float> B, <float> C[, <float> D])\n  - min(<vec2|vec3|vec4> A)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n\n*/\n\n#ifndef FNC_MIN\n#define FNC_MIN\nfloat min(in float a, in float b, in float c) {\n  return min(a, min(b, c));\n}\n\nfloat min(in float a, in float b, in float c, in float d) {\n  return min(min(a,b), min(c, d));\n}\n\nfloat min(const vec2 v) {\n    return min(v.x, v.y);\n}\n\nfloat min(const vec3 v) {\n    return min(v.x, v.y, v.z);\n}\n\nfloat min(const vec4 v) {\n    return min(v.x, v.y, v.z, v.w);\n}\n#endif\n'},5824:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: expands mix to linearly mix more than two values\nuse: mix(<float|vec2|vec3|vec4> a, <float|vec2|vec3|vec4> b, <float|vec2|vec3|vec4> c [, <float|vec2|vec3|vec4> d], <float> pct)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef FNC_MIX\n#define FNC_MIX\nfloat mix(float a , float b, float c, float pct) {\n     return mix(\n         mix(a, b, 2. * pct),\n         mix(b, c, 2. * (max(pct, .5) - .5)),\n         step(.5, pct)\n     );\n}\n\nvec2 mix(vec2 a , vec2 b, vec2 c, float pct) {\n     return mix(\n         mix(a, b, 2. * pct),\n         mix(b, c, 2. * (max(pct, .5) - .5)),\n         step(.5, pct)\n     );\n}\n\nvec2 mix(vec2 a , vec2 b, vec2 c, vec2 pct) {\n     return mix(\n         mix(a, b, 2. * pct),\n         mix(b, c, 2. * (max(pct, .5) - .5)),\n         step(.5, pct)\n     );\n}\n\nvec3 mix(vec3 a , vec3 b, vec3 c, float pct) {\n     return mix(\n         mix(a, b, 2. * pct),\n         mix(b, c, 2. * (max(pct, .5) - .5)),\n         step(.5, pct)\n     );\n}\n\nvec3 mix(vec3 a , vec3 b, vec3 c, vec3 pct) {\n     return mix(\n         mix(a, b, 2. * pct),\n         mix(b, c, 2. * (max(pct, .5) - .5)),\n         step(.5, pct)\n     );\n}\n\nvec4 mix(vec4 a , vec4 b, vec4 c, float pct) {\n     return mix(\n         mix(a, b, 2. * pct),\n         mix(b, c, 2. * (max(pct, .5) - .5)),\n         step(.5, pct)\n     );\n}\n\nvec4 mix(vec4 a , vec4 b, vec4 c, vec4 pct) {\n     return mix(\n         mix(a, b, 2. * pct),\n         mix(b, c, 2. * (max(pct, .5) - .5)),\n         step(.5, pct)\n     );\n}\n\nfloat mix(in float a , in float b, in float c, in float d, in float pct) {\n     return mix(\n         mix(a, b, 3. * pct),\n         mix(b,\n             mix( c,\n                  d,\n                  3. * (max(pct, .66) - .66)),\n             3. * (clamp(pct, .33, .66) - .33)\n         ),\n         step(.33, pct)\n     );\n}\n\nvec2 mix(in vec2 a , in vec2 b, in vec2 c, in vec2 d, in float pct) {\n     return mix(\n         mix(a, b, 3. * pct),\n         mix(b,\n             mix( c,\n                  d,\n                  3. * (max(pct, .66) - .66)),\n             3. * (clamp(pct, .33, .66) - .33)\n         ),\n         step(.33, pct)\n     );\n}\n\nvec2 mix(in vec2 a , in vec2 b, in vec2 c, in vec2 d, in vec2 pct) {\n     return mix(\n         mix(a, b, 3. * pct),\n         mix(b,\n             mix( c,\n                  d,\n                  3. * (max(pct, .66) - .66)),\n             3. * (clamp(pct, .33, .66) - .33)\n         ),\n         step(.33, pct)\n     );\n}\n\nvec3 mix(in vec3 a , in vec3 b, in vec3 c, in vec3 d, in float pct) {\n     return mix(\n         mix(a, b, 3. * pct),\n         mix(b,\n             mix( c,\n                  d,\n                  3. * (max(pct, .66) - .66)),\n             3. * (clamp(pct, .33, .66) - .33)\n         ),\n         step(.33, pct)\n     );\n}\n\nvec3 mix(in vec3 a , in vec3 b, in vec3 c, in vec3 d, in vec3 pct) {\n     return mix(\n         mix(a, b, 3. * pct),\n         mix(b,\n             mix( c,\n                  d,\n                  3. * (max(pct, .66) - .66)),\n             3. * (clamp(pct, .33, .66) - .33)\n         ),\n         step(.33, pct)\n     );\n}\n\nvec4 mix(in vec4 a , in vec4 b, in vec4 c, in vec4 d, in float pct) {\n     return mix(\n         mix(a, b, 3. * pct),\n         mix(b,\n             mix( c,\n                  d,\n                  3. * (max(pct, .66) - .66)),\n             3. * (clamp(pct, .33, .66) - .33)\n         ),\n         step(.33, pct)\n     );\n}\n\nvec4 mix(in vec4 a , in vec4 b, in vec4 c, in vec4 d, in vec4 pct) {\n     return mix(\n         mix(a, b, 3. * pct),\n         mix(b,\n             mix( c,\n                  d,\n                  3. * (max(pct, .66) - .66)),\n             3. * (clamp(pct, .33, .66) - .33)\n         ),\n         step(.33, pct)\n     );\n}\n#endif\n'},7802:e=>{e.exports="/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: modulus of 289\nuse: mod289(<float|vec2|vec3|vec4> x)\nlicense: |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n#ifndef FNC_MOD289\n#define FNC_MOD289\nfloat mod289(in float x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec2 mod289(in vec2 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec3 mod289(in vec3 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec4 mod289(in vec4 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n#endif\n"},1:e=>{e.exports="/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: modulus of 289\nuse: mod289(<float|vec2|vec3|vec4> x)\nlicense: |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n#ifndef FNC_MOD289\n#define FNC_MOD289\nfloat mod289(in float x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec2 mod289(in vec2 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec3 mod289(in vec3 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec4 mod289(in vec4 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\n#endif\n\n\n/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: permute\nuse: permute(<float|vec2|vec3|vec4> x)\nlicense : |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n\n#ifndef FNC_PERMUTE\n#define FNC_PERMUTE\nfloat permute(in float x) {\n     return mod289(((x * 34.) + 1.)*x);\n}\n\nvec3 permute(in vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 permute(in vec4 x) {\n     return mod289(((x * 34.) + 1.)*x);\n}\n#endif\n"},5661:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: power of 2\nuse: pow2(<float|vec2|vec3|vec4> x)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef FNC_POW2\n#define FNC_POW2\nfloat pow2(in float x) {\n  return x * x;\n}\n\nvec2 pow2(in vec2 x) {\n  return x * x;\n}\n\nvec3 pow2(in vec3 x) {\n  return x * x;\n}\n\nvec4 pow2(in vec4 x) {\n  return x * x;\n}\n#endif\n'},1759:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: power of 3\nuse: pow3(<float|vec2|vec3|vec4> x)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef FNC_POW3\n#define FNC_POW3\nfloat pow3(in float x) {\n  return x * x * x;\n}\n\nvec2 pow3(in vec2 x) {\n  return x * x * x;\n}\n\nvec3 pow3(in vec3 x) {\n  return x * x * x;\n}\n\nvec4 pow3(in vec4 x) {\n  return x * x * x;\n}\n#endif\n'},8029:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: power of 5\nuse: pow5(<float|vec2|vec3|vec4> x)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef FNC_POW5\n#define FNC_POW5\nfloat pow5(in float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nvec2 pow5(in vec2 x) {\n    vec2 x2 = x * x;\n    return x2 * x2 * x;\n}\n\nvec3 pow5(in vec3 x) {\n    vec3 x2 = x * x;\n    return x2 * x2 * x;\n}\n\nvec4 pow5(in vec4 x) {\n    vec4 x2 = x * x;\n    return x2 * x2 * x;\n}\n#endif\n'},2257:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: power of 7\nuse: pow7(<float|vec2|vec3|vec4> x)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef FNC_POW2\n#define FNC_POW2\nfloat pow7(in float x) {\n  return x * x * x * x * x * x * x;\n}\n\nvec2 pow7(in vec2 x) {\n  return x * x * x * x * x * x * x;\n}\n\nvec3 pow7(in vec3 x) {\n  return x * x * x * x * x * x * x;\n}\n\nvec4 pow7(in vec4 x) {\n  return x * x * x * x * x * x * x;\n}\n#endif\n'},6398:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: fast approximation to pow()\nuse: powFast(<float> x, <float> exp)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef FNC_POWFAST\n#define FNC_POWFAST\n\nfloat powFast(float a, float b) {\n  return a / ((1. - b) * a + b);\n}\n\n#endif'},2471:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: returns a 2x2 rotation matrix\nuse: rotate2d(<float> radians)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n\n*/\n\n#ifndef FNC_ROTATE2D\n#define FNC_ROTATE2D\nmat2 rotate2d(in float radians){\n    float c = cos(radians);\n    float s = sin(radians);\n    return mat2(c, -s, s, c);\n}\n#endif\n'},5085:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: returns a 4x4 rotation matrix\nuse: rotate4d(<vec3> axis, <float> radians)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n\n*/\n\n#ifndef FNC_ROTATE3D\n#define FNC_ROTATE3D\nmat3 rotate3d(in vec3 axis, in float radians) {\n    axis = normalize(axis);\n    float s = sin(radians);\n    float c = cos(radians);\n    float oc = 1.0 - c;\n\n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c );\n}\n#endif\n'},3448:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: returns a 4x4 rotation matrix\nuse: rotate4d(<vec3> axis, <float> radians)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n\n*/\n\n#ifndef FNC_ROTATE4D\n#define FNC_ROTATE4D\nmat4 rotate4d(in vec3 axis, in float radians) {\n    axis = normalize(axis);\n    float s = sin(radians);\n    float c = cos(radians);\n    float oc = 1.0 - c;\n\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n#endif\n'},2109:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: returns a 4x4 rotation matrix\nuse: rotate4dX(<float> radians)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n\n*/\n\n#ifndef FNC_ROTATE4DX\n#define FNC_ROTATE4DX\nmat4 rotate4dX(in float phi){\n    return mat4(\n        vec4(1.,0.,0.,0),\n        vec4(0.,cos(phi),-sin(phi),0.),\n        vec4(0.,sin(phi),cos(phi),0.),\n        vec4(0.,0.,0.,1.));\n}\n#endif\n'},3538:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: returns a 4x4 rotation matrix\nuse: rotate4dY(<float> radians)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n\n*/\n\n#ifndef FNC_ROTATE4DY\n#define FNC_ROTATE4DY\nmat4 rotate4dY(in float theta){\n    return mat4(\n        vec4(cos(theta),0.,-sin(theta),0),\n        vec4(0.,1.,0.,0.),\n        vec4(sin(theta),0.,cos(theta),0.),\n        vec4(0.,0.,0.,1.));\n}\n#endif\n'},3553:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: returns a 4x4 rotation matrix\nuse: rotate4dZ(<float> radians)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n\n*/\n\n#ifndef FNC_ROTATE4DZ\n#define FNC_ROTATE4DZ\nmat4 rotate4dZ(in float psi){\n    return mat4(\n        vec4(cos(psi),-sin(psi),0.,0),\n        vec4(sin(psi),cos(psi),0.,0.),\n        vec4(0.,0.,1.,0.),\n        vec4(0.,0.,0.,1.));\n}\n#endif\n'},4782:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: clamp a value between 0 and 1\nuse: saturation(<float|vec2|vec3|vec4> value)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef FNC_SATURATE\n#define FNC_SATURATE\n// #define saturate(x) clamp(x, 0.0, 1.0)\nfloat saturate( float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec2 saturate( vec2 x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec3 saturate( vec3 x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec4 saturate( vec4 x) {\n    return clamp(x, 0.0, 1.0);\n}\n#endif'},608:e=>{e.exports="/*\nauthor: [Ian McEwan, Ashima Arts]\ndescription: \nuse: taylorInvSqrt(<float|vec4> x)\nLicense : |\n  Copyright (C) 2011 Ashima Arts. All rights reserved.\n  Distributed under the MIT License. See LICENSE file.\n  https://github.com/ashima/webgl-noise\n*/\n\n#ifndef FNC_TAYLORINVSQRT\n#define FNC_TAYLORINVSQRT\nfloat taylorInvSqrt(in float r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 taylorInvSqrt(in vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n#endif"},4324:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: Converts a RGB normal map into normal vectors\nuse: normalMap(<sampler2D> texture, <vec2> st, <vec2> pixel)\noptions:\n    NORMALMAP_Z: Steepness of z before normalization, defaults to .01\n    NORMALMAP_SAMPLER_FNC(POS_UV): Function used to sample into the normal map texture, defaults to texture2D(tex,POS_UV).r\nlicense: |\n    Copyright (c) 2017 Patricio Gonzalez Vivo.\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef NORMALMAP_Z\n#define NORMALMAP_Z .01\n#endif\n\n#ifndef NORMALMAP_SAMPLER_FNC\n#define NORMALMAP_SAMPLER_FNC(POS_UV) texture2D(tex,POS_UV).r\n#endif\n\n#ifndef FNC_NORMALMAP\n#define FNC_NORMALMAP\nvec3 normalMap(sampler2D tex, vec2 st, vec2 pixel) {\n    float center      = NORMALMAP_SAMPLER_FNC(st);\n    float topLeft     = NORMALMAP_SAMPLER_FNC(st - pixel);\n    float left        = NORMALMAP_SAMPLER_FNC(st - vec2(pixel.x, .0));\n    float bottomLeft  = NORMALMAP_SAMPLER_FNC(st + vec2(-pixel.x, pixel.y));\n    float top         = NORMALMAP_SAMPLER_FNC(st - vec2(.0, pixel.y));\n    float bottom      = NORMALMAP_SAMPLER_FNC(st + vec2(.0, pixel.y));\n    float topRight    = NORMALMAP_SAMPLER_FNC(st + vec2(pixel.x, -pixel.y));\n    float right       = NORMALMAP_SAMPLER_FNC(st + vec2(pixel.x, .0));\n    float bottomRight = NORMALMAP_SAMPLER_FNC(st + pixel);\n    \n    float dX = topRight + 2. * right + bottomRight - topLeft - 2. * left - bottomLeft;\n    float dY = bottomLeft + 2. * bottom + bottomRight - topLeft - 2. * top - topRight;\n\n    return normalize(vec3(dX, dY, NORMALMAP_Z) );\n}\n#endif'},7914:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: heatmap palette\nuse: heatmap(<float> value)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef FNC_HEATMAP\n#define FNC_HEATMAP\nvec3 heatmap(float v) {\n    vec3 r = v * 2.1 - vec3(1.8, 1.14, 0.3);\n    return 1.0 - r * r;\n}\n#endif\n\n/*\nauthor: Dennis Gustafsson\ndescription:  http://blog.tuxedolabs.com/2018/05/04/bokeh-depth-of-field-in-single-pass.html\nuse: textureDoF(<sampler2D> texture, <sampler2D> depth, <vec2> st, <float> focusPoint, <float> focusScale)\noptions:\n    TEXTUREDOF_TYPE:\n    TEXTUREDOF_BLUR_SIZE:\n    TEXTUREDOF_RAD_SCALE:\n    TEXTUREDOF_DEPTH_FNC(UV):\n    TEXTUREDOF_COLOR_FNC(UV):\n*/\n\n#ifndef FNC_TEXTUREDOF\n#define FNC_TEXTUREDOF\n\n#ifndef TEXTUREDOF_BLUR_SIZE\n#define TEXTUREDOF_BLUR_SIZE 6.\n#endif\n\n// Smaller = nicer blur, larger = faster\n#ifndef TEXTUREDOF_RAD_SCALE\n#define TEXTUREDOF_RAD_SCALE .5\n#endif\n\n#ifndef GOLDEN_ANGLE\n#define GOLDEN_ANGLE 2.39996323\n#endif\n\n#ifndef TEXTUREDOF_DEPTH_FNC\n#define TEXTUREDOF_DEPTH_FNC(UV)texture2D(texDepth,UV).r\n#endif\n\n#ifndef TEXTUREDOF_COLOR_FNC\n#define TEXTUREDOF_COLOR_FNC(UV)texture2D(tex,UV).rgb\n#endif\n\n#ifndef TEXTUREDOF_TYPE\n#define TEXTUREDOF_TYPE vec3\n#endif\n\nfloat getBlurSize(float depth,float focusPoint,float focusScale){\n    float coc = clamp((1./focusPoint-1./depth)*focusScale,-1.,1.);\n    return abs(coc) * TEXTUREDOF_BLUR_SIZE;\n}\n\n#ifdef PLATFORM_WEBGL\n\nTEXTUREDOF_TYPE textureDoF(sampler2D tex,sampler2D texDepth,vec2 texCoord,float focusPoint,float focusScale){\n    float pct=0.;\n    \n    float centerDepth = TEXTUREDOF_DEPTH_FNC(texCoord);\n    float centerSize = getBlurSize(centerDepth, focusPoint, focusScale);\n    vec2 pixelSize = 1.0/u_resolution.xy;\n    TEXTUREDOF_TYPE color = TEXTUREDOF_COLOR_FNC(texCoord);\n    \n    float total = 1.0;\n    float radius = TEXTUREDOF_RAD_SCALE;\n    for (float angle = 0.0 ; angle < 60.; angle += GOLDEN_ANGLE){\n        if (radius >= TEXTUREDOF_BLUR_SIZE)\n            break;\n\n        vec2 tc = texCoord + vec2(cos(angle), sin(angle)) * pixelSize * radius;\n        float sampleDepth = TEXTUREDOF_DEPTH_FNC(tc);\n        float sampleSize = getBlurSize(sampleDepth, focusPoint, focusScale);\n        if (sampleDepth > centerDepth)\n            sampleSize=clamp(sampleSize, 0.0, centerSize*2.0);\n        pct = smoothstep(radius-0.5, radius+0.5, sampleSize);\n        TEXTUREDOF_TYPE sampleColor = TEXTUREDOF_COLOR_FNC(tc);\n        #ifdef TEXTUREDOF_DEBUG\n        sampleColor.rgb = heatmap(pct*0.5+(angle/TEXTUREDOF_BLUR_SIZE)*0.1);\n        #endif\n        color += mix(color/total, sampleColor, pct);\n        total += 1.0;\n        radius += TEXTUREDOF_RAD_SCALE/radius;\n    }\n    return color/=total;\n}\n\n#else\n\nTEXTUREDOF_TYPE textureDoF(sampler2D tex, sampler2D texDepth, vec2 texCoord, float focusPoint, float focusScale) {\n    float pct = 0.0;\n    float ang = 0.0;\n\n    float centerDepth = TEXTUREDOF_DEPTH_FNC(texCoord);\n    float centerSize = getBlurSize(centerDepth, focusPoint, focusScale);\n    vec2 pixelSize = 1./u_resolution.xy;\n    TEXTUREDOF_TYPE color = TEXTUREDOF_COLOR_FNC(texCoord);\n\n    float tot = 1.0;\n    float radius = TEXTUREDOF_RAD_SCALE;\n    for (ang = 0.0; radius < TEXTUREDOF_BLUR_SIZE; ang += GOLDEN_ANGLE) {\n        vec2 tc = texCoord + vec2(cos(ang), sin(ang)) * pixelSize * radius;\n        float sampleDepth = TEXTUREDOF_DEPTH_FNC(tc);\n        float sampleSize = getBlurSize(sampleDepth, focusPoint, focusScale);\n        if (sampleDepth > centerDepth)\n            sampleSize = clamp(sampleSize, 0.0, centerSize*2.0);\n        pct = smoothstep(radius-0.5, radius+0.5, sampleSize);\n        TEXTUREDOF_TYPE sampleColor = TEXTUREDOF_COLOR_FNC(tc);\n        #ifdef TEXTUREDOF_DEBUG\n        sampleColor.rgb = heatmap(pct * 0.5 + (ang/TEXTUREDOF_BLUR_SIZE) * 0.1);\n        #endif\n        color += mix(color/tot, sampleColor, pct);\n        tot += 1.0;\n        radius += TEXTUREDOF_RAD_SCALE/radius;\n    }\n    return color /= tot;\n}\n\n#endif\n\n#endif'},6880:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: convertes QUILT of tiles into something the LookingGlass Volumetric display can render\nuse: textureQuilt(<sampler2D> texture, <vec4> calibration, <vec3> tile, <vec2> st, <vec2> resolution)\noptions:\n    TEXTUREQUILT_FLIPSUBP: \n    TEXTUREQUILT_SAMPLE_FNC(POS_UV): Function used to sample into the normal map texture, defaults to texture2D(tex,POS_UV)\nlicense: |\n    Copyright (c) 2021 Patricio Gonzalez Vivo.\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef TEXTUREQUILT_SAMPLE_FNC\n#define TEXTUREQUILT_SAMPLE_FNC(UV) texture2D(tex, UV)\n#endif\n\n#ifndef FNC_QUILT\n#define FNC_QUILT\nvec2 mapQuilt(vec3 tile, vec2 pos, float a) {\n    vec2 tile2 = tile.xy - 1.0;\n    vec2 dir = vec2(-1.0);\n\n    a = fract(a) * tile.y;\n    tile2.y += dir.y * floor(a);\n    a = fract(a) * tile.x;\n    tile2.x += dir.x * floor(a);\n    return (tile2 + pos) / tile.xy;\n}\n\nvec3 textureQuilt(sampler2D tex, vec4 calibration, vec3 tile, vec2 st, vec2 resolution) {\n    float pitch = -resolution.x / calibration.x  * calibration.y * sin(atan(abs(calibration.z)));\n    float tilt = resolution.y / (resolution.x * calibration.z);\n    float subp = 1.0 / (3.0 * resolution.x);\n    float subp2 = subp * pitch;\n\n    float a = (-st.x - st.y * tilt) * pitch - calibration.w;\n\n    vec3 color = vec3(0.0);\n    #ifdef TEXTUREQUILT_FLIPSUBP\n    color.r = TEXTUREQUILT_SAMPLE_FNC( mapQuilt(tile, st, a-2.0*subp2) ).r;\n    color.g = TEXTUREQUILT_SAMPLE_FNC( mapQuilt(tile, st, a-subp2) ).g;\n    color.b = TEXTUREQUILT_SAMPLE_FNC( mapQuilt(tile, st, a) ).b;\n    #else\n    color.r = TEXTUREQUILT_SAMPLE_FNC( mapQuilt(tile, st, a) ).r;\n    color.g = TEXTUREQUILT_SAMPLE_FNC( mapQuilt(tile, st, a-subp2) ).g;\n    color.b = TEXTUREQUILT_SAMPLE_FNC( mapQuilt(tile, st, a-2.0*subp2) ).b;\n    #endif\n    return color;\n}\n#endif'},6711:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: sampler shadowMap \nuse: textureShadow(<sampler2D> shadowMap, <vec4|vec3|vec2> _coord)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef FNC_TEXTURESHADOW\n#define FNC_TEXTURESHADOW\n\nfloat textureShadow(const sampler2D _shadowMap, in vec4 _coord) {\n    vec3 shadowCoord = _coord.xyz / _coord.w;\n    return texture2D(_shadowMap, shadowCoord.xy).r;\n}\n\nfloat textureShadow(const sampler2D _shadowMap, in vec3 _coord) {\n    return textureShadow(_shadowMap, vec4(_coord, 1.0));\n}\n\nfloat textureShadow(const sampler2D depths, vec2 uv, float compare){\n    return step(compare, texture2D(depths, uv).r );\n}\n\n#endif'},7899:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: Returns a circle-shaped SDF.\nuse: circleSDF(vec2 st[, vec2 center])\noptions:\n    CIRCLESDF_FNC(POS_UV) : function used to calculate the SDF, defaults to GLSL length function, use lengthSq for a different slope\nlicense: |\n    Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n    Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n    https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef CIRCLESDF_FNC\n#define CIRCLESDF_FNC(POS_UV) length(POS_UV)\n#endif\n\n#ifndef FNC_CIRCLESDF\n#define FNC_CIRCLESDF\n\nfloat circleSDF(in vec2 st, in vec2 center) {\n    return CIRCLESDF_FNC(st - center) * 2.;\n}\n\nfloat circleSDF(in vec2 st) {\n    return circleSDF(st, vec2(.5));\n}\n\n#endif\n'},2092:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: Returns a rectangular SDF\nuse: rectSDF(<vec2> st, <vec2> size)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n  Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n  https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_RECTSDF\n#define FNC_RECTSDF\nfloat rectSDF(in vec2 st, in vec2 s) {\n    st = st * 2. - 1.;\n    return max( abs(st.x / s.x),\n                abs(st.y / s.y) );\n}\n#endif\n\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: Returns a cross-shaped SDF\nuse: crossSDF(<vec2> st, size s)\nlicense: |\n    Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n    Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n    https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_CROSSSDF\n#define FNC_CROSSSDF\nfloat crossSDF(in vec2 st, in float s) {\n    vec2 size = vec2(.25, s);\n    return min(rectSDF(st.xy, size.xy),\n               rectSDF(st.xy, size.yx));\n}\n#endif\n'},9023:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: Returns a flower shaped SDF\nuse: flowerSDF(<vec2> st, <int> n_sides)\nlicense: |\n    Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n    Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n    https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_FLOWERSDF\n#define FNC_FLOWERSDF\nfloat flowerSDF(vec2 st, int N) {\n    st = st * 2.0 - 1.0;\n    float r = length(st) * 2.0;\n    float a = atan(st.y, st.x);\n    float v = float(N) * 0.5;\n    return 1.0 - (abs(cos(a * v)) *  0.5 + 0.5) / r;\n}\n#endif'},6881:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: Returns a heart shaped SDF\nuse: heartSDF(<vec2> st)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n  Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n  https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_HEARTSDF\n#define FNC_HEARTSDF\nfloat heartSDF(vec2 st) {\n    st -= vec2(0.5, 0.8);\n    float r = length(st) * 5.0;\n    st = normalize(st);\n    return r - ((st.y * pow(abs(st.x), 0.67)) / (st.y + 1.5) - (2.0) * st.y + 1.26);\n}\n#endif'},9455:e=>{e.exports='/*\\\nauthor: Patricio Gonzalez Vivo\ndescription: Returns a hexagon-shaped SDF\nuse: hexSDF(<vec2> st)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n  Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n  https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_HEXSDF\n#define FNC_HEXSDF\nfloat hexSDF(in vec2 st) {\n    st = abs(st * 2. - 1.);\n    return max(abs(st.y), st.x * .866025 + st.y * .5);\n}\n#endif\n'},6223:e=>{e.exports='#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef ONE_OVER_PI\n#define ONE_OVER_PI 0.31830988618\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n#ifndef GOLDEN_RATIO\n#define GOLDEN_RATIO 1.6180339887\n#endif\n#ifndef GOLDEN_RATIO_CONJUGATE \n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#endif\n#ifndef GOLDEN_ANGLE // (3.-sqrt(5.0))*PI radians\n#define GOLDEN_ANGLE 2.39996323\n#endif\n\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: Returns a sdf for a regular polygon with V sides.\nuse: polySDF(<vec2> st, int V)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n  Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n  https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_POLYSDF\n#define FNC_POLYSDF\nfloat polySDF(in vec2 st, in int V) {\n    st = st * 2. - 1.;\n    float a = atan(st.x, st.y) + PI;\n    float r = length(st);\n    float v = TAU / float(V);\n    return cos(floor(.5 + a / v) * v - a ) * r;\n}\n#endif\n'},122:e=>{e.exports='#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef ONE_OVER_PI\n#define ONE_OVER_PI 0.31830988618\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n#ifndef GOLDEN_RATIO\n#define GOLDEN_RATIO 1.6180339887\n#endif\n#ifndef GOLDEN_RATIO_CONJUGATE \n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#endif\n#ifndef GOLDEN_ANGLE // (3.-sqrt(5.0))*PI radians\n#define GOLDEN_ANGLE 2.39996323\n#endif\n\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: Returns a sdf for rays with N branches\nuse: raysSDF(<vec2> st, <int> N)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n  Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n  https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_RAYSSDF\n#define FNC_RAYSSDF\nfloat raysSDF(in vec2 st, in int N) {\n    st -= .5;\n    return fract(atan(st.y, st.x) / TAU * float(N));\n}\n#endif\n'},2704:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: Returns a rectangular SDF\nuse: rectSDF(<vec2> st, <vec2> size)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n  Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n  https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_RECTSDF\n#define FNC_RECTSDF\nfloat rectSDF(in vec2 st, in vec2 s) {\n    st = st * 2. - 1.;\n    return max( abs(st.x / s.x),\n                abs(st.y / s.y) );\n}\n#endif\n'},8958:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: Returns a triangle-shaped sdf\nuse: triSDF(<vec2> st)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n  Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n  https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_TRISDF\n#define FNC_TRISDF\nfloat triSDF(in vec2 st) {\n    st = (st * 2. - 1.) * 2.;\n    return max(abs(st.x) * .866025 + st.y * .5, -st.y * .5);\n}\n#endif\n\n\n/*\ndescription: Returns a rhomb-shaped sdf\nuse: rhombSDF(<vec2> st)\nauthor: Patricio Gonzalez Vivo\nlicense: |\n    Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n    Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n    https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_RHOMBSDF\n#define FNC_RHOMBSDF\nfloat rhombSDF(in vec2 st) {\n    return max(triSDF(st),\n               triSDF(vec2(st.x, 1. - st.y)));\n}\n#endif\n'},4260:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: Returns a spiral SDF\nuse: spiralSDF(<vec2> st, <float> turns)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n  Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n  https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_SPIRALSDF\n#define FNC_SPIRALSDF\nfloat spiralSDF(vec2 st, float t) {\n    st -= 0.5;\n    float r = dot(st, st);\n    float a = atan(st.y, st.x);\n    return abs(sin(fract(log(r) * t + a * 0.159)));\n}\n#endif'},3433:e=>{e.exports='#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef ONE_OVER_PI\n#define ONE_OVER_PI 0.31830988618\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n#ifndef GOLDEN_RATIO\n#define GOLDEN_RATIO 1.6180339887\n#endif\n#ifndef GOLDEN_RATIO_CONJUGATE \n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#endif\n#ifndef GOLDEN_ANGLE // (3.-sqrt(5.0))*PI radians\n#define GOLDEN_ANGLE 2.39996323\n#endif\n\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: Returns a star-shaped sdf with V branches\nuse: starSDF(<vec2> st, <int> V, <float> scale)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n  Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n  https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_STARSDF\n#define FNC_STARSDF\nfloat starSDF(in vec2 st, in int V, in float s) {\n    st = st * 4. - 2.;\n    float a = atan(st.y, st.x) / TAU;\n    float seg = a * float(V);\n    a = ((floor(seg) + .5) / float(V) +\n        mix(s, -s, step(.5, fract(seg))))\n        * TAU;\n    return abs(dot(vec2(cos(a), sin(a)),\n                   st));\n}\n#endif\n'},5866:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: Returns a triangle-shaped sdf\nuse: triSDF(<vec2> st)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n  Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n  https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_TRISDF\n#define FNC_TRISDF\nfloat triSDF(in vec2 st) {\n    st = (st * 2. - 1.) * 2.;\n    return max(abs(st.x) * .866025 + st.y * .5, -st.y * .5);\n}\n#endif\n'},2838:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: Returns a circle-shaped SDF.\nuse: circleSDF(vec2 st[, vec2 center])\noptions:\n    CIRCLESDF_FNC(POS_UV) : function used to calculate the SDF, defaults to GLSL length function, use lengthSq for a different slope\nlicense: |\n    Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n    Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n    https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef CIRCLESDF_FNC\n#define CIRCLESDF_FNC(POS_UV) length(POS_UV)\n#endif\n\n#ifndef FNC_CIRCLESDF\n#define FNC_CIRCLESDF\n\nfloat circleSDF(in vec2 st, in vec2 center) {\n    return CIRCLESDF_FNC(st - center) * 2.;\n}\n\nfloat circleSDF(in vec2 st) {\n    return circleSDF(st, vec2(.5));\n}\n\n#endif\n\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: Returns an almond-shaped sdf\nuse: vesicaSDF(<vec2> st, <float> w)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo. All rights reserved.\n  Distributed under BSD 3-clause "New" or "Revised" License. See LICENSE file at\n  https://github.com/patriciogonzalezvivo/PixelSpiritDeck\n*/\n\n#ifndef FNC_VESICASDF\n#define FNC_VESICASDF\nfloat vesicaSDF(in vec2 st, in float w) {\n    vec2 offset = vec2(w*.5,0.);\n    return max( circleSDF(st-offset),\n                circleSDF(st+offset));\n}\n#endif\n'},7225:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: Flip Y axis\nuse: flipY(<vec2> st)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n\n*/\n\n#ifndef FNC_FLIPY\n#define FNC_FLIPY\nvec2 flipY(in vec2 st) {\n  return vec2(st.x, 1. - st.y);\n}\n#endif\n'},7358:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: linearize depth\nuse: linearizeDepth(<float> depth, <float> near, <float> far)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n\n*/\n\n#ifndef FNC_LINEARIZE_DEPTH\n#define FNC_LINEARIZE_DEPTH\n\nfloat linearizeDepth(float depth, float near, float far) {\n    depth = 2.0 * depth - 1.0;\n    return (2.0 * near) / (far + near - depth * (far - near));\n}\n\n#endif'},9357:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: Fix the aspect ratio of a space keeping things squared for you.\nuse: ratio(vec2 st, vec2 st_size)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef FNC_RATIO\n#define FNC_RATIO\nvec2 ratio(in vec2 st, in vec2 s) {\n    return mix( vec2((st.x*s.x/s.y)-(s.x*.5-s.y*.5)/s.y,st.y),\n                vec2(st.x,st.y*(s.y/s.x)-(s.y*.5-s.x*.5)/s.x),\n                step(s.x,s.y));\n}\n#endif\n'},1904:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: returns a 2x2 rotation matrix\nuse: rotate2d(<float> radians)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n\n*/\n\n#ifndef FNC_ROTATE2D\n#define FNC_ROTATE2D\nmat2 rotate2d(in float radians){\n    float c = cos(radians);\n    float s = sin(radians);\n    return mat2(c, -s, s, c);\n}\n#endif\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: returns a 4x4 rotation matrix\nuse: rotate4d(<vec3> axis, <float> radians)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n\n*/\n\n#ifndef FNC_ROTATE4D\n#define FNC_ROTATE4D\nmat4 rotate4d(in vec3 axis, in float radians) {\n    axis = normalize(axis);\n    float s = sin(radians);\n    float c = cos(radians);\n    float oc = 1.0 - c;\n\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n#endif\n\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: rotate a 2D space by a radian radians\nuse: rotate(<vec3|vec2> st, float radians [, vec2 center])\noptions:\n  - CENTER_2D\n  - CENTER_3D\n  - CENTER_4D\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef FNC_ROTATE\n#define FNC_ROTATE\nvec2 rotate(in vec2 st, in float radians, in vec2 center) {\n  return rotate2d(radians) * (st - center) + center;\n}\n\nvec2 rotate(in vec2 st, in float radians) {\n  #ifdef CENTER_2D\n  return rotate(st, radians, CENTER_2D);\n  #else\n  return rotate(st, radians, vec2(.5));\n  #endif\n}\n\nvec3 rotate(in vec3 xyz, in float radians, in vec3 axis, in vec3 center) {\n  return (rotate4d(axis, radians) * vec4(xyz - center, 1.)).xyz + center;\n}\n\nvec3 rotate(in vec3 xyz, in float radians, in vec3 axis) {\n  #ifdef CENTER_3D\n  return rotate(xyz, radians, axis, CENTER_3D);\n  #else\n  return rotate(xyz, radians, axis, vec3(0.));\n  #endif\n}\n\nvec4 rotate(in vec4 xyzw, in float radians, in vec3 axis, in vec4 center) {\n  return rotate4d(axis, radians) * (xyzw - center) + center;\n}\n\nvec4 rotate(in vec4 xyzw, in float radians, in vec3 axis) {\n  #ifdef CENTER_4D\n  return rotate(xyzw, radians, axis, CENTER_4D);\n  #else\n  return rotate(xyzw, radians, axis, vec4(0.));\n  #endif\n}\n#endif\n'},8535:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: returns a 4x4 rotation matrix\nuse: rotate4dX(<float> radians)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n\n*/\n\n#ifndef FNC_ROTATE4DX\n#define FNC_ROTATE4DX\nmat4 rotate4dX(in float phi){\n    return mat4(\n        vec4(1.,0.,0.,0),\n        vec4(0.,cos(phi),-sin(phi),0.),\n        vec4(0.,sin(phi),cos(phi),0.),\n        vec4(0.,0.,0.,1.));\n}\n#endif\n\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: rotate a 2D space by a radian angle\nuse: rotateX(<vec3|vec4> pos, float radian [, vec3 center])\noptions:\n  - CENTER_3D\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef FNC_ROTATEX\n#define FNC_ROTATEX\nvec3 rotateX(in vec3 pos, in float radian, in vec3 center) {\n  return (rotate4dX(radian) * vec4(pos - center, 1.)).xyz + center;\n}\n\nvec3 rotateX(in vec3 pos, in float radian) {\n  #ifdef CENTER_3D\n  return rotateX(pos, radian, CENTER_3D);\n  #else\n  return rotateX(pos, radian, vec3(.0));\n  #endif\n}\n#endif\n'},5422:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: returns a 4x4 rotation matrix\nuse: rotate4dY(<float> radians)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n\n*/\n\n#ifndef FNC_ROTATE4DY\n#define FNC_ROTATE4DY\nmat4 rotate4dY(in float theta){\n    return mat4(\n        vec4(cos(theta),0.,-sin(theta),0),\n        vec4(0.,1.,0.,0.),\n        vec4(sin(theta),0.,cos(theta),0.),\n        vec4(0.,0.,0.,1.));\n}\n#endif\n\n\n/*\nauthor: Patricio Gonzalez Vivo\ndescription: rotate a 2D space by a radian angle\nuse: rotateY(<vec3> pos, float radian [, vec4 center])\noptions:\n  - CENTER_3D\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef FNC_ROTATEY\n#define FNC_ROTATEY\nvec3 rotateY(in vec3 pos, in float radian, in vec3 center) {\n  return (rotate4dY(radian) * vec4((pos - center), 1.)).xyz + center;\n}\n\nvec3 rotateY(in vec3 pos, in float radian) {\n  #ifdef CENTER_3D\n  return rotateY(pos, radian, CENTER_3D);\n  #else\n  return rotateY(pos, radian, vec3(.0));\n  #endif\n}\n#endif\n'},9174:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: returns a 4x4 rotation matrix\nuse: rotate4dZ(<float> radians)\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n\n*/\n\n#ifndef FNC_ROTATE4DZ\n#define FNC_ROTATE4DZ\nmat4 rotate4dZ(in float psi){\n    return mat4(\n        vec4(cos(psi),-sin(psi),0.,0),\n        vec4(sin(psi),cos(psi),0.,0.),\n        vec4(0.,0.,1.,0.),\n        vec4(0.,0.,0.,1.));\n}\n#endif\n\n\n/*\nfunction: rotateZ\nauthor: Patricio Gonzalez Vivo\ndescription: rotate a 2D space by a radian angle\nuse: rotateZ(<vec3|vec4> pos, float radian [, vec3 center])\noptions:\n  - CENTER_3D\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef FNC_ROTATEZ\n#define FNC_ROTATEZ\nvec3 rotateZ(in vec3 pos, in float radian, in vec3 center) {\n  return (rotate4dZ(radian) * vec4(pos - center, 0.) ).xyz + center;\n}\n\nvec3 rotateZ(in vec3 pos, in float radian) {\n  #ifdef CENTER_3D\n  return rotateZ(pos, radian, CENTER_3D);\n  #else\n  return rotateZ(pos, radian, vec3(.0));\n  #endif\n}\n#endif\n'},8457:e=>{e.exports='/*\nauthor: Patricio Gonzalez Vivo\ndescription: scale a 2D space variable\nuse: scale(<vec2> st, <vec2|float> scale_factor [, <vec2> center])\noptions:\n    - CENTER\n    - CENTER_2D\n    - CENTER_3D\nlicense: |\n  Copyright (c) 2017 Patricio Gonzalez Vivo.\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.    \n*/\n\n#ifndef FNC_SCALE\n#define FNC_SCALE\nfloat scale(in float st, in float s, in float center) {\n  return (st - center) * s + center;\n}\n\nfloat scale(in float st, in float s) {\n  #ifdef CENTER_2D\n  return scale(st,  s, CENTER);\n  #else\n  return scale(st,  s, .5);\n  #endif\n}\n\n\nvec2 scale(in vec2 st, in vec2 s, in vec2 center) {\n  return (st - center) * s + center;\n}\n\nvec2 scale(in vec2 st, in float value, in vec2 center) {\n  return scale(st, vec2(value), center);\n}\n\nvec2 scale(in vec2 st, in vec2 s) {\n  #ifdef CENTER_2D\n  return scale(st,  s, CENTER_2D);\n  #else\n  return scale(st,  s, vec2(.5));\n  #endif\n}\n\nvec2 scale(in vec2 st, in float value) {\n  return scale(st, vec2(value));\n}\n\nvec3 scale(in vec3 st, in vec3 s, in vec3 center) {\n  return (st - center) * s + center;\n}\n\nvec3 scale(in vec3 st, in float value, in vec3 center) {\n  return scale(st, vec3(value), center);\n}\n\nvec3 scale(in vec3 st, in vec3 s) {\n  #ifdef CENTER_3D\n  return scale(st,  s, CENTER_3D);\n  #else\n  return scale(st,  s, vec3(.5));\n  #endif\n}\n\nvec3 scale(in vec3 st, in float value) {\n  return scale(st, vec3(value));\n}\n#endif\n'},6828:(e,t,n)=>{n.d(t,{Z:()=>i});const i={normalMap:n(4324)}},8033:(e,t,n)=>{n.d(t,{Z:()=>i});const i={circleSDF:n(7899),flowerSDF:n(9023),hexSDF:n(9455),raysSDF:n(122),spiralSDF:n(4260),triSDF:n(5866),crossSDF:n(2092),heartSDF:n(6881),polySDF:n(6223),rectSDF:n(2704),starSDF:n(3433),vesicaSDF:n(2838),rhombSDF:n(8958)}},96:(e,t,n)=>{n.d(t,{Z:()=>i});const i={flipY:n(7225),ratio:n(9357),rotate:n(1904),rotateX:n(8535),rotateY:n(5422),rotateZ:n(9174),scale:n(8457),linearizeDepth:n(7358)}}},zc={};function Gc(e){var t=zc[e];if(void 0!==t)return t.exports;var n=zc[e]={exports:{}};return Bc[e](n,n.exports,Gc),n.exports}Gc.d=(e,t)=>{for(var n in t)Gc.o(t,n)&&!Gc.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},Gc.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);var Wc={};(()=>{Gc.d(Wc,{oQ:()=>e.Z,$_:()=>t.Z,Nn:()=>n.Z,ii:()=>i.Z,hX:()=>o.Z,L_:()=>r.Z,mA:()=>a.Z,dF:()=>s.Z,UP:()=>d,bq:()=>c.Z,Dh:()=>l.Z});var e=Gc(5682),t=Gc(9859),n=Gc(6764),i=Gc(2821),o=Gc(1996),r=Gc(4899),a=Gc(5923),s=Gc(6828),c=Gc(8033),l=Gc(96);const d={textureDof:Gc(7914),textureQuilt:Gc(6880),textureShadow:Gc(6711)}})();var Yc=Wc.oQ,Vc=Wc.$_,kc=Wc.Nn,jc=Wc.ii,Xc=Wc.hX,qc=Wc.L_,Kc=Wc.mA,Zc=Wc.dF,Jc=Wc.UP,Qc=Wc.bq,$c=Wc.Dh;console.log(t);const el=document.querySelector(".webgl");class tl{constructor(){this._Init()}_Init(){this.scene=new _o,this.time=new Ks,this.num=Math.random(),this.oldTime=0,this.InitShader(),this.InitCamera(),this.InitRenderer(),this.Update(),window.addEventListener("resize",(()=>{this.Resize()}))}InitTextShader(){this.fontLoader=new Ws,this.fontLoader.load("Sunf_Bold.json",(e=>{this.textParameters={font:e,size:2,height:.5,curveSegments:12,bevelEnabled:!0,bevelThickness:.03,bevelSize:.02,bevelOffset:0,bevelSegments:5},this.textGeometry=new ua("400",this.textParameters),this.textMaterial=new dn({transparent:!0,side:2,vertexShader:Uc,fragmentShader:Hc,uniforms:{u_time:{value:1},u_rand:{value:0},u_resolution:{type:"v2",value:new D},u_mouse:{type:"v2",value:new D}}}),console.log(Hc),this.textMesh=new on(this.textGeometry,this.textMaterial),this.scene.add(this.textMesh),this.textGeometry.computeBoundingBox(),this.textGeometry.center()}))}InitShader(){this.geometry=new On(2,2),this.material=new dn({extensions:{derivatives:"#extension GL_OES_standard_derivatives: enable"},transparent:!0,side:2,vertexShader:Uc,fragmentShader:Hc,uniforms:{u_time:{type:"f",value:1},u_rand:{value:0},u_resolution:{type:"v2",value:new D},u_mouse:{type:"v2",value:new D}}}),this.mesh=new on(this.geometry,this.material),this.scene.add(this.mesh),document.onmousemove=e=>{this.material.uniforms.u_mouse.value.x=e.pageX/window.innerWidth,this.material.uniforms.u_mouse.value.y=-e.pageY/window.innerHeight}}InitCamera(){this.camera=new fn(50,window.innerWidth/window.innerHeight,.1,100),this.camera.position.z=3,this.scene.add(this.camera)}InitLights(){this.ambientLight=new _s(16777215,.5),this.scene.add(this.ambientLight)}InitRenderer(){this.renderer=new xo({canvas:el,antialias:!0}),this.renderer.shadowMap.enabled=!0,this.renderer.shadowMap.type=2,this.renderer.setClearColor(4633),this.renderer.setPixelRatio(Math.min(window.devicePixelRatio,2)),this.renderer.setSize(window.innerWidth,window.innerHeight),this.renderer.render(this.scene,this.camera),this.renderer.outputEncoding=N}InitControls(){this.controls=new Pc(this.camera,el),this.controls.enableDamping=!0,this.controls.update()}InitTime(){this.time=new Ks}Resize(){this.camera.aspect=window.innerWidth/window.innerHeight,this.camera.updateProjectionMatrix(),this.renderer.setSize(window.innerWidth,window.innerHeight)}Update(){requestAnimationFrame((()=>{this.elapsedTime=this.time.getElapsedTime(),this.deltaTime=this.elapsedTime-this.oldTime,this.oldTime=this.elapsedTime,this.material.uniforms.u_time.value+=this.deltaTime,this.textMaterial&&(this.textMaterial.uniforms.u_time.value+=this.deltaTime),this.interval=setInterval((()=>{clearInterval(),this.num=Math.random()}),1e3),this.renderer.render(this.scene,this.camera),this.Update()}))}}let nl=null;window.addEventListener("DOMContentLoaded",(()=>{nl=new tl}))})();
//# sourceMappingURL=bundle.a175968aac811c9a160d.js.map